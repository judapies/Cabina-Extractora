CCS PCH C Compiler, Version 4.104, 5967               08-feb.-21 15:03

               Filename: D:\Laboratorio\Cabina Extractora de Gases y  Humos\2021\Cabina Extractora Sin Ductos 90TOPA GLCD CEMMIT #0045884XX OP202114\Schematic - Pruebas\RS485_I2C\RS485_I2C.lst

               ROM used: 2406 bytes (7%)
                         Largest free fragment is 30358
               RAM used: 1235 (60%) at main() level
                         1252 (61%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
0000:  GOTO   07D6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0304
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   038A
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0408
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Autoclave con Calderin 
.................... // Tiene Menú:Ciclo: Liquidos, Instrumental suave, Textil Instrumental y Caucho. 
.................... // Tiene 6 niveles programables para desfogue suave. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 2015 
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... #fuses XTPLL,WDT1024,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV4,VREGEN,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOBROWNOUT,NOLPT1OSC,NOMCLR 
.................... //#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV1,VREGEN,NOMCLR 
.................... #use delay(clock=16000000) 
*
0544:  MOVLW  04
0546:  MOVLB  4
0548:  SUBWF  xDD,F
054A:  BNC   0560
054C:  MOVLW  04
054E:  MOVWF  FEA
0550:  MOVLW  DD
0552:  MOVWF  FE9
0554:  MOVF   FEF,W
0556:  BZ    0560
0558:  BRA    055C
055A:  NOP   
055C:  DECFSZ FEF,F
055E:  BRA    055A
0560:  MOVLB  0
0562:  RETLW  00
....................  
.................... #use i2c(slave, slow, sda=PIN_B0, scl=PIN_B1, address=0xB0) 
*
03F0:  MOVF   FC9,W
03F2:  MOVFF  4E2,FC9
03F6:  BSF    FC6.4
03F8:  BCF    F9E.3
03FA:  BTFSC  FC7.0
03FC:  BRA    03FA
03FE:  CLRF   01
0400:  BTFSC  FC6.4
0402:  INCF   01,F
0404:  GOTO   043C (RETURN)
....................  
.................... #define   Buzzer_on           output_bit(PIN_A5,1) 
.................... #define   Buzzer_off          output_bit(PIN_A5,0) 
....................  
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 1023 
.................... #define MODBUS_SERIAL_BAUD 9600 
....................  
.................... //#use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_B4, RCV=PIN_B5,stream=PC, errors) 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C6   // Data transmit pin 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C7   // Data receive pin 
.................... //The following should be defined for RS485 communication 
.................... #define MODBUS_SERIAL_ENABLE_PIN   PIN_B2   // Controls DE pin for RS485 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin for RS485 
.................... //#define DEBUG_MSG(msg) fprintf(PC, msg) 
.................... //#define DEBUG_DATA(msg,data) fprintf(PC, msg, data) 
....................  
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009          Made PCD Compatible                                        //// 
.................... ////  August 21, 2009      Added Modbus ASCII protocol                                //// 
.................... ////  September 25, 2009   Fixed Bug in RCV_ON function                               //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
0336:  BTFSS  F9E.5
0338:  BRA    0336
033A:  MOVFF  FAB,17
033E:  MOVFF  FAE,01
0342:  BTFSS  17.1
0344:  BRA    034A
0346:  BCF    FAB.4
0348:  BSF    FAB.4
034A:  RETLW  00
*
0564:  BTFSS  F9E.4
0566:  BRA    0564
0568:  MOVWF  FAD
056A:  GOTO   0576 (RETURN)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #byte TXSTA=getenv("sfr:TXSTA") 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       int8 b[2]; 
....................       int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    int8 address; 
....................    int8 len;                                //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for high–order byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for low–order byte */ 
.................... const char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
0476:  BTFSS  F9E.5
0478:  BRA    047E
047A:  RCALL  0336
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
047C:  BRA    0476
....................         clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
047E:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
0480:  RETLW  00
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
0482:  BCF    F93.2
0484:  BCF    F8A.2
....................  
....................    RCV_ON(); 
0486:  RCALL  0476
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
0488:  MOVLW  20
048A:  IORLW  06
048C:  MOVWF  FCA
048E:  MOVLW  F9
0490:  MOVWF  FCB
....................       #endif 
....................       enable_interrupts(GLOBAL); 
0492:  MOVLW  C0
0494:  IORWF  FF2,F
....................    #endif 
.................... } 
0496:  GOTO   0890 (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
02F2:  BCF    F9D.1
....................    if (enable) { 
02F4:  MOVLB  4
02F6:  MOVF   xE1,F
02F8:  BZ    0300
....................       set_timer2(0); 
02FA:  CLRF   FCC
....................       clear_interrupt(INT_TIMER2); 
02FC:  BCF    F9E.1
....................       enable_interrupts(INT_TIMER2); 
02FE:  BSF    F9D.1
....................    } 
.................... } 
0300:  MOVLB  0
0302:  RETLW  00
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
0304:  MOVF   1D,W
0306:  SUBLW  02
0308:  BNZ   031E
030A:  MOVF   1E,F
030C:  BNZ   031E
030E:  MOVF   1F,F
0310:  BNZ   031E
0312:  BTFSC  1C.0
0314:  BRA    031E
....................       { 
....................          modbus_rx.len-=2; 
0316:  MOVLW  02
0318:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
031A:  BSF    1C.0
....................       } 
....................       else 
031C:  BRA    0320
....................          modbus_serial_new=FALSE; 
031E:  BCF    1C.0
....................     
....................       modbus_serial_crc.d=0xFFFF; 
0320:  MOVLW  FF
0322:  MOVWF  1F
0324:  MOVWF  1E
....................       modbus_serial_state=MODBUS_GETADDY; 
0326:  CLRF   1D
....................       modbus_enable_timeout(FALSE); 
0328:  MOVLB  4
032A:  CLRF   xE1
032C:  MOVLB  0
032E:  RCALL  02F2
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
0330:  BCF    F9E.1
0332:  GOTO   006C
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
034C:  MOVF   1F,W
034E:  MOVLB  4
0350:  XORWF  xE1,W
0352:  MOVWF  xE2
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0354:  CLRF   03
0356:  MOVF   xE2,W
0358:  MOVFF  FF2,4E3
035C:  BCF    FF2.7
035E:  MOVLB  0
0360:  RCALL  00AE
0362:  MOVLB  4
0364:  BTFSC  xE3.7
0366:  BSF    FF2.7
0368:  MOVWF  01
036A:  MOVF   1E,W
036C:  XORWF  01,W
036E:  MOVWF  1F
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0370:  CLRF   03
0372:  MOVF   xE2,W
0374:  MOVFF  FF2,4E3
0378:  BCF    FF2.7
037A:  MOVLB  0
037C:  RCALL  01D0
037E:  MOVLB  4
0380:  BTFSC  xE3.7
0382:  BSF    FF2.7
0384:  MOVWF  1E
....................    #endif 
.................... } 
0386:  MOVLB  0
0388:  RETLW  00
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
056E:  MOVLB  4
0570:  MOVF   xDC,W
0572:  MOVLB  0
0574:  BRA    0564
0576:  CLRF   16
0578:  BTFSC  FF2.7
057A:  BSF    16.7
057C:  BCF    FF2.7
....................       modbus_calc_crc(c); 
057E:  MOVFF  4DC,4E1
0582:  RCALL  034C
0584:  BTFSC  16.7
0586:  BSF    FF2.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
0588:  MOVLW  8A
058A:  MOVWF  00
058C:  DECFSZ 00,F
058E:  BRA    058C
0590:  NOP   
....................    #endif 
.................... } 
0592:  RETLW  00
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
038A:  RCALL  0336
038C:  MOVFF  01,4E0
....................     
....................    if (!modbus_serial_new) 
0390:  BTFSC  1C.0
0392:  BRA    03DE
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
0394:  MOVF   1D,F
0396:  BNZ   03AA
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0398:  MOVLW  FF
039A:  MOVWF  1F
039C:  MOVWF  1E
....................             modbus_rx.address = c; 
039E:  MOVFF  4E0,20
....................             modbus_serial_state++; 
03A2:  INCF   1D,F
....................             modbus_rx.len = 0; 
03A4:  CLRF   21
....................             modbus_rx.error=0; 
03A6:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
03A8:  BRA    03CE
03AA:  DECFSZ 1D,W
03AC:  BRA    03B6
....................          { 
....................             modbus_rx.func = c; 
03AE:  MOVFF  4E0,22
....................             modbus_serial_state++; 
03B2:  INCF   1D,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
03B4:  BRA    03CE
03B6:  MOVF   1D,W
03B8:  SUBLW  02
03BA:  BNZ   03CE
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
....................             modbus_rx.data[modbus_rx.len]=c; 
03BC:  MOVLW  24
03BE:  ADDWF  21,W
03C0:  MOVWF  FE9
03C2:  CLRF   FEA
03C4:  BTFSC  FD8.0
03C6:  INCF   FEA,F
03C8:  MOVFF  4E0,FEF
....................             modbus_rx.len++; 
03CC:  INCF   21,F
....................          } 
....................     
....................          modbus_calc_crc(c); 
03CE:  MOVFF  4E0,4E1
03D2:  RCALL  034C
....................          modbus_enable_timeout(TRUE); 
03D4:  MOVLW  01
03D6:  MOVLB  4
03D8:  MOVWF  xE1
03DA:  MOVLB  0
03DC:  RCALL  02F2
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
03DE:  CLRF   1B
03E0:  CLRF   1A
03E2:  MOVLW  27
03E4:  MOVWF  19
03E6:  MOVLW  10
03E8:  MOVWF  18
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
03EA:  BCF    F9E.5
03EC:  GOTO   006C
.................... void modbus_serial_send_start(int8 to, int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
0594:  MOVLW  FF
0596:  MOVWF  1F
0598:  MOVWF  1E
....................    #endif 
....................    modbus_serial_new=FALSE; 
059A:  BCF    1C.0
....................  
....................    RCV_OFF(); 
059C:  BCF    F9D.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
059E:  BCF    F93.2
05A0:  BSF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
05A2:  MOVLW  02
05A4:  MOVLB  4
05A6:  MOVWF  xDC
05A8:  MOVLW  B5
05AA:  MOVWF  xDD
05AC:  MOVLB  0
05AE:  RCALL  0544
05B0:  MOVLB  4
05B2:  DECFSZ xDC,F
05B4:  BRA    05A8
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
05B6:  MOVFF  4DA,4DC
05BA:  MOVLB  0
05BC:  RCALL  056E
....................    modbus_serial_putc(func); 
05BE:  MOVFF  4DB,4DC
05C2:  RCALL  056E
.................... } 
05C4:  RETLW  00
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
05C6:  MOVFF  1F,4DB
....................       crc_low=modbus_serial_crc.b[0]; 
05CA:  MOVFF  1E,4DA
....................     
....................       modbus_serial_putc(crc_high); 
05CE:  MOVFF  4DB,4DC
05D2:  RCALL  056E
....................       modbus_serial_putc(crc_low); 
05D4:  MOVFF  4DA,4DC
05D8:  RCALL  056E
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
05DA:  BTFSS  FAC.1
05DC:  BRA    05DA
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
05DE:  MOVLW  02
05E0:  MOVLB  4
05E2:  MOVWF  xDC
05E4:  MOVLW  B5
05E6:  MOVWF  xDD
05E8:  MOVLB  0
05EA:  RCALL  0544
05EC:  MOVLB  4
05EE:  DECFSZ xDC,F
05F0:  BRA    05E4
....................    #endif 
....................  
....................    RCV_ON(); 
05F2:  MOVLB  0
05F4:  RCALL  0476
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
05F6:  BCF    F93.2
05F8:  BCF    F8A.2
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
05FA:  MOVLW  FF
05FC:  MOVWF  1F
05FE:  MOVWF  1E
....................    #endif 
.................... } 
0600:  RETLW  00
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
0602:  BTFSC  1C.0
0604:  BRA    060E
....................       return FALSE; 
0606:  MOVLW  00
0608:  MOVWF  01
060A:  BRA    0620
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
060C:  BRA    061A
060E:  BTFSS  22.7
0610:  BRA    061A
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0612:  MOVFF  24,23
....................       modbus_rx.len = 1; 
0616:  MOVLW  01
0618:  MOVWF  21
....................    } 
....................    modbus_serial_new=FALSE; 
061A:  BCF    1C.0
....................    return TRUE; 
061C:  MOVLW  01
061E:  MOVWF  01
.................... } 
0620:  RETLW  00
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
0622:  MOVFF  4D3,4DA
0626:  MOVLW  03
0628:  MOVLB  4
062A:  MOVWF  xDB
062C:  MOVLB  0
062E:  RCALL  0594
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0630:  MOVFF  4D5,4D8
0634:  MOVFF  4D5,4DC
0638:  RCALL  056E
....................    modbus_serial_putc(make8(start_address,0)); 
063A:  MOVFF  4D4,4D8
063E:  MOVFF  4D4,4DC
0642:  RCALL  056E
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0644:  MOVFF  4D7,4D8
0648:  MOVFF  4D7,4DC
064C:  RCALL  056E
....................    modbus_serial_putc(make8(quantity,0)); 
064E:  MOVFF  4D6,4D8
0652:  MOVFF  4D6,4DC
0656:  RCALL  056E
....................  
....................    modbus_serial_send_stop(); 
0658:  RCALL  05C6
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
065A:  MOVLB  4
065C:  MOVF   xD3,F
065E:  BZ    06A4
0660:  MOVLB  0
0662:  RCALL  0602
0664:  MOVF   01,F
0666:  BNZ   068E
0668:  MOVLW  FF
066A:  ADDWF  18,F
066C:  BTFSS  FD8.0
066E:  ADDWF  19,F
0670:  BTFSS  FD8.0
0672:  ADDWF  1A,F
0674:  BTFSS  FD8.0
0676:  ADDWF  1B,F
0678:  MOVF   18,F
067A:  BNZ   0688
067C:  MOVF   19,F
067E:  BNZ   0688
0680:  MOVF   1A,F
0682:  BNZ   0688
0684:  MOVF   1B,F
0686:  BZ    068E
0688:  BRA    068A
068A:  BRA    068C
068C:  BRA    0662
068E:  MOVF   18,F
0690:  BNZ   06A2
0692:  MOVF   19,F
0694:  BNZ   06A2
0696:  MOVF   1A,F
0698:  BNZ   06A2
069A:  MOVF   1B,F
069C:  BNZ   06A2
069E:  MOVLW  0C
06A0:  MOVWF  23
06A2:  MOVLB  4
06A4:  CLRF   1B
06A6:  CLRF   1A
06A8:  MOVLW  27
06AA:  MOVWF  19
06AC:  MOVLW  10
06AE:  MOVWF  18
....................  
....................    return modbus_rx.error; 
06B0:  MOVFF  23,01
.................... } 
06B4:  MOVLB  0
06B6:  GOTO   06D0 (RETURN)
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
*
071A:  MOVFF  4D5,4DA
071E:  MOVLW  06
0720:  MOVLB  4
0722:  MOVWF  xDB
0724:  MOVLB  0
0726:  RCALL  0594
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
0728:  MOVFF  4D7,4DA
072C:  MOVFF  4D7,4DC
0730:  RCALL  056E
....................    modbus_serial_putc(make8(reg_address,0)); 
0732:  MOVFF  4D6,4DA
0736:  MOVFF  4D6,4DC
073A:  RCALL  056E
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
073C:  MOVFF  4D9,4DA
0740:  MOVFF  4D9,4DC
0744:  RCALL  056E
....................    modbus_serial_putc(make8(reg_value,0)); 
0746:  MOVFF  4D8,4DA
074A:  MOVFF  4D8,4DC
074E:  RCALL  056E
....................  
....................    modbus_serial_send_stop(); 
0750:  RCALL  05C6
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
0752:  MOVLB  4
0754:  MOVF   xD5,F
0756:  BZ    079C
0758:  MOVLB  0
075A:  RCALL  0602
075C:  MOVF   01,F
075E:  BNZ   0786
0760:  MOVLW  FF
0762:  ADDWF  18,F
0764:  BTFSS  FD8.0
0766:  ADDWF  19,F
0768:  BTFSS  FD8.0
076A:  ADDWF  1A,F
076C:  BTFSS  FD8.0
076E:  ADDWF  1B,F
0770:  MOVF   18,F
0772:  BNZ   0780
0774:  MOVF   19,F
0776:  BNZ   0780
0778:  MOVF   1A,F
077A:  BNZ   0780
077C:  MOVF   1B,F
077E:  BZ    0786
0780:  BRA    0782
0782:  BRA    0784
0784:  BRA    075A
0786:  MOVF   18,F
0788:  BNZ   079A
078A:  MOVF   19,F
078C:  BNZ   079A
078E:  MOVF   1A,F
0790:  BNZ   079A
0792:  MOVF   1B,F
0794:  BNZ   079A
0796:  MOVLW  0C
0798:  MOVWF  23
079A:  MOVLB  4
079C:  CLRF   1B
079E:  CLRF   1A
07A0:  MOVLW  27
07A2:  MOVWF  19
07A4:  MOVLW  10
07A6:  MOVWF  18
....................  
....................    return modbus_rx.error; 
07A8:  MOVFF  23,01
.................... } 
07AC:  MOVLB  0
07AE:  GOTO   07CC (RETURN)
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity, 
....................                            int8 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = (int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity, 
....................                            int16 *values) 
.................... { 
....................    int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(int8 address, int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(int8 address, int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start, 
....................                                     int16 read_quantity, int16 write_start, 
....................                                     int16 write_quantity, 
....................                                     int16 *write_registers_value) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    int8 record_length; 
....................    int8 reference_type; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    int8 reference_type; 
....................    int16 file_number; 
....................    int16 record_number; 
....................    int16 record_length; 
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count,  
....................                                     int8 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *reg_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count,  
....................                                         int16 *input_data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address,  
....................                                     int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address,  
....................                                         int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(int8 address, int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status,  
....................                                         int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status, 
....................                                     int16 event_count, int16 message_count,  
....................                                     int8 *events, int8 events_len) 
.................... { 
....................    int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address,  
....................                                         int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address,  
....................                                             int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status, 
....................                               int8 *data, int8 data_len) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address, 
....................                            int16 AND_mask, int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len,  
....................                                                 int16 *data) 
.................... { 
....................    int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data) 
.................... { 
....................    int8 i; 
....................    int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(int8 address, int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define MODBUS_SLAVE_ADDRESS 0x01 
....................  
.................... // Variables para Pt100 
.................... int8 instruccion=0,address=0,regl=0,regh=0,i=0,pwm1l=0,pwm1h=0,pwm2l=0,pwm2h=0,address_ant=0,reg_ant=0,crc1=0,crc2=0; 
.................... int16 reg=0,pwm1=0,pwm2=0,temporal=0; 
....................  
.................... int8 fstate;                     //Guardara el estado del bus I2C 
.................... int8 posicion, buffer[50], txbuf[50],rxbuf[50];     //Buffer de memoria 
....................  
.................... #INT_SSP 
.................... void ssp_interupt (){ 
....................    int8 incoming;                //Variable donde se recibe el byte que manda el maestro 
....................     
....................    fstate = i2c_isr_state();    //Lectura del estado del bus I2c la interrupción 
*
0408:  BTFSC  FC7.5
040A:  BRA    0414
040C:  MOVLB  4
040E:  CLRF   xD0
0410:  BTFSC  FC7.2
0412:  BSF    xD0.7
0414:  MOVLB  4
0416:  MOVF   xD0,W
0418:  INCF   xD0,F
041A:  MOVWF  x38
....................  
....................    if(fstate == 0x80) {          
041C:  MOVF   x38,W
041E:  SUBLW  80
0420:  BNZ   0440
....................        //Manda al maestro la información contenida en la posición de memoria que le ha solicitado 
....................       i2c_write (txbuf[posicion]); 
0422:  CLRF   03
0424:  MOVF   x39,W
0426:  ADDLW  6C
0428:  MOVWF  FE9
042A:  MOVLW  04
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  MOVFF  FEF,4E1
0434:  MOVFF  4E1,4E2
0438:  MOVLB  0
043A:  BRA    03F0
....................    }else {                              //Sino es que hay dato en el bus I2C... 
043C:  BRA    0470
043E:  MOVLB  4
....................       incoming = i2c_read();           //... lo lee 
0440:  BCF    FC6.6
0442:  BTFSS  F9E.3
0444:  BRA    0442
0446:  MOVF   FC9,W
0448:  BSF    FC6.4
044A:  MOVWF  xE0
....................       if (fState == 1) {          //Información recibida corresponde a la posicion 
044C:  DECFSZ x38,W
044E:  BRA    0456
....................          posicion = incoming;          //Se guarda posición 
0450:  MOVFF  4E0,439
....................       } 
....................       else if (fState == 2) {          //Información recibida corresponde al dato 
0454:  BRA    046E
0456:  MOVF   x38,W
0458:  SUBLW  02
045A:  BNZ   046E
....................          rxbuf[posicion] = incoming; 
045C:  CLRF   03
045E:  MOVF   x39,W
0460:  ADDLW  9E
0462:  MOVWF  FE9
0464:  MOVLW  04
0466:  ADDWFC 03,W
0468:  MOVWF  FEA
046A:  MOVFF  4E0,FEF
046E:  MOVLB  0
....................       } 
....................   } 
.................... } 
....................  
0470:  BCF    F9E.3
0472:  GOTO   006C
.................... void Lee_Vector(void){ 
....................    instruccion=rxbuf[0]; 
*
04BC:  MOVFF  49E,423
....................    address=rxbuf[1]; 
04C0:  MOVFF  49F,424
....................    regl=rxbuf[2]; 
04C4:  MOVFF  4A0,425
....................    regh=rxbuf[3]; 
04C8:  MOVFF  4A1,426
....................    reg=(regh*256)+regl; 
04CC:  MOVLB  4
04CE:  CLRF   xD2
04D0:  MOVFF  426,4D1
04D4:  MOVLW  01
04D6:  MOVWF  xD4
04D8:  CLRF   xD3
04DA:  MOVLB  0
04DC:  RCALL  049A
04DE:  MOVLB  4
04E0:  MOVF   x25,W
04E2:  ADDWF  01,W
04E4:  MOVWF  x30
04E6:  MOVLW  00
04E8:  ADDWFC 02,W
04EA:  MOVWF  x31
....................    pwm1l=rxbuf[4]; 
04EC:  MOVFF  4A2,428
....................    pwm1h=rxbuf[5]; 
04F0:  MOVFF  4A3,429
....................    pwm2l=rxbuf[6]; 
04F4:  MOVFF  4A4,42A
....................    pwm2h=rxbuf[7]; 
04F8:  MOVFF  4A5,42B
....................    pwm1=(pwm1h*256)+pwm1l; 
04FC:  CLRF   xD2
04FE:  MOVFF  429,4D1
0502:  MOVLW  01
0504:  MOVWF  xD4
0506:  CLRF   xD3
0508:  MOVLB  0
050A:  RCALL  049A
050C:  MOVLB  4
050E:  MOVF   x28,W
0510:  ADDWF  01,W
0512:  MOVWF  x32
0514:  MOVLW  00
0516:  ADDWFC 02,W
0518:  MOVWF  x33
....................    pwm2=(pwm2h*256)+pwm2l; 
051A:  CLRF   xD2
051C:  MOVFF  42B,4D1
0520:  MOVLW  01
0522:  MOVWF  xD4
0524:  CLRF   xD3
0526:  MOVLB  0
0528:  RCALL  049A
052A:  MOVLB  4
052C:  MOVF   x2A,W
052E:  ADDWF  01,W
0530:  MOVWF  x34
0532:  MOVLW  00
0534:  ADDWFC 02,W
0536:  MOVWF  x35
....................    crc1=rxbuf[8]; 
0538:  MOVFF  4A6,42E
....................    crc2=rxbuf[9]; 
053C:  MOVFF  4A7,42F
.................... } 
0540:  MOVLB  0
0542:  RETLW  00
....................  
.................... int8 swap_bits(int8 c) 
.................... { 
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0) 
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0); 
.................... } 
....................  
.................... void read_all_coils() 
.................... { 
....................    //DEBUG_MSG("Coils:\r\n"); 
....................    if(!(modbus_read_coils(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=1; i < (modbus_rx.len); ++i) 
....................          //DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_inputs() 
.................... { 
....................    //DEBUG_MSG("Inputs:\r\n"); 
....................    if(!(modbus_read_discrete_input(MODBUS_SLAVE_ADDRESS,0,8))) 
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=1; i < (modbus_rx.len); ++i) 
....................       //   DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void read_all_holding(int8 start,int8 size) 
.................... { 
....................    //DEBUG_MSG("Holding Registers:\r\n"); 
....................    if(!(modbus_read_holding_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
*
06BA:  MOVLW  01
06BC:  MOVLB  4
06BE:  MOVWF  xD3
06C0:  CLRF   xD5
06C2:  MOVFF  4D1,4D4
06C6:  CLRF   xD7
06C8:  MOVFF  4D2,4D6
06CC:  MOVLB  0
06CE:  BRA    0622
06D0:  MOVF   01,F
06D2:  BNZ   0714
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       for(i=1; i < (modbus_rx.len); ++i){ 
06D4:  MOVLW  01
06D6:  MOVLB  4
06D8:  MOVWF  x27
06DA:  MOVF   21,W
06DC:  SUBWF  x27,W
06DE:  BC    0712
....................          //DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................          if(i<20) 
06E0:  MOVF   x27,W
06E2:  SUBLW  13
06E4:  BNC   070E
....................             txbuf[i]=(int8)modbus_rx.data[i]; 
06E6:  CLRF   03
06E8:  MOVF   x27,W
06EA:  ADDLW  6C
06EC:  MOVWF  01
06EE:  MOVLW  04
06F0:  ADDWFC 03,F
06F2:  MOVLW  24
06F4:  ADDWF  x27,W
06F6:  MOVWF  FE9
06F8:  CLRF   FEA
06FA:  BTFSC  FD8.0
06FC:  INCF   FEA,F
06FE:  MOVFF  FEF,4D5
0702:  MOVFF  03,FEA
0706:  MOVFF  01,FE9
070A:  MOVFF  4D5,FEF
....................       } 
070E:  INCF   x27,F
0710:  BRA    06DA
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    }  
....................    else 
0712:  BRA    0714
0714:  MOVLB  0
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
0716:  GOTO   092E (RETURN)
....................  
.................... void read_all_input_reg(int8 start,int8 size) 
.................... { 
....................    //DEBUG_MSG("Input Registers:\r\n"); 
....................    if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,start,size))) 
....................    { 
....................       //DEBUG_MSG("Data: ");       
....................       //for(i=1; i < (modbus_rx.len); ++i) 
....................          //DEBUG_DATA("%X ", modbus_rx.data[i]);        
....................         
....................        //DEBUG_MSG("\r\n\r\n"); 
....................  
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
.................... void write_coil() 
.................... { 
....................    //DEBUG_MSG("Writing Single Coil:\r\n"); 
....................    if(!(modbus_write_single_coil(MODBUS_SLAVE_ADDRESS,6,TRUE))) 
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=0; i < (modbus_rx.len); ++i) 
....................       //   DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_reg(int16 address,int16 reg) 
.................... { 
....................    //DEBUG_MSG("Writing Single Register:\r\n"); 
....................    if(!(modbus_write_single_register(MODBUS_SLAVE_ADDRESS,address,reg))) 
*
07B2:  MOVLW  01
07B4:  MOVLB  4
07B6:  MOVWF  xD5
07B8:  MOVFF  4D2,4D7
07BC:  MOVFF  4D1,4D6
07C0:  MOVFF  4D4,4D9
07C4:  MOVFF  4D3,4D8
07C8:  MOVLB  0
07CA:  BRA    071A
07CC:  MOVF   01,F
07CE:  BNZ   07D2
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=0; i < (modbus_rx.len); ++i) 
....................          //DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
07D0:  BRA    07D2
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
07D2:  GOTO   0960 (RETURN)
....................  
.................... void write_coils() 
.................... { 
....................    int8 coils[1] = { 0x50 }; 
....................    //DEBUG_MSG("Writing Multiple Coils:\r\n"); 
....................    if(!(modbus_write_multiple_coils(MODBUS_SLAVE_ADDRESS,0,8,coils))) 
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=0; i < (modbus_rx.len); ++i) 
....................       //   DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void write_regs() 
.................... { 
....................    int16 reg_array[2] = {0x1111, 0x2222}; 
....................    //DEBUG_MSG("Writing Multiple Registers:\r\n"); 
....................    if(!(modbus_write_multiple_registers(MODBUS_SLAVE_ADDRESS,0,2,reg_array))) 
....................    { 
....................       //DEBUG_MSG("Data: "); 
....................       //for(i=0; i < (modbus_rx.len); ++i) 
....................       //   DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    }    
.................... } 
....................  
.................... void unknown_func() 
.................... { 
....................    //DEBUG_MSG("Trying unknown function\r\n"); 
....................    //DEBUG_MSG("Diagnostic:\r\n"); 
....................    if(!(modbus_diagnostics(MODBUS_SLAVE_ADDRESS,0,0))) 
....................    { 
....................       //DEBUG_MSG("Data:"); 
....................       //for(i=0; i < (modbus_rx.len); ++i) 
....................       //   DEBUG_DATA("%X ", modbus_rx.data[i]); 
....................       //DEBUG_MSG("\r\n\r\n"); 
....................    } 
....................    else 
....................    { 
....................       //DEBUG_DATA("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
....................    } 
.................... } 
....................  
....................  
.................... void main() 
.................... { 
07D6:  CLRF   FF8
07D8:  BCF    FD0.7
07DA:  BSF    07.7
07DC:  CLRF   FEA
07DE:  CLRF   FE9
07E0:  BSF    F93.1
07E2:  BSF    F93.0
07E4:  MOVLW  B0
07E6:  MOVWF  FC8
07E8:  MOVLW  36
07EA:  MOVWF  FC6
07EC:  BSF    FB8.3
07EE:  MOVLW  A0
07F0:  MOVWF  FAF
07F2:  MOVLW  01
07F4:  MOVWF  FB0
07F6:  MOVLW  A6
07F8:  MOVWF  FAC
07FA:  MOVLW  90
07FC:  MOVWF  FAB
07FE:  CLRF   1B
0800:  CLRF   1A
0802:  MOVLW  27
0804:  MOVWF  19
0806:  MOVLW  10
0808:  MOVWF  18
080A:  BCF    1C.0
080C:  CLRF   1D
080E:  MOVLB  4
0810:  CLRF   x23
0812:  CLRF   x24
0814:  CLRF   x25
0816:  CLRF   x26
0818:  CLRF   x27
081A:  CLRF   x28
081C:  CLRF   x29
081E:  CLRF   x2A
0820:  CLRF   x2B
0822:  CLRF   x2C
0824:  CLRF   x2D
0826:  CLRF   x2E
0828:  CLRF   x2F
082A:  CLRF   x31
082C:  CLRF   x30
082E:  CLRF   x33
0830:  CLRF   x32
0832:  CLRF   x35
0834:  CLRF   x34
0836:  CLRF   x37
0838:  CLRF   x36
083A:  MOVF   FC1,W
083C:  ANDLW  C0
083E:  IORLW  0F
0840:  MOVWF  FC1
0842:  MOVLW  07
0844:  MOVWF  FB4
0846:  CLRF   17
0848:  MOVLW  03
084A:  MOVWF  xD0
....................    fState = 0; 
084C:  CLRF   x38
....................    for (posicion=0;posicion<0x10;posicion++){ 
084E:  CLRF   x39
0850:  MOVF   x39,W
0852:  SUBLW  0F
0854:  BNC   088A
....................       buffer[posicion] = 0x00; 
0856:  CLRF   03
0858:  MOVF   x39,W
085A:  ADDLW  3A
085C:  MOVWF  FE9
085E:  MOVLW  04
0860:  ADDWFC 03,W
0862:  MOVWF  FEA
0864:  CLRF   FEF
....................       txbuf[posicion] = 0x00; 
0866:  CLRF   03
0868:  MOVF   x39,W
086A:  ADDLW  6C
086C:  MOVWF  FE9
086E:  MOVLW  04
0870:  ADDWFC 03,W
0872:  MOVWF  FEA
0874:  CLRF   FEF
....................       rxbuf[posicion] = 0x00; 
0876:  CLRF   03
0878:  MOVF   x39,W
087A:  ADDLW  9E
087C:  MOVWF  FE9
087E:  MOVLW  04
0880:  ADDWFC 03,W
0882:  MOVWF  FEA
0884:  CLRF   FEF
....................    } 
0886:  INCF   x39,F
0888:  BRA    0850
....................    enable_interrupts(INT_SSP); 
088A:  BSF    F9D.3
....................    modbus_init();    
088C:  MOVLB  0
088E:  BRA    0482
....................    setup_wdt(WDT_ON); 
0890:  BSF    FD1.0
....................    setup_timer_2(T2_DIV_BY_16, 255, 16);  
0892:  MOVLW  78
0894:  IORLW  06
0896:  MOVWF  FCA
0898:  MOVLW  FF
089A:  MOVWF  FCB
....................    setup_ccp1(CCP_PWM); 
089C:  BCF    F94.2
089E:  BCF    F8B.2
08A0:  MOVLW  0C
08A2:  MOVWF  FBD
....................    setup_ccp2(CCP_PWM); 
08A4:  BCF    F94.1
08A6:  BCF    F8B.1
08A8:  MOVWF  FBA
....................    set_pwm1_duty (0); 
08AA:  CLRF   FBE
....................    set_pwm2_duty (0); 
08AC:  CLRF   FBB
....................    enable_interrupts(global); 
08AE:  MOVLW  C0
08B0:  IORWF  FF2,F
....................    //DEBUG_MSG("\r\nInitializing..."); 
....................    //DEBUG_MSG("...ready\r\n"); 
....................    Lee_Vector(); 
08B2:  RCALL  04BC
....................     
....................  
.................... while(true) 
.................... { 
....................    restart_wdt(); 
08B4:  CLRWDT
....................    txbuf[0]=10; 
08B6:  MOVLW  0A
08B8:  MOVLB  4
08BA:  MOVWF  x6C
....................    txbuf[19]=128; 
08BC:  MOVLW  80
08BE:  MOVWF  x7F
....................    temporal++;    
08C0:  INCF   x36,F
08C2:  BTFSC  FD8.2
08C4:  INCF   x37,F
....................    set_pwm1_duty(pwm1); 
08C6:  MOVFF  433,02
08CA:  MOVFF  432,01
08CE:  RRCF   02,F
08D0:  RRCF   01,F
08D2:  RRCF   02,F
08D4:  RRCF   01,F
08D6:  RRCF   02,F
08D8:  MOVFF  01,FBE
08DC:  RRCF   02,F
08DE:  RRCF   02,W
08E0:  ANDLW  30
08E2:  MOVWF  00
08E4:  MOVF   FBD,W
08E6:  ANDLW  CF
08E8:  IORWF  00,W
08EA:  MOVWF  FBD
....................    set_pwm2_duty(pwm2); 
08EC:  MOVFF  435,02
08F0:  MOVFF  434,01
08F4:  RRCF   02,F
08F6:  RRCF   01,F
08F8:  RRCF   02,F
08FA:  RRCF   01,F
08FC:  RRCF   02,F
08FE:  MOVFF  01,FBB
0902:  RRCF   02,F
0904:  RRCF   02,W
0906:  ANDLW  30
0908:  MOVWF  00
090A:  MOVF   FBA,W
090C:  ANDLW  CF
090E:  IORWF  00,W
0910:  MOVWF  FBA
....................    if(crc1==txbuf[0] && crc2==txbuf[19]){ 
0912:  MOVF   x6C,W
0914:  SUBWF  x2E,W
0916:  BNZ   0962
0918:  MOVF   x7F,W
091A:  SUBWF  x2F,W
091C:  BNZ   0962
....................       if(instruccion==3){ 
091E:  MOVF   x23,W
0920:  SUBLW  03
0922:  BNZ   0930
....................          read_all_holding(0,8); 
0924:  CLRF   xD1
0926:  MOVLW  08
0928:  MOVWF  xD2
092A:  MOVLB  0
092C:  BRA    06BA
092E:  MOVLB  4
....................       } 
....................       if(instruccion==5){ 
0930:  MOVF   x23,W
0932:  SUBLW  05
0934:  BNZ   0962
....................          if(address_ant!=address){ 
0936:  MOVF   x24,W
0938:  SUBWF  x2C,W
093A:  BZ    0962
....................             address_ant=address; 
093C:  MOVFF  424,42C
....................             if(reg_ant!=reg){ 
0940:  MOVF   x30,W
0942:  SUBWF  x2D,W
0944:  BNZ   094A
0946:  MOVF   x31,F
0948:  BZ    0962
....................                reg_ant=reg; 
094A:  MOVFF  430,42D
....................                write_reg(address,reg); 
094E:  CLRF   xD2
0950:  MOVFF  424,4D1
0954:  MOVFF  431,4D4
0958:  MOVFF  430,4D3
095C:  MOVLB  0
095E:  BRA    07B2
0960:  MOVLB  4
....................             }          
....................          } 
....................       }   
....................    } 
....................    //DEBUG_DATA("Inst: %02u \r\n", instruccion); 
....................    //DEBUG_DATA("Address: %02u \r\n", address); 
....................    Lee_Vector();    
0962:  MOVLB  0
0964:  RCALL  04BC
.................... } 
0966:  BRA    08B4
.................... } 
0968:  SLEEP 

Configuration Fuses:
   Word  1: 0238   XTPLL NOIESO NOFCMEN PLL1 CPUDIV4 USBDIV
   Word  2: 1539   NOBROWNOUT WDT BORV20 NOPUT WDT1024 VREGEN
   Word  3: 0100   NOPBADEN CCP2C1 NOMCLR NOLPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
