CCS PCH C Compiler, Version 4.104, 5967               12-jul.-21 08:26

               Filename: D:\Laboratorio\Cabina Extractora de Gases y  Humos\2021\Cabina Extractora con Filtros HMI 120PP Avantika #0045886XX-XX OP2021140-141\Firmware\GLCD_Controller.lst

               ROM used: 46086 bytes (47%)
                         Largest free fragment is 32768
               RAM used: 2820 (85%) at main() level
                         2873 (86%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
00000:  GOTO   5EAC
*
00008:  GOTO   00AE
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FFB,15
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.5
0005E:  GOTO   0068
00062:  BTFSC  F9E.5
00064:  GOTO   051A
00068:  MOVFF  0E,00
0006C:  MOVFF  0F,01
00070:  MOVFF  10,02
00074:  MOVFF  11,03
00078:  MOVFF  0C,FE9
0007C:  MOVFF  07,FEA
00080:  BSF    07.7
00082:  MOVFF  08,FE1
00086:  MOVFF  09,FE2
0008A:  MOVFF  0A,FD9
0008E:  MOVFF  0B,FDA
00092:  MOVFF  12,FF3
00096:  MOVFF  13,FF4
0009A:  MOVFF  14,FFA
0009E:  MOVFF  15,FFB
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
000AE:  MOVWF  17
000B0:  MOVFF  FD8,18
000B4:  MOVFF  FE0,19
000B8:  MOVLB  0
000BA:  MOVFF  FE9,1F
000BE:  MOVFF  FEA,1A
000C2:  MOVFF  FE1,1B
000C6:  MOVFF  FE2,1C
000CA:  MOVFF  FD9,1D
000CE:  MOVFF  FDA,1E
000D2:  MOVFF  FF3,25
000D6:  MOVFF  FF4,26
000DA:  MOVFF  FFA,27
000DE:  MOVFF  FFB,28
000E2:  MOVFF  00,21
000E6:  MOVFF  01,22
000EA:  MOVFF  02,23
000EE:  MOVFF  03,24
000F2:  BTFSS  FF2.5
000F4:  GOTO   00FE
000F8:  BTFSC  FF2.2
000FA:  GOTO   04C8
000FE:  BTFSS  FF2.4
00100:  GOTO   010A
00104:  BTFSC  FF2.1
00106:  GOTO   044A
0010A:  BTFSS  FF0.3
0010C:  GOTO   0116
00110:  BTFSC  FF0.0
00112:  GOTO   0372
00116:  MOVFF  21,00
0011A:  MOVFF  22,01
0011E:  MOVFF  23,02
00122:  MOVFF  24,03
00126:  MOVFF  1F,FE9
0012A:  MOVFF  1A,FEA
0012E:  BSF    1A.7
00130:  MOVFF  1B,FE1
00134:  MOVFF  1C,FE2
00138:  MOVFF  1D,FD9
0013C:  MOVFF  1E,FDA
00140:  MOVFF  25,FF3
00144:  MOVFF  26,FF4
00148:  MOVFF  27,FFA
0014C:  MOVFF  28,FFB
00150:  MOVF   17,W
00152:  MOVFF  19,FE0
00156:  MOVFF  18,FD8
0015A:  RETFIE 0
.................... //Programa para Cabina de Bioseguridad 
....................  
.................... #include <18F4685.h> 
.................... //////// Standard Header file for the PIC18F4685 device //////////////// 
.................... #device PIC18F4685 
.................... #list 
....................  
.................... #device adc=10 
.................... #device HIGH_INTS=TRUE //Activamos niveles de prioridad 
.................... #fuses HS,WDT8192,NOPROTECT,NOLVP,NODEBUG,NOSTVREN,NOPUT,NOCPD,NOWRT,NOIESO,NOFCMEN,NOPBADEN,NOWRTC,NOWRTB,NOEBTR,NOEBTRB,NOCPB,NOXINST,NOLPT1OSC,NOMCLR 
.................... #use delay(clock=20000000) 
*
011F6:  MOVLW  0B
011F8:  MOVWF  FEA
011FA:  MOVLW  22
011FC:  MOVWF  FE9
011FE:  MOVF   FEF,W
01200:  BZ    121C
01202:  MOVLW  06
01204:  MOVWF  01
01206:  CLRF   00
01208:  DECFSZ 00,F
0120A:  BRA    1208
0120C:  DECFSZ 01,F
0120E:  BRA    1206
01210:  MOVLW  7B
01212:  MOVWF  00
01214:  DECFSZ 00,F
01216:  BRA    1214
01218:  DECFSZ FEF,F
0121A:  BRA    1202
0121C:  RETLW  00
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits=8, parity=N,errors) 
*
00502:  BTFSS  F9E.5
00504:  BRA    0502
00506:  MOVFF  FAB,2A
0050A:  MOVFF  FAE,01
0050E:  BTFSS  2A.1
00510:  BRA    0516
00512:  BCF    FAB.4
00514:  BSF    FAB.4
00516:  GOTO   051C (RETURN)
*
0132E:  BTFSS  F9E.4
01330:  BRA    132E
01332:  MOVWF  FAD
01334:  RETLW  00
.................... #priority rda 
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <DS1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_C5 
.................... #define RTC_IO   PIN_C4 
.................... #define RTC_RST  PIN_D3 
....................  
.................... //#endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
0121E:  MOVLB  B
01220:  CLRF   x0A
01222:  MOVF   x0A,W
01224:  SUBLW  07
01226:  BNC   1242
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
01228:  BCF    FD8.0
0122A:  RRCF   x09,F
0122C:  BC    1232
0122E:  BCF    F8B.4
01230:  BRA    1234
01232:  BSF    F8B.4
01234:  BCF    F94.4
....................       output_high(RTC_SCLK); 
01236:  BCF    F94.5
01238:  BSF    F8B.5
....................       output_low(RTC_SCLK); 
0123A:  BCF    F94.5
0123C:  BCF    F8B.5
....................    } 
0123E:  INCF   x0A,F
01240:  BRA    1222
.................... } 
01242:  MOVLB  0
01244:  RETLW  00
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
01246:  BCF    F95.3
01248:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
0124A:  MOVFF  B07,B09
0124E:  RCALL  121E
....................    write_ds1302_byte(data); 
01250:  MOVFF  B08,B09
01254:  RCALL  121E
....................    output_low(RTC_RST); 
01256:  BCF    F95.3
01258:  BCF    F8C.3
.................... } 
0125A:  RETLW  00
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
0125C:  BCF    F95.3
0125E:  BSF    F8C.3
....................    write_ds1302_byte(cmd); 
01260:  MOVFF  B04,B09
01264:  RCALL  121E
....................     
....................    input(RTC_IO); 
01266:  BSF    F94.4
....................    delay_us(10); 
01268:  MOVLW  10
0126A:  MOVWF  00
0126C:  DECFSZ 00,F
0126E:  BRA    126C
01270:  NOP   
....................           
....................    for(i=0;i<=7;++i) { 
01272:  MOVLB  B
01274:  CLRF   x05
01276:  MOVF   x05,W
01278:  SUBLW  07
0127A:  BNC   12A6
....................       shift_right(&data,1,input(RTC_IO)); 
0127C:  BSF    F94.4
0127E:  BTFSC  F82.4
01280:  BRA    1286
01282:  BCF    FD8.0
01284:  BRA    1288
01286:  BSF    FD8.0
01288:  RRCF   x06,F
....................       output_high(RTC_SCLK); 
0128A:  BCF    F94.5
0128C:  BSF    F8B.5
....................       delay_us(20); 
0128E:  MOVLW  21
01290:  MOVWF  00
01292:  DECFSZ 00,F
01294:  BRA    1292
....................       output_low(RTC_SCLK); 
01296:  BCF    F94.5
01298:  BCF    F8B.5
....................       delay_us(20); 
0129A:  MOVLW  21
0129C:  MOVWF  00
0129E:  DECFSZ 00,F
012A0:  BRA    129E
....................    } 
012A2:  INCF   x05,F
012A4:  BRA    1276
....................    output_low(RTC_RST); 
012A6:  BCF    F95.3
012A8:  BCF    F8C.3
....................  
....................    return(data); 
012AA:  MOVFF  B06,01
.................... } 
012AE:  MOVLB  0
012B0:  RETLW  00
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
012B2:  BCF    F95.3
012B4:  BCF    F8C.3
....................    delay_us(20); 
012B6:  MOVLW  21
012B8:  MOVWF  00
012BA:  DECFSZ 00,F
012BC:  BRA    12BA
....................    output_low(RTC_SCLK); 
012BE:  BCF    F94.5
012C0:  BCF    F8B.5
....................    write_ds1302(0x8e,0); 
012C2:  MOVLW  8E
012C4:  MOVLB  B
012C6:  MOVWF  x07
012C8:  CLRF   x08
012CA:  MOVLB  0
012CC:  RCALL  1246
....................    write_ds1302(0x90,0xa4); 
012CE:  MOVLW  90
012D0:  MOVLB  B
012D2:  MOVWF  x07
012D4:  MOVLW  A4
012D6:  MOVWF  x08
012D8:  MOVLB  0
012DA:  RCALL  1246
....................    x=read_ds1302(0x81); 
012DC:  MOVLW  81
012DE:  MOVLB  B
012E0:  MOVWF  x04
012E2:  MOVLB  0
012E4:  RCALL  125C
012E6:  MOVFF  01,B00
....................    if((x & 0x80)!=0) 
012EA:  MOVLB  B
012EC:  MOVF   x00,W
012EE:  ANDLW  80
012F0:  BZ    12FE
....................      write_ds1302(0x80,0); 
012F2:  MOVLW  80
012F4:  MOVWF  x07
012F6:  CLRF   x08
012F8:  MOVLB  0
012FA:  RCALL  1246
012FC:  MOVLB  B
.................... } 
012FE:  MOVLB  0
01300:  GOTO   64AA (RETURN)
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
*
05C46:  MOVFF  B06,B09
05C4A:  MOVLW  0A
05C4C:  MOVLB  B
05C4E:  MOVWF  x0A
05C50:  MOVLB  0
05C52:  CALL   51CA
05C56:  MOVFF  01,B07
....................    nibl=data-(nibh*10); 
05C5A:  MOVLB  B
05C5C:  MOVF   x07,W
05C5E:  MULLW  0A
05C60:  MOVF   FF3,W
05C62:  SUBWF  x06,W
05C64:  MOVWF  x08
....................  
....................    return((nibh<<4)|nibl); 
05C66:  SWAPF  x07,W
05C68:  MOVWF  00
05C6A:  MOVLW  F0
05C6C:  ANDWF  00,F
05C6E:  MOVF   00,W
05C70:  IORWF  x08,W
05C72:  MOVWF  01
.................... } 
05C74:  MOVLB  0
05C76:  RETLW  00
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
*
03876:  MOVFF  B05,B06
....................    data=(i>>4)*10; 
0387A:  MOVLB  B
0387C:  SWAPF  x06,W
0387E:  MOVWF  00
03880:  MOVLW  0F
03882:  ANDWF  00,F
03884:  MOVF   00,W
03886:  MULLW  0A
03888:  MOVFF  FF3,B05
....................    data=data+(i<<4>>4); 
0388C:  SWAPF  x06,W
0388E:  MOVWF  00
03890:  MOVLW  F0
03892:  ANDWF  00,F
03894:  MOVF   00,W
03896:  SWAPF  00,F
03898:  MOVLW  0F
0389A:  ANDWF  00,F
0389C:  MOVF   00,W
0389E:  ADDWF  x05,F
....................  
....................    return data; 
038A0:  MOVFF  B05,01
.................... } 
038A4:  MOVLB  0
038A6:  RETLW  00
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
05C78:  MOVFF  B00,B06
05C7C:  RCALL  5C46
05C7E:  MOVFF  01,B06
05C82:  MOVLW  86
05C84:  MOVLB  B
05C86:  MOVWF  x07
05C88:  MOVFF  01,B08
05C8C:  MOVLB  0
05C8E:  CALL   1246
....................    write_ds1302(0x88,get_bcd(mth)); 
05C92:  MOVFF  B01,B06
05C96:  RCALL  5C46
05C98:  MOVFF  01,B06
05C9C:  MOVLW  88
05C9E:  MOVLB  B
05CA0:  MOVWF  x07
05CA2:  MOVFF  01,B08
05CA6:  MOVLB  0
05CA8:  CALL   1246
....................    write_ds1302(0x8c,get_bcd(year)); 
05CAC:  MOVFF  B02,B06
05CB0:  RCALL  5C46
05CB2:  MOVFF  01,B06
05CB6:  MOVLW  8C
05CB8:  MOVLB  B
05CBA:  MOVWF  x07
05CBC:  MOVFF  01,B08
05CC0:  MOVLB  0
05CC2:  CALL   1246
....................    write_ds1302(0x8a,get_bcd(dow)); 
05CC6:  MOVFF  B03,B06
05CCA:  RCALL  5C46
05CCC:  MOVFF  01,B06
05CD0:  MOVLW  8A
05CD2:  MOVLB  B
05CD4:  MOVWF  x07
05CD6:  MOVFF  01,B08
05CDA:  MOVLB  0
05CDC:  CALL   1246
....................    write_ds1302(0x84,get_bcd(hr)); 
05CE0:  MOVFF  B04,B06
05CE4:  RCALL  5C46
05CE6:  MOVFF  01,B06
05CEA:  MOVLW  84
05CEC:  MOVLB  B
05CEE:  MOVWF  x07
05CF0:  MOVFF  01,B08
05CF4:  MOVLB  0
05CF6:  CALL   1246
....................    write_ds1302(0x82,get_bcd(min)); 
05CFA:  MOVFF  B05,B06
05CFE:  RCALL  5C46
05D00:  MOVFF  01,B06
05D04:  MOVLW  82
05D06:  MOVLB  B
05D08:  MOVWF  x07
05D0A:  MOVFF  01,B08
05D0E:  MOVLB  0
05D10:  CALL   1246
....................    write_ds1302(0x80,get_bcd(0)); 
05D14:  MOVLB  B
05D16:  CLRF   x06
05D18:  MOVLB  0
05D1A:  RCALL  5C46
05D1C:  MOVFF  01,B06
05D20:  MOVLW  80
05D22:  MOVLB  B
05D24:  MOVWF  x07
05D26:  MOVFF  01,B08
05D2A:  MOVLB  0
05D2C:  CALL   1246
.................... } 
05D30:  GOTO   8D44 (RETURN)
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
065A8:  MOVLW  87
065AA:  MOVLB  B
065AC:  MOVWF  x04
065AE:  MOVLB  0
065B0:  CALL   125C
065B4:  MOVFF  01,B00
065B8:  MOVFF  01,B05
065BC:  CALL   3876
065C0:  MOVFF  01,98
....................    mth = rm_bcd(read_ds1302(0x89)); 
065C4:  MOVLW  89
065C6:  MOVLB  B
065C8:  MOVWF  x04
065CA:  MOVLB  0
065CC:  CALL   125C
065D0:  MOVFF  01,B00
065D4:  MOVFF  01,B05
065D8:  CALL   3876
065DC:  MOVFF  01,97
....................    year = rm_bcd(read_ds1302(0x8d)); 
065E0:  MOVLW  8D
065E2:  MOVLB  B
065E4:  MOVWF  x04
065E6:  MOVLB  0
065E8:  CALL   125C
065EC:  MOVFF  01,B00
065F0:  MOVFF  01,B05
065F4:  CALL   3876
065F8:  MOVFF  01,96
....................    dow = rm_bcd(read_ds1302(0x8b)); 
065FC:  MOVLW  8B
065FE:  MOVLB  B
06600:  MOVWF  x04
06602:  MOVLB  0
06604:  CALL   125C
06608:  MOVFF  01,B00
0660C:  MOVFF  01,B05
06610:  CALL   3876
06614:  MOVFF  01,9C
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
06618:  MOVLW  85
0661A:  MOVLB  B
0661C:  MOVWF  x04
0661E:  MOVLB  0
06620:  CALL   125C
06624:  MOVFF  01,B00
06628:  MOVFF  01,B05
0662C:  CALL   3876
06630:  MOVFF  01,99
....................    min = rm_bcd(read_ds1302(0x83)); 
06634:  MOVLW  83
06636:  MOVLB  B
06638:  MOVWF  x04
0663A:  MOVLB  0
0663C:  CALL   125C
06640:  MOVFF  01,B00
06644:  MOVFF  01,B05
06648:  CALL   3876
0664C:  MOVFF  01,9A
....................    sec = rm_bcd(read_ds1302(0x81)); 
06650:  MOVLW  81
06652:  MOVLB  B
06654:  MOVWF  x04
06656:  MOVLB  0
06658:  CALL   125C
0665C:  MOVFF  01,B00
06660:  MOVFF  01,B05
06664:  CALL   3876
06668:  MOVFF  01,9B
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "FuncionesDisplay.h" 
....................  
.................... // Funcion para conversor analogo-digital 
.................... unsigned int16 sensores(int x){ 
.................... unsigned int16 y;set_adc_channel(x);delay_ms(1);y=read_adc();return (y); 
*
038CA:  MOVLB  B
038CC:  RLCF   x1F,W
038CE:  MOVWF  00
038D0:  RLCF   00,F
038D2:  MOVLW  FC
038D4:  ANDWF  00,F
038D6:  MOVFF  00,01
038DA:  MOVF   FC2,W
038DC:  ANDLW  C3
038DE:  IORWF  00,W
038E0:  MOVWF  FC2
038E2:  MOVLW  01
038E4:  MOVWF  x22
038E6:  MOVLB  0
038E8:  CALL   11F6
038EC:  BSF    FC2.1
038EE:  BTFSC  FC2.1
038F0:  BRA    38EE
038F2:  MOVFF  FC4,B21
038F6:  MOVLB  B
038F8:  MOVFF  FC3,B20
038FC:  MOVFF  B20,01
03900:  MOVFF  B21,02
.................... } 
03904:  MOVLB  0
03906:  RETLW  00
....................  
....................  
.................... #define   UP               !input(PIN_B4) 
.................... #define   DOWN             !input(PIN_B5) 
.................... #define   RIGHT            !input(PIN_B6) 
.................... #define   LEFT             !input(PIN_B7) 
.................... #define   VIDRIOUUP        !input(PIN_E2) 
.................... #define   VIDRIOUP         !input(PIN_E1) 
.................... #define   VIDRIODN         !input(PIN_E0) 
....................  
.................... #define   Alarma_on           output_bit(PIN_C0,1) 
.................... #define   Alarma_off          output_bit(PIN_C0,0) 
.................... #define   LuzBlanca_on        output_bit(PIN_D0,0) 
.................... #define   LuzBlanca_off       output_bit(PIN_D0,1) 
.................... #define   LuzUV_on            output_bit(PIN_D1,0) 
.................... #define   LuzUV_off           output_bit(PIN_D1,1) 
.................... #define   Aux_on              output_bit(PIN_D2,0) 
.................... #define   Aux_off             output_bit(PIN_D2,1) 
.................... #define   Motor_on            output_bit(PIN_C3,1) 
.................... #define   Motor_off           output_bit(PIN_C3,0) 
.................... #define   Motor2_on           output_bit(PIN_C2,1) 
.................... #define   Motor2_off          output_bit(PIN_C2,0) 
.................... #define   Toma_on             output_bit(PIN_C1,1) 
.................... #define   Toma_off            output_bit(PIN_C1,0) 
.................... #define   Display_on          output_bit(PIN_D5,1) 
.................... #define   Display_off         output_bit(PIN_D5,0) 
.................... #define   O2_on               output_bit(PIN_D6,1) 
.................... #define   O2_off              output_bit(PIN_D6,0) 
.................... #define   O1_on               output_bit(PIN_D7,1) 
.................... #define   O1_off              output_bit(PIN_D7,0) 
....................  
.................... #define OFF 0 
.................... #define ON  1 
.................... #define RX_BUFFER_SIZE  10 
.................... char Rx_Buffer[RX_BUFFER_SIZE+1]; 
.................... char Rx_Buffer2[RX_BUFFER_SIZE+1]; 
.................... char RX_Wr_Index=0; 
.................... char RX_Rd_Index=0; 
.................... char RX_Counter=0; 
....................  
.................... #define TX_BUFFER_SIZE  24 
.................... char Tx_Buffer[TX_BUFFER_SIZE+1]; 
.................... char TX_Wr_Index=0; 
.................... char TX_Counter=0; 
....................  
....................  
.................... /* Tabla de Modulos, Primera Fila Ao Regular y el siguiente ao Bisiesto 
.................... E   F   M   A   M   J   J   A   S   O   N   D 
.................... 0   3   3   6   1   4   6   2   5   0   3   5 
.................... 0   3   4   0   2   5   0   3   6   1   4   6 
.................... */ 
.................... int8 Regular[12]={0,3,3,6,1,4,6,2,5,0,3,5}; 
.................... int8 Bisiesto[12]={0,3,4,0,2,5,0,3,6,1,4,6}; 
....................  
.................... short imprimir=0,flag_blower=0,flag_toma=0,flag_luz=0,w=0,flag_uv=0,flag_alarma2=0,pulsoSubir=OFF,pulsoBajar=OFF,flag_arriba=OFF; 
.................... short tiempo_purga=0,tiempo_trabajo=0,flag_latencia=0,entro=0,GuardaEEPROM=0,Minutos=OFF,Segundos=OFF,Latencia=0,tiempo_uv=0,guardauv=0; 
.................... short Cruce2=OFF,flagClave=OFF,Encendio=OFF; 
.................... short guardatrabajo=0,Lectura=0,tiempo_postpurga=0,ECO=0; 
.................... int8 Menu=240,Opcion=1,negativo=10,G_l=0,G_h=0,tiemporeset=0,codigoSubir=0,codigoBajar=0,codigoDetener=0; 
.................... int8 q=0,r=0,l=0,h=0,Entero=0,Decimal1=0,Alarma=10,Alarma2=10,LuzUV=0,Vel1=0,Vel2=0,mediaMovil=0; 
.................... int8 Year=18,Mes=9,Dia=13,Hora=0,Minuto=0,Segundo=0,dow=0,Dato_Exitoso=0,MenuAntt=8; 
.................... int8 YearTx=0,MesTx=0,DiaTx=0,HoraTx=0,MinutoTx=0,dowTx=0,z=0,Dato2=0,Inicio=0,TipoClave=0,PantallaPrincipal=0,Digito=0,n=0; 
.................... int8 sPurga=0,sPurgap=0,mPurga=0,mPurgap=0,sPPurga=0,sPPurgap=0,mPPurga=0,mPPurgap=0,sUV=0,mUV=0,sUVp=0,mUVp=0,UV2=10,Modulo=0,Opcion2=0; 
....................  
.................... unsigned int16 Temporal1=0,segundos_uv=0; 
....................  
.................... int16 t_latencia=0,minutos_uv=0,minutos_trabajo=0,G16=0,tClave=0; 
.................... signed int  Tuv[4]={0,0,0,0};          // Tiempo de UV transcurrido(en Horas) 
.................... signed int  Ttrabajo[4]={0,0,0,0};        // Tiempo de trabajo transcurrido (en Horas) 
.................... signed int  Password[4]={0,0,0,0};        // Contrasena Almacenada de 4 digitos 
.................... signed int  Contrasena[4]={0,0,0,0};      // Contrasena de 4 digitos 
.................... float Inflow=0.0,Downflow=0.0,Filtro_Downflow=0.0,Filtro_Inflow=0.0,Diferencia=0.0; 
.................... float Velocidad=0.0,x_uno=0.0,x_cuadrado=0.0,x_cubo=0.0; 
.................... float Temporal=0.0,Temporal2=0.0,UVTime=0.0,TrabajoTime=0.0,barra=0.0,Gdn=0.0,Ajustedn=0.0; 
.................... float a=0.0000001418633343546420,b=-0.00009476749001431169,c= 0.040182822903506,d= -5.354852229527197;//Sensor 2 Posible bueno 
.................... //float t=378.463968402560,f=-18275.0402762787;//Sensor 2 Posible bueno 
....................  
.................... float promedio[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float promedio2[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float PromPresion[30]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float prom[10]; 
.................... float zero_fabrica=203.0,zero_actual=0.0,Relacion=0.57; 
.................... float V1=0.0,G=2.0; 
....................  
.................... int16 pulsos=0; 
.................... int8 i=0,l2=0,h2=0,Temperatura=0; 
.................... short Cruce=OFF,Purga=OFF; 
.................... int8 VelMotor=0,VelMotor2=0; 
....................  
.................... int1 BITS[32]; 
.................... int16 Ta,Tb,TICK=0; 
.................... Int1 BIT_START, NUEVO_DATO; 
.................... int BYTE_IR[4]; 
.................... int8 BIT_BYTE(int1 D7, int1 D6, int1 D5, int1 D4, int1 D3, int1 D2, int1 D1, int1 D0); 
....................  
.................... typedef struct{ 
....................    float zero_actual; 
....................    float Diferencia; 
....................    int16 adc; 
....................    int8 negativo ; 
....................    float Velocidad; 
....................    int8 l; 
....................    int8 h; 
....................    float Flujo;    
....................    float Ajuste; 
....................    float promedio[80]; 
.................... }SensorFlujo; 
....................  
.................... typedef struct{ 
....................    int16 adc; 
....................    float V1; 
....................    float G; 
....................    float Presion; 
....................    float RPT100; 
....................    int8 r; 
....................    int8 h;    
....................    float Ajuste;    
....................    float PromPresion[10]; 
....................    float promediopresion; 
.................... }SensorPresion; 
....................  
.................... SensorFlujo Flujo[5]; 
.................... SensorPresion Presion[5]; 
.................... #include "Funciones.h" 
.................... void BorraBuffer(void){ 
.................... RX_Buffer[0]=0; 
.................... RX_Buffer[1]=0; 
.................... RX_Buffer[2]=0; 
.................... RX_Buffer[3]=0; 
.................... RX_Buffer[4]=0; 
.................... RX_Buffer[5]=0; 
.................... RX_Buffer[6]=0; 
.................... RX_Buffer[7]=0; 
.................... RX_Buffer[8]=0; 
.................... RX_Buffer[9]=0; 
....................  
.................... RX_Buffer2[0]=0; 
.................... RX_Buffer2[1]=0; 
.................... RX_Buffer2[2]=0; 
.................... RX_Buffer2[3]=0; 
.................... RX_Buffer2[4]=0; 
.................... RX_Buffer2[5]=0; 
.................... RX_Buffer2[6]=0; 
.................... RX_Buffer2[7]=0; 
.................... RX_Buffer2[8]=0; 
.................... RX_Buffer2[9]=0; 
....................  
.................... } 
....................  
.................... char bgetc(void){ 
....................    char c; 
....................    while(RX_Counter==0) 
....................       ; 
....................    c=Rx_Buffer2[RX_Rd_Index]; 
....................    if(++RX_Rd_Index>RX_BUFFER_SIZE) 
....................       RX_Rd_Index=0; 
....................    if(RX_Counter) 
....................       RX_Counter--; 
....................    return c; 
.................... } 
....................  
.................... void bputc(char c){ 
....................    char restart=0; 
....................    while(TX_Counter> (TX_BUFFER_SIZE-1)) 
....................       ; 
....................    if(TX_Counter==0) 
....................       restart=1; 
....................    TX_Buffer[TX_Wr_Index++]=c; 
....................    if(TX_Wr_Index>TX_BUFFER_SIZE) 
....................       TX_Wr_Index=0; 
....................     
....................    TX_Counter++; 
....................     
....................    if(restart==1) 
....................       enable_interrupts(int_tbe); 
.................... } 
....................  
.................... void SendDataDisplay(void){ 
.................... delay_us(10); 
*
01336:  MOVLW  10
01338:  MOVWF  00
0133A:  DECFSZ 00,F
0133C:  BRA    133A
0133E:  NOP   
.................... putc(0xFF); 
01340:  MOVLW  FF
01342:  RCALL  132E
.................... delay_us(10); 
01344:  MOVLW  10
01346:  MOVWF  00
01348:  DECFSZ 00,F
0134A:  BRA    1348
0134C:  NOP   
.................... putc(0xFF); 
0134E:  MOVLW  FF
01350:  RCALL  132E
.................... delay_us(10); 
01352:  MOVLW  10
01354:  MOVWF  00
01356:  DECFSZ 00,F
01358:  BRA    1356
0135A:  NOP   
.................... putc(0xFF); 
0135C:  MOVLW  FF
0135E:  RCALL  132E
.................... delay_us(10); 
01360:  MOVLW  10
01362:  MOVWF  00
01364:  DECFSZ 00,F
01366:  BRA    1364
01368:  NOP   
.................... } 
0136A:  RETLW  00
....................  
.................... short esBisiesto(int8 year) { 
....................      return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0); 
*
05BF2:  MOVLB  B
05BF4:  MOVF   x00,W
05BF6:  ANDLW  03
05BF8:  BNZ   5C0E
05BFA:  MOVFF  B00,B09
05BFE:  MOVLW  64
05C00:  MOVWF  x0A
05C02:  MOVLB  0
05C04:  CALL   51CA
05C08:  MOVF   00,F
05C0A:  BNZ   5C3C
05C0C:  MOVLB  B
05C0E:  CLRF   x02
05C10:  MOVFF  B00,B01
05C14:  MOVLW  01
05C16:  MOVWF  x04
05C18:  MOVLW  90
05C1A:  MOVWF  x03
05C1C:  MOVLB  0
05C1E:  BRA    5BAA
05C20:  MOVFF  00,B01
05C24:  MOVLB  B
05C26:  MOVFF  03,B02
05C2A:  MOVF   x01,F
05C2C:  BNZ   5C38
05C2E:  MOVF   x02,F
05C30:  BTFSS  FD8.2
05C32:  BRA    5C38
05C34:  MOVLB  0
05C36:  BRA    5C3C
05C38:  MOVLW  00
05C3A:  BRA    5C40
05C3C:  MOVLW  01
05C3E:  MOVLB  B
05C40:  MOVWF  01
.................... } 
05C42:  MOVLB  0
05C44:  RETLW  00
....................  
.................... void LimitaDia(){ 
....................    if(MesTx>12) 
*
05D34:  MOVF   xA0,W
05D36:  SUBLW  0C
05D38:  BC    5D3E
....................       MesTx=10; 
05D3A:  MOVLW  0A
05D3C:  MOVWF  xA0
....................    if(DiaTx>31) 
05D3E:  MOVF   xA1,W
05D40:  SUBLW  1F
05D42:  BC    5D48
....................       DiaTx=16; 
05D44:  MOVLW  10
05D46:  MOVWF  xA1
....................    if(YearTx>99) 
05D48:  MOVF   x9F,W
05D4A:  SUBLW  63
05D4C:  BC    5D52
....................       YearTx=18;    
05D4E:  MOVLW  12
05D50:  MOVWF  x9F
....................    if(HoraTx>24) 
05D52:  MOVF   xA2,W
05D54:  SUBLW  18
05D56:  BC    5D5C
....................       HoraTx=11;       
05D58:  MOVLW  0B
05D5A:  MOVWF  xA2
....................    if(MinutoTx>59) 
05D5C:  MOVF   xA3,W
05D5E:  SUBLW  3B
05D60:  BC    5D66
....................       MinutoTx=30;       
05D62:  MOVLW  1E
05D64:  MOVWF  xA3
....................     
....................       if(MesTx==2){ 
05D66:  MOVF   xA0,W
05D68:  SUBLW  02
05D6A:  BNZ   5D8E
....................          if(esBisiesto(YearTx)){ 
05D6C:  MOVFF  9F,B00
05D70:  RCALL  5BF2
05D72:  MOVF   01,F
05D74:  BZ    5D82
....................             if(DiaTx>29){ 
05D76:  MOVF   xA1,W
05D78:  SUBLW  1D
05D7A:  BC    5D80
....................                DiaTx=29; 
05D7C:  MOVLW  1D
05D7E:  MOVWF  xA1
....................             } 
....................          }else{ 
05D80:  BRA    5D8C
....................             if(DiaTx>28){ 
05D82:  MOVF   xA1,W
05D84:  SUBLW  1C
05D86:  BC    5D8C
....................                DiaTx=28; 
05D88:  MOVLW  1C
05D8A:  MOVWF  xA1
....................             } 
....................          } 
....................       }else{ 
05D8C:  BRA    5DB8
....................          if(MesTx<=7){ 
05D8E:  MOVF   xA0,W
05D90:  SUBLW  07
05D92:  BNC   5DA6
....................             if(MesTx % 2 ==0){ 
05D94:  MOVF   xA0,W
05D96:  ANDLW  01
05D98:  BNZ   5DA4
....................                if(DiaTx>30){ 
05D9A:  MOVF   xA1,W
05D9C:  SUBLW  1E
05D9E:  BC    5DA4
....................                   DiaTx=30;                    
05DA0:  MOVLW  1E
05DA2:  MOVWF  xA1
....................                } 
....................             } 
....................          }else{ 
05DA4:  BRA    5DB8
....................             if(MesTx % 2 ==1){ 
05DA6:  MOVF   xA0,W
05DA8:  ANDLW  01
05DAA:  SUBLW  01
05DAC:  BNZ   5DB8
....................                if(DiaTx>30){ 
05DAE:  MOVF   xA1,W
05DB0:  SUBLW  1E
05DB2:  BC    5DB8
....................                   DiaTx=30;  
05DB4:  MOVLW  1E
05DB6:  MOVWF  xA1
....................                } 
....................             } 
....................          } 
....................       } 
.................... } 
05DB8:  GOTO   8FD0 (RETURN)
....................  
.................... void LeeDisplay(void){ 
....................    if(Dato_Exitoso==5){ 
*
036E8:  MOVF   x9D,W
036EA:  SUBLW  05
036EC:  BTFSS  FD8.2
036EE:  BRA    3866
....................          RX_Buffer[0]=RX_Buffer2[0]; 
036F0:  MOVFF  3C,31
....................          RX_Buffer[1]=RX_Buffer2[1]; 
036F4:  MOVFF  3D,32
....................          RX_Buffer[2]=RX_Buffer2[2]; 
036F8:  MOVFF  3E,33
....................          RX_Buffer[3]=RX_Buffer2[3]; 
036FC:  MOVFF  3F,34
....................          RX_Buffer[4]=RX_Buffer2[4]; 
03700:  MOVFF  40,35
....................          RX_Buffer[5]=RX_Buffer2[5]; 
03704:  MOVFF  41,36
....................          RX_Buffer[6]=RX_Buffer2[6]; 
03708:  MOVFF  42,37
....................          RX_Buffer[7]=RX_Buffer2[7]; 
0370C:  MOVFF  43,38
....................          RX_Buffer[8]=RX_Buffer2[8]; 
03710:  MOVFF  44,39
....................          RX_Buffer[9]=RX_Buffer2[9]; 
03714:  MOVFF  45,3A
....................           
....................       if(RX_Buffer[3]==0x01){// Pregunta por la pagina en la que esta el display,01 es Contrasea de Acceso 
03718:  DECFSZ 34,W
0371A:  BRA    372A
....................          Menu=0; 
0371C:  CLRF   x81
....................          if(MenuAntt!=Menu) 
0371E:  MOVF   x81,W
03720:  SUBWF  x9E,W
03722:  BZ    3728
....................             MenuAntt=Menu; 
03724:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x02){//02 es Menu Principal  
03728:  BRA    3864
0372A:  MOVF   34,W
0372C:  SUBLW  02
0372E:  BNZ   3740
....................          Menu=1; 
03730:  MOVLW  01
03732:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03734:  MOVF   x81,W
03736:  SUBWF  x9E,W
03738:  BZ    373E
....................             MenuAntt=Menu; 
0373A:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x03){//03 es Tiempo de Purga 
0373E:  BRA    3864
03740:  MOVF   34,W
03742:  SUBLW  03
03744:  BNZ   3756
....................          Menu=2; 
03746:  MOVLW  02
03748:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0374A:  MOVF   x81,W
0374C:  SUBWF  x9E,W
0374E:  BZ    3754
....................             MenuAntt=Menu; 
03750:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x04){//04 es Tiempo de Post-Purga 
03754:  BRA    3864
03756:  MOVF   34,W
03758:  SUBLW  04
0375A:  BNZ   376C
....................          Menu=3; 
0375C:  MOVLW  03
0375E:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03760:  MOVF   x81,W
03762:  SUBWF  x9E,W
03764:  BZ    376A
....................             MenuAntt=Menu; 
03766:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x05){//05 es Tiempo de Purga Corriendo 
0376A:  BRA    3864
0376C:  MOVF   34,W
0376E:  SUBLW  05
03770:  BNZ   3782
....................          Menu=4; 
03772:  MOVLW  04
03774:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03776:  MOVF   x81,W
03778:  SUBWF  x9E,W
0377A:  BZ    3780
....................             MenuAntt=Menu; 
0377C:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x06){//06 es Pantalla Principal 
03780:  BRA    3864
03782:  MOVF   34,W
03784:  SUBLW  06
03786:  BNZ   3798
....................          Menu=5; 
03788:  MOVLW  05
0378A:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0378C:  MOVF   x81,W
0378E:  SUBWF  x9E,W
03790:  BZ    3796
....................             MenuAntt=Menu; 
03792:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x07){//07 es Tiempo de Post-Purga Corriendo 
03796:  BRA    3864
03798:  MOVF   34,W
0379A:  SUBLW  07
0379C:  BNZ   37AE
....................          Menu=6; 
0379E:  MOVLW  06
037A0:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037A2:  MOVF   x81,W
037A4:  SUBWF  x9E,W
037A6:  BZ    37AC
....................             MenuAntt=Menu; 
037A8:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x08){//08 es Fecha y hora 
037AC:  BRA    3864
037AE:  MOVF   34,W
037B0:  SUBLW  08
037B2:  BNZ   37C4
....................          Menu=7; 
037B4:  MOVLW  07
037B6:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037B8:  MOVF   x81,W
037BA:  SUBWF  x9E,W
037BC:  BZ    37C2
....................             MenuAntt=Menu; 
037BE:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x09){//09 es off 
037C2:  BRA    3864
037C4:  MOVF   34,W
037C6:  SUBLW  09
037C8:  BNZ   37DA
....................          Menu=8; 
037CA:  MOVLW  08
037CC:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037CE:  MOVF   x81,W
037D0:  SUBWF  x9E,W
037D2:  BZ    37D8
....................             MenuAntt=Menu; 
037D4:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x0a){//0a es TiempoUV 
037D8:  BRA    3864
037DA:  MOVF   34,W
037DC:  SUBLW  0A
037DE:  BNZ   37F0
....................          Menu=9; 
037E0:  MOVLW  09
037E2:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
037E4:  MOVF   x81,W
037E6:  SUBWF  x9E,W
037E8:  BZ    37EE
....................             MenuAntt=Menu; 
037EA:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x0f){//0f es Recibe caracteres de contrasea desde display 
037EE:  BRA    3864
037F0:  MOVF   34,W
037F2:  SUBLW  0F
037F4:  BNZ   37F8
....................           
....................       }else if(RX_Buffer[3]==0x1a){//1a es Mantenimiento 
037F6:  BRA    3864
037F8:  MOVF   34,W
037FA:  SUBLW  1A
037FC:  BNZ   380E
....................          Menu=10; 
037FE:  MOVLW  0A
03800:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03802:  MOVF   x81,W
03804:  SUBWF  x9E,W
03806:  BZ    380C
....................             MenuAntt=Menu; 
03808:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x1b){//1b es Menu de clave correcta 
0380C:  BRA    3864
0380E:  MOVF   34,W
03810:  SUBLW  1B
03812:  BNZ   3824
....................          Menu=15; 
03814:  MOVLW  0F
03816:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03818:  MOVF   x81,W
0381A:  SUBWF  x9E,W
0381C:  BZ    3822
....................             MenuAntt=Menu; 
0381E:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x1c){//1c es Menu de clave incorrecta 
03822:  BRA    3864
03824:  MOVF   34,W
03826:  SUBLW  1C
03828:  BNZ   383A
....................          Menu=16; 
0382A:  MOVLW  10
0382C:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
0382E:  MOVF   x81,W
03830:  SUBWF  x9E,W
03832:  BZ    3838
....................             MenuAntt=Menu; 
03834:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0x2c){//2c es Menu de Configuracion de Parametros 
03838:  BRA    3864
0383A:  MOVF   34,W
0383C:  SUBLW  2C
0383E:  BNZ   3850
....................          Menu=100; 
03840:  MOVLW  64
03842:  MOVWF  x81
....................          if(MenuAntt!=Menu) 
03844:  MOVF   x81,W
03846:  SUBWF  x9E,W
03848:  BZ    384E
....................             MenuAntt=Menu; 
0384A:  MOVFF  81,9E
....................       }else if(RX_Buffer[3]==0xcc){//cc es Menu de Bienvenida 
0384E:  BRA    3864
03850:  MOVF   34,W
03852:  SUBLW  CC
03854:  BNZ   3864
....................          Menu=240; 
03856:  MOVLW  F0
03858:  MOVWF  x81
....................          if(MenuAntt!=240) 
0385A:  MOVF   x9E,W
0385C:  SUBLW  F0
0385E:  BZ    3864
....................             MenuAntt=Menu; 
03860:  MOVFF  81,9E
....................             //reset_cpu(); 
....................       } 
....................    }else{ 
03864:  BRA    3872
....................       for(z=0;z<RX_BUFFER_SIZE;z++){ 
03866:  CLRF   xA5
03868:  MOVF   xA5,W
0386A:  SUBLW  09
0386C:  BNC   3872
....................             //Rx_Buffer[z]=0; 
....................             //Rx_Buffer2[z]=0; 
....................          } 
0386E:  INCF   xA5,F
03870:  BRA    3868
....................    } 
.................... } 
03872:  GOTO   65A2 (RETURN)
....................  
.................... Float LeerFlujo(int8 media,int8 canal){ 
....................     Flujo[canal].adc=sensores(canal); 
*
039FE:  MOVLB  B
03A00:  CLRF   x20
03A02:  MOVFF  B01,B1F
03A06:  MOVLW  01
03A08:  MOVWF  x22
03A0A:  MOVLW  59
03A0C:  MOVWF  x21
03A0E:  MOVLB  0
03A10:  RCALL  38A8
03A12:  MOVFF  01,B02
03A16:  MOVLW  08
03A18:  MOVLB  B
03A1A:  ADDWF  01,W
03A1C:  MOVWF  01
03A1E:  MOVLW  00
03A20:  ADDWFC 02,W
03A22:  MOVWF  03
03A24:  MOVF   01,W
03A26:  ADDLW  E3
03A28:  MOVWF  01
03A2A:  MOVLW  02
03A2C:  ADDWFC 03,F
03A2E:  MOVFF  01,B02
03A32:  MOVFF  03,B03
03A36:  MOVFF  B01,B1F
03A3A:  MOVLB  0
03A3C:  RCALL  38CA
03A3E:  MOVFF  B03,FEA
03A42:  MOVFF  B02,FE9
03A46:  MOVFF  02,FEC
03A4A:  MOVF   FED,F
03A4C:  MOVFF  01,FEF
....................        
....................     if(Flujo[canal].negativo==10){ 
03A50:  MOVLB  B
03A52:  CLRF   x20
03A54:  MOVFF  B01,B1F
03A58:  MOVLW  01
03A5A:  MOVWF  x22
03A5C:  MOVLW  59
03A5E:  MOVWF  x21
03A60:  MOVLB  0
03A62:  RCALL  38A8
03A64:  MOVFF  02,B03
03A68:  MOVFF  01,B02
03A6C:  MOVLW  0A
03A6E:  MOVLB  B
03A70:  ADDWF  01,W
03A72:  MOVWF  01
03A74:  MOVLW  00
03A76:  ADDWFC 02,W
03A78:  MOVWF  03
03A7A:  MOVF   01,W
03A7C:  ADDLW  E3
03A7E:  MOVWF  FE9
03A80:  MOVLW  02
03A82:  ADDWFC 03,W
03A84:  MOVWF  FEA
03A86:  MOVF   FEF,W
03A88:  SUBLW  0A
03A8A:  BNZ   3B5C
....................       x_uno=Flujo[canal].adc+Flujo[canal].Diferencia; 
03A8C:  CLRF   x20
03A8E:  MOVFF  B01,B1F
03A92:  MOVLW  01
03A94:  MOVWF  x22
03A96:  MOVLW  59
03A98:  MOVWF  x21
03A9A:  MOVLB  0
03A9C:  RCALL  38A8
03A9E:  MOVFF  01,B02
03AA2:  MOVLW  08
03AA4:  MOVLB  B
03AA6:  ADDWF  01,W
03AA8:  MOVWF  01
03AAA:  MOVLW  00
03AAC:  ADDWFC 02,W
03AAE:  MOVWF  03
03AB0:  MOVF   01,W
03AB2:  ADDLW  E3
03AB4:  MOVWF  FE9
03AB6:  MOVLW  02
03AB8:  ADDWFC 03,W
03ABA:  MOVWF  FEA
03ABC:  MOVFF  FEC,B03
03AC0:  MOVF   FED,F
03AC2:  MOVFF  FEF,B02
03AC6:  CLRF   x20
03AC8:  MOVFF  B01,B1F
03ACC:  MOVLW  01
03ACE:  MOVWF  x22
03AD0:  MOVLW  59
03AD2:  MOVWF  x21
03AD4:  MOVLB  0
03AD6:  RCALL  38A8
03AD8:  MOVFF  01,B04
03ADC:  MOVLW  04
03ADE:  MOVLB  B
03AE0:  ADDWF  01,W
03AE2:  MOVWF  01
03AE4:  MOVLW  00
03AE6:  ADDWFC 02,W
03AE8:  MOVWF  03
03AEA:  MOVF   01,W
03AEC:  ADDLW  E3
03AEE:  MOVWF  FE9
03AF0:  MOVLW  02
03AF2:  ADDWFC 03,W
03AF4:  MOVWF  FEA
03AF6:  MOVFF  FEF,B04
03AFA:  MOVFF  FEC,B05
03AFE:  MOVFF  FEC,B06
03B02:  MOVFF  FEC,B07
03B06:  MOVFF  B03,B20
03B0A:  MOVFF  B02,B1F
03B0E:  MOVLB  0
03B10:  CALL   136C
03B14:  MOVFF  FEA,B09
03B18:  MOVFF  FE9,B08
03B1C:  BCF    FD8.1
03B1E:  MOVFF  03,B26
03B22:  MOVFF  02,B25
03B26:  MOVFF  01,B24
03B2A:  MOVFF  00,B23
03B2E:  MOVFF  B07,B2A
03B32:  MOVFF  B06,B29
03B36:  MOVFF  B05,B28
03B3A:  MOVFF  B04,B27
03B3E:  CALL   1500
03B42:  MOVFF  B09,FEA
03B46:  MOVFF  B08,FE9
03B4A:  MOVFF  03,F4
03B4E:  MOVFF  02,F3
03B52:  MOVFF  01,F2
03B56:  MOVFF  00,F1
03B5A:  MOVLB  B
....................     } 
....................     if(Flujo[canal].negativo==20){ 
03B5C:  CLRF   x20
03B5E:  MOVFF  B01,B1F
03B62:  MOVLW  01
03B64:  MOVWF  x22
03B66:  MOVLW  59
03B68:  MOVWF  x21
03B6A:  MOVLB  0
03B6C:  RCALL  38A8
03B6E:  MOVFF  02,B03
03B72:  MOVFF  01,B02
03B76:  MOVLW  0A
03B78:  MOVLB  B
03B7A:  ADDWF  01,W
03B7C:  MOVWF  01
03B7E:  MOVLW  00
03B80:  ADDWFC 02,W
03B82:  MOVWF  03
03B84:  MOVF   01,W
03B86:  ADDLW  E3
03B88:  MOVWF  FE9
03B8A:  MOVLW  02
03B8C:  ADDWFC 03,W
03B8E:  MOVWF  FEA
03B90:  MOVF   FEF,W
03B92:  SUBLW  14
03B94:  BNZ   3C64
....................       x_uno=Flujo[canal].adc-Flujo[canal].Diferencia; 
03B96:  CLRF   x20
03B98:  MOVFF  B01,B1F
03B9C:  MOVLW  01
03B9E:  MOVWF  x22
03BA0:  MOVLW  59
03BA2:  MOVWF  x21
03BA4:  MOVLB  0
03BA6:  RCALL  38A8
03BA8:  MOVFF  01,B02
03BAC:  MOVLW  08
03BAE:  MOVLB  B
03BB0:  ADDWF  01,W
03BB2:  MOVWF  01
03BB4:  MOVLW  00
03BB6:  ADDWFC 02,W
03BB8:  MOVWF  03
03BBA:  MOVF   01,W
03BBC:  ADDLW  E3
03BBE:  MOVWF  FE9
03BC0:  MOVLW  02
03BC2:  ADDWFC 03,W
03BC4:  MOVWF  FEA
03BC6:  MOVFF  FEC,B03
03BCA:  MOVF   FED,F
03BCC:  MOVFF  FEF,B02
03BD0:  CLRF   x20
03BD2:  MOVFF  B01,B1F
03BD6:  MOVLW  01
03BD8:  MOVWF  x22
03BDA:  MOVLW  59
03BDC:  MOVWF  x21
03BDE:  MOVLB  0
03BE0:  RCALL  38A8
03BE2:  MOVFF  01,B04
03BE6:  MOVLW  04
03BE8:  MOVLB  B
03BEA:  ADDWF  01,W
03BEC:  MOVWF  01
03BEE:  MOVLW  00
03BF0:  ADDWFC 02,W
03BF2:  MOVWF  03
03BF4:  MOVF   01,W
03BF6:  ADDLW  E3
03BF8:  MOVWF  FE9
03BFA:  MOVLW  02
03BFC:  ADDWFC 03,W
03BFE:  MOVWF  FEA
03C00:  MOVFF  FEF,B04
03C04:  MOVFF  FEC,B05
03C08:  MOVFF  FEC,B06
03C0C:  MOVFF  FEC,B07
03C10:  MOVFF  B03,B20
03C14:  MOVFF  B02,B1F
03C18:  MOVLB  0
03C1A:  CALL   136C
03C1E:  MOVFF  FEA,B09
03C22:  MOVFF  FE9,B08
03C26:  BSF    FD8.1
03C28:  MOVFF  03,B26
03C2C:  MOVFF  02,B25
03C30:  MOVFF  01,B24
03C34:  MOVFF  00,B23
03C38:  MOVFF  B07,B2A
03C3C:  MOVFF  B06,B29
03C40:  MOVFF  B05,B28
03C44:  MOVFF  B04,B27
03C48:  CALL   1500
03C4C:  MOVFF  B09,FEA
03C50:  MOVFF  B08,FE9
03C54:  MOVFF  03,F4
03C58:  MOVFF  02,F3
03C5C:  MOVFF  01,F2
03C60:  MOVFF  00,F1
....................     } 
....................     x_cuadrado=x_uno*x_uno; 
03C64:  MOVFF  F4,B26
03C68:  MOVFF  F3,B25
03C6C:  MOVFF  F2,B24
03C70:  MOVFF  F1,B23
03C74:  MOVFF  F4,B2A
03C78:  MOVFF  F3,B29
03C7C:  MOVFF  F2,B28
03C80:  MOVFF  F1,B27
03C84:  MOVLB  0
03C86:  RCALL  3908
03C88:  MOVFF  03,F8
03C8C:  MOVFF  02,F7
03C90:  MOVFF  01,F6
03C94:  MOVFF  00,F5
....................     x_cubo=x_uno*x_cuadrado; 
03C98:  MOVFF  F4,B26
03C9C:  MOVFF  F3,B25
03CA0:  MOVFF  F2,B24
03CA4:  MOVFF  F1,B23
03CA8:  MOVFF  F8,B2A
03CAC:  MOVFF  F7,B29
03CB0:  MOVFF  F6,B28
03CB4:  MOVFF  F5,B27
03CB8:  RCALL  3908
03CBA:  MOVFF  03,FC
03CBE:  MOVFF  02,FB
03CC2:  MOVFF  01,FA
03CC6:  MOVFF  00,F9
....................     Flujo[canal].Velocidad=(x_cubo*a)+(x_cuadrado*b)+(x_uno*c)+d;  
03CCA:  MOVLB  B
03CCC:  CLRF   x20
03CCE:  MOVFF  B01,B1F
03CD2:  MOVLW  01
03CD4:  MOVWF  x22
03CD6:  MOVLW  59
03CD8:  MOVWF  x21
03CDA:  MOVLB  0
03CDC:  RCALL  38A8
03CDE:  MOVFF  02,B03
03CE2:  MOVFF  01,B02
03CE6:  MOVLW  0B
03CE8:  MOVLB  B
03CEA:  ADDWF  01,W
03CEC:  MOVWF  01
03CEE:  MOVLW  00
03CF0:  ADDWFC 02,W
03CF2:  MOVWF  03
03CF4:  MOVF   01,W
03CF6:  ADDLW  E3
03CF8:  MOVWF  FE9
03CFA:  MOVLW  02
03CFC:  ADDWFC 03,W
03CFE:  MOVWF  FEA
03D00:  MOVFF  FC,B26
03D04:  MOVFF  FB,B25
03D08:  MOVFF  FA,B24
03D0C:  MOVFF  F9,B23
03D10:  MOVFF  11C,B2A
03D14:  MOVFF  11B,B29
03D18:  MOVFF  11A,B28
03D1C:  MOVFF  119,B27
03D20:  MOVLB  0
03D22:  RCALL  3908
03D24:  MOVFF  00,B04
03D28:  MOVFF  01,B05
03D2C:  MOVFF  02,B06
03D30:  MOVFF  03,B07
03D34:  MOVFF  F8,B26
03D38:  MOVFF  F7,B25
03D3C:  MOVFF  F6,B24
03D40:  MOVFF  F5,B23
03D44:  MOVFF  120,B2A
03D48:  MOVFF  11F,B29
03D4C:  MOVFF  11E,B28
03D50:  MOVFF  11D,B27
03D54:  RCALL  3908
03D56:  MOVFF  FEA,B09
03D5A:  MOVFF  FE9,B08
03D5E:  BCF    FD8.1
03D60:  MOVFF  B07,B26
03D64:  MOVFF  B06,B25
03D68:  MOVFF  B05,B24
03D6C:  MOVFF  B04,B23
03D70:  MOVFF  03,B2A
03D74:  MOVFF  02,B29
03D78:  MOVFF  01,B28
03D7C:  MOVFF  00,B27
03D80:  CALL   1500
03D84:  MOVFF  B09,FEA
03D88:  MOVFF  B08,FE9
03D8C:  MOVFF  00,B04
03D90:  MOVFF  01,B05
03D94:  MOVFF  02,B06
03D98:  MOVFF  03,B07
03D9C:  MOVFF  F4,B26
03DA0:  MOVFF  F3,B25
03DA4:  MOVFF  F2,B24
03DA8:  MOVFF  F1,B23
03DAC:  MOVFF  124,B2A
03DB0:  MOVFF  123,B29
03DB4:  MOVFF  122,B28
03DB8:  MOVFF  121,B27
03DBC:  RCALL  3908
03DBE:  MOVFF  FEA,B0B
03DC2:  MOVFF  FE9,B0A
03DC6:  BCF    FD8.1
03DC8:  MOVFF  B07,B26
03DCC:  MOVFF  B06,B25
03DD0:  MOVFF  B05,B24
03DD4:  MOVFF  B04,B23
03DD8:  MOVFF  03,B2A
03DDC:  MOVFF  02,B29
03DE0:  MOVFF  01,B28
03DE4:  MOVFF  00,B27
03DE8:  CALL   1500
03DEC:  MOVFF  B0B,FEA
03DF0:  MOVFF  B0A,FE9
03DF4:  MOVFF  00,B04
03DF8:  MOVFF  01,B05
03DFC:  MOVFF  02,B06
03E00:  MOVFF  03,B07
03E04:  MOVFF  FEA,B0D
03E08:  MOVFF  FE9,B0C
03E0C:  BCF    FD8.1
03E0E:  MOVFF  03,B26
03E12:  MOVFF  02,B25
03E16:  MOVFF  01,B24
03E1A:  MOVFF  00,B23
03E1E:  MOVFF  128,B2A
03E22:  MOVFF  127,B29
03E26:  MOVFF  126,B28
03E2A:  MOVFF  125,B27
03E2E:  CALL   1500
03E32:  MOVFF  B0D,FEA
03E36:  MOVFF  B0C,FE9
03E3A:  MOVFF  00,FEF
03E3E:  MOVFF  01,FEC
03E42:  MOVFF  02,FEC
03E46:  MOVFF  03,FEC
....................     //Velocidad=Velocidad*correccion;//Ajuste de Temperatura 
....................     Flujo[canal].Velocidad=Flujo[canal].Velocidad-0.08; 
03E4A:  MOVLB  B
03E4C:  CLRF   x20
03E4E:  MOVFF  B01,B1F
03E52:  MOVLW  01
03E54:  MOVWF  x22
03E56:  MOVLW  59
03E58:  MOVWF  x21
03E5A:  MOVLB  0
03E5C:  RCALL  38A8
03E5E:  MOVFF  01,B02
03E62:  MOVLW  0B
03E64:  MOVLB  B
03E66:  ADDWF  01,W
03E68:  MOVWF  01
03E6A:  MOVLW  00
03E6C:  ADDWFC 02,W
03E6E:  MOVWF  03
03E70:  MOVF   01,W
03E72:  ADDLW  E3
03E74:  MOVWF  01
03E76:  MOVLW  02
03E78:  ADDWFC 03,F
03E7A:  MOVFF  01,B02
03E7E:  MOVFF  03,B03
03E82:  CLRF   x20
03E84:  MOVFF  B01,B1F
03E88:  MOVLW  01
03E8A:  MOVWF  x22
03E8C:  MOVLW  59
03E8E:  MOVWF  x21
03E90:  MOVLB  0
03E92:  RCALL  38A8
03E94:  MOVFF  01,B04
03E98:  MOVLW  0B
03E9A:  MOVLB  B
03E9C:  ADDWF  01,W
03E9E:  MOVWF  01
03EA0:  MOVLW  00
03EA2:  ADDWFC 02,W
03EA4:  MOVWF  03
03EA6:  MOVF   01,W
03EA8:  ADDLW  E3
03EAA:  MOVWF  FE9
03EAC:  MOVLW  02
03EAE:  ADDWFC 03,W
03EB0:  MOVWF  FEA
03EB2:  MOVFF  FEF,B04
03EB6:  MOVFF  FEC,B05
03EBA:  MOVFF  FEC,B06
03EBE:  MOVFF  FEC,B07
03EC2:  MOVFF  FEA,B09
03EC6:  MOVFF  FE9,B08
03ECA:  BSF    FD8.1
03ECC:  MOVFF  B07,B26
03ED0:  MOVFF  B06,B25
03ED4:  MOVFF  B05,B24
03ED8:  MOVFF  B04,B23
03EDC:  MOVLW  0A
03EDE:  MOVWF  x2A
03EE0:  MOVLW  D7
03EE2:  MOVWF  x29
03EE4:  MOVLW  23
03EE6:  MOVWF  x28
03EE8:  MOVLW  7B
03EEA:  MOVWF  x27
03EEC:  MOVLB  0
03EEE:  CALL   1500
03EF2:  MOVFF  B09,FEA
03EF6:  MOVFF  B08,FE9
03EFA:  MOVFF  B03,FEA
03EFE:  MOVFF  B02,FE9
03F02:  MOVFF  00,FEF
03F06:  MOVFF  01,FEC
03F0A:  MOVFF  02,FEC
03F0E:  MOVFF  03,FEC
....................     if(Flujo[canal].Velocidad<0.0) 
03F12:  MOVLB  B
03F14:  CLRF   x20
03F16:  MOVFF  B01,B1F
03F1A:  MOVLW  01
03F1C:  MOVWF  x22
03F1E:  MOVLW  59
03F20:  MOVWF  x21
03F22:  MOVLB  0
03F24:  RCALL  38A8
03F26:  MOVFF  01,B02
03F2A:  MOVLW  0B
03F2C:  MOVLB  B
03F2E:  ADDWF  01,W
03F30:  MOVWF  01
03F32:  MOVLW  00
03F34:  ADDWFC 02,W
03F36:  MOVWF  03
03F38:  MOVF   01,W
03F3A:  ADDLW  E3
03F3C:  MOVWF  FE9
03F3E:  MOVLW  02
03F40:  ADDWFC 03,W
03F42:  MOVWF  FEA
03F44:  MOVFF  FEF,B02
03F48:  MOVFF  FEC,B03
03F4C:  MOVFF  FEC,B04
03F50:  MOVFF  FEC,B05
03F54:  MOVFF  B05,B22
03F58:  MOVFF  B04,B21
03F5C:  MOVFF  B03,B20
03F60:  MOVFF  B02,B1F
03F64:  CLRF   x26
03F66:  CLRF   x25
03F68:  CLRF   x24
03F6A:  CLRF   x23
03F6C:  MOVLB  0
03F6E:  CALL   241C
03F72:  BNC   3FAE
....................       Flujo[canal].Velocidad=0.0; 
03F74:  MOVLB  B
03F76:  CLRF   x20
03F78:  MOVFF  B01,B1F
03F7C:  MOVLW  01
03F7E:  MOVWF  x22
03F80:  MOVLW  59
03F82:  MOVWF  x21
03F84:  MOVLB  0
03F86:  RCALL  38A8
03F88:  MOVFF  01,B02
03F8C:  MOVLW  0B
03F8E:  MOVLB  B
03F90:  ADDWF  01,W
03F92:  MOVWF  01
03F94:  MOVLW  00
03F96:  ADDWFC 02,W
03F98:  MOVWF  03
03F9A:  MOVF   01,W
03F9C:  ADDLW  E3
03F9E:  MOVWF  FE9
03FA0:  MOVLW  02
03FA2:  ADDWFC 03,W
03FA4:  MOVWF  FEA
03FA6:  CLRF   FEF
03FA8:  CLRF   FEC
03FAA:  CLRF   FEC
03FAC:  CLRF   FEC
....................       
....................      if(Flujo[canal].l>media-1) 
03FAE:  MOVLB  B
03FB0:  CLRF   x20
03FB2:  MOVFF  B01,B1F
03FB6:  MOVLW  01
03FB8:  MOVWF  x22
03FBA:  MOVLW  59
03FBC:  MOVWF  x21
03FBE:  MOVLB  0
03FC0:  RCALL  38A8
03FC2:  MOVFF  02,B03
03FC6:  MOVFF  01,B02
03FCA:  MOVLW  0F
03FCC:  MOVLB  B
03FCE:  ADDWF  01,W
03FD0:  MOVWF  01
03FD2:  MOVLW  00
03FD4:  ADDWFC 02,W
03FD6:  MOVWF  03
03FD8:  MOVF   01,W
03FDA:  ADDLW  E3
03FDC:  MOVWF  FE9
03FDE:  MOVLW  02
03FE0:  ADDWFC 03,W
03FE2:  MOVWF  FEA
03FE4:  MOVFF  FEF,B02
03FE8:  MOVLW  01
03FEA:  SUBWF  x00,W
03FEC:  SUBWF  x02,W
03FEE:  BZ    4024
03FF0:  BNC   4024
....................        {Flujo[canal].l=0;} 
03FF2:  CLRF   x20
03FF4:  MOVFF  B01,B1F
03FF8:  MOVLW  01
03FFA:  MOVWF  x22
03FFC:  MOVLW  59
03FFE:  MOVWF  x21
04000:  MOVLB  0
04002:  RCALL  38A8
04004:  MOVFF  01,B02
04008:  MOVLW  0F
0400A:  MOVLB  B
0400C:  ADDWF  01,W
0400E:  MOVWF  01
04010:  MOVLW  00
04012:  ADDWFC 02,W
04014:  MOVWF  03
04016:  MOVF   01,W
04018:  ADDLW  E3
0401A:  MOVWF  FE9
0401C:  MOVLW  02
0401E:  ADDWFC 03,W
04020:  MOVWF  FEA
04022:  CLRF   FEF
....................       
....................      Flujo[canal].promedio[Flujo[canal].l]=Flujo[canal].Velocidad; 
04024:  CLRF   x20
04026:  MOVFF  B01,B1F
0402A:  MOVLW  01
0402C:  MOVWF  x22
0402E:  MOVLW  59
04030:  MOVWF  x21
04032:  MOVLB  0
04034:  RCALL  38A8
04036:  MOVFF  02,B03
0403A:  MOVFF  01,B02
0403E:  MOVLW  19
04040:  MOVLB  B
04042:  ADDWF  x02,F
04044:  MOVLW  00
04046:  ADDWFC x03,F
04048:  CLRF   x20
0404A:  MOVFF  B01,B1F
0404E:  MOVLW  01
04050:  MOVWF  x22
04052:  MOVLW  59
04054:  MOVWF  x21
04056:  MOVLB  0
04058:  RCALL  38A8
0405A:  MOVFF  02,B05
0405E:  MOVFF  01,B04
04062:  MOVLW  0F
04064:  MOVLB  B
04066:  ADDWF  01,W
04068:  MOVWF  01
0406A:  MOVLW  00
0406C:  ADDWFC 02,W
0406E:  MOVWF  03
04070:  MOVF   01,W
04072:  ADDLW  E3
04074:  MOVWF  FE9
04076:  MOVLW  02
04078:  ADDWFC 03,W
0407A:  MOVWF  FEA
0407C:  CLRF   x20
0407E:  MOVFF  FEF,B1F
04082:  CLRF   x22
04084:  MOVLW  04
04086:  MOVWF  x21
04088:  MOVLB  0
0408A:  RCALL  38A8
0408C:  MOVFF  02,03
04090:  MOVF   01,W
04092:  MOVLB  B
04094:  ADDWF  x02,W
04096:  MOVWF  01
04098:  MOVF   x03,W
0409A:  ADDWFC 03,F
0409C:  MOVF   01,W
0409E:  ADDLW  E3
040A0:  MOVWF  01
040A2:  MOVLW  02
040A4:  ADDWFC 03,F
040A6:  MOVFF  01,B02
040AA:  MOVFF  03,B03
040AE:  CLRF   x20
040B0:  MOVFF  B01,B1F
040B4:  MOVLW  01
040B6:  MOVWF  x22
040B8:  MOVLW  59
040BA:  MOVWF  x21
040BC:  MOVLB  0
040BE:  CALL   38A8
040C2:  MOVFF  02,B05
040C6:  MOVFF  01,B04
040CA:  MOVLW  0B
040CC:  MOVLB  B
040CE:  ADDWF  01,W
040D0:  MOVWF  01
040D2:  MOVLW  00
040D4:  ADDWFC 02,W
040D6:  MOVWF  03
040D8:  MOVF   01,W
040DA:  ADDLW  E3
040DC:  MOVWF  FE9
040DE:  MOVLW  02
040E0:  ADDWFC 03,W
040E2:  MOVWF  FEA
040E4:  MOVFF  FEF,00
040E8:  MOVFF  FEC,01
040EC:  MOVFF  FEC,02
040F0:  MOVFF  FEC,03
040F4:  MOVFF  B03,FEA
040F8:  MOVFF  B02,FE9
040FC:  MOVFF  00,FEF
04100:  MOVFF  01,FEC
04104:  MOVFF  02,FEC
04108:  MOVFF  03,FEC
....................      Flujo[canal].l++; 
0410C:  CLRF   x20
0410E:  MOVFF  B01,B1F
04112:  MOVLW  01
04114:  MOVWF  x22
04116:  MOVLW  59
04118:  MOVWF  x21
0411A:  MOVLB  0
0411C:  CALL   38A8
04120:  MOVFF  01,B02
04124:  MOVLW  0F
04126:  MOVLB  B
04128:  ADDWF  01,W
0412A:  MOVWF  01
0412C:  MOVLW  00
0412E:  ADDWFC 02,W
04130:  MOVWF  03
04132:  MOVF   01,W
04134:  ADDLW  E3
04136:  MOVWF  FE9
04138:  MOVLW  02
0413A:  ADDWFC 03,W
0413C:  MOVWF  FEA
0413E:  INCF   FEF,F
....................      Flujo[canal].Flujo=0; 
04140:  CLRF   x20
04142:  MOVFF  B01,B1F
04146:  MOVLW  01
04148:  MOVWF  x22
0414A:  MOVLW  59
0414C:  MOVWF  x21
0414E:  MOVLB  0
04150:  CALL   38A8
04154:  MOVFF  01,B02
04158:  MOVLW  11
0415A:  MOVLB  B
0415C:  ADDWF  01,W
0415E:  MOVWF  01
04160:  MOVLW  00
04162:  ADDWFC 02,W
04164:  MOVWF  03
04166:  MOVF   01,W
04168:  ADDLW  E3
0416A:  MOVWF  FE9
0416C:  MOVLW  02
0416E:  ADDWFC 03,W
04170:  MOVWF  FEA
04172:  CLRF   FEF
04174:  CLRF   FEC
04176:  CLRF   FEC
04178:  CLRF   FEC
....................       
....................      for(q=0;q<=(media-1);q++){ 
0417A:  MOVLB  0
0417C:  CLRF   x8A
0417E:  MOVLW  01
04180:  MOVLB  B
04182:  SUBWF  x00,W
04184:  MOVLB  0
04186:  SUBWF  x8A,W
04188:  BZ    418E
0418A:  BTFSC  FD8.0
0418C:  BRA    4298
....................         Flujo[canal].Flujo+=Flujo[canal].promedio[q]; 
0418E:  MOVLB  B
04190:  CLRF   x20
04192:  MOVFF  B01,B1F
04196:  MOVLW  01
04198:  MOVWF  x22
0419A:  MOVLW  59
0419C:  MOVWF  x21
0419E:  MOVLB  0
041A0:  CALL   38A8
041A4:  MOVFF  01,B02
041A8:  MOVLW  11
041AA:  MOVLB  B
041AC:  ADDWF  01,W
041AE:  MOVWF  01
041B0:  MOVLW  00
041B2:  ADDWFC 02,W
041B4:  MOVWF  03
041B6:  MOVF   01,W
041B8:  ADDLW  E3
041BA:  MOVWF  01
041BC:  MOVLW  02
041BE:  ADDWFC 03,F
041C0:  MOVFF  01,B02
041C4:  MOVFF  03,B03
041C8:  MOVFF  03,FEA
041CC:  MOVFF  01,FE9
041D0:  MOVFF  FEF,B04
041D4:  MOVFF  FEC,B05
041D8:  MOVFF  FEC,B06
041DC:  MOVFF  FEC,B07
041E0:  CLRF   x20
041E2:  MOVFF  B01,B1F
041E6:  MOVLW  01
041E8:  MOVWF  x22
041EA:  MOVLW  59
041EC:  MOVWF  x21
041EE:  MOVLB  0
041F0:  CALL   38A8
041F4:  MOVFF  02,B09
041F8:  MOVFF  01,B08
041FC:  MOVLW  19
041FE:  MOVLB  B
04200:  ADDWF  x08,F
04202:  MOVLW  00
04204:  ADDWFC x09,F
04206:  CLRF   x20
04208:  MOVFF  8A,B1F
0420C:  CLRF   x22
0420E:  MOVLW  04
04210:  MOVWF  x21
04212:  MOVLB  0
04214:  CALL   38A8
04218:  MOVFF  02,03
0421C:  MOVF   01,W
0421E:  MOVLB  B
04220:  ADDWF  x08,W
04222:  MOVWF  01
04224:  MOVF   x09,W
04226:  ADDWFC 03,F
04228:  MOVF   01,W
0422A:  ADDLW  E3
0422C:  MOVWF  FE9
0422E:  MOVLW  02
04230:  ADDWFC 03,W
04232:  MOVWF  FEA
04234:  MOVFF  FEF,00
04238:  MOVFF  FEC,01
0423C:  MOVFF  FEC,02
04240:  MOVFF  FEC,03
04244:  MOVFF  FEA,B09
04248:  MOVFF  FE9,B08
0424C:  BCF    FD8.1
0424E:  MOVFF  B07,B26
04252:  MOVFF  B06,B25
04256:  MOVFF  B05,B24
0425A:  MOVFF  B04,B23
0425E:  MOVFF  03,B2A
04262:  MOVFF  02,B29
04266:  MOVFF  01,B28
0426A:  MOVFF  00,B27
0426E:  MOVLB  0
04270:  CALL   1500
04274:  MOVFF  B09,FEA
04278:  MOVFF  B08,FE9
0427C:  MOVFF  B03,FEA
04280:  MOVFF  B02,FE9
04284:  MOVFF  00,FEF
04288:  MOVFF  01,FEC
0428C:  MOVFF  02,FEC
04290:  MOVFF  03,FEC
....................      }  
04294:  INCF   x8A,F
04296:  BRA    417E
....................      Flujo[canal].Flujo=(Flujo[canal].Flujo/media)*Flujo[canal].Ajuste;  
04298:  MOVLB  B
0429A:  CLRF   x20
0429C:  MOVFF  B01,B1F
042A0:  MOVLW  01
042A2:  MOVWF  x22
042A4:  MOVLW  59
042A6:  MOVWF  x21
042A8:  MOVLB  0
042AA:  CALL   38A8
042AE:  MOVFF  01,B02
042B2:  MOVLW  11
042B4:  MOVLB  B
042B6:  ADDWF  01,W
042B8:  MOVWF  01
042BA:  MOVLW  00
042BC:  ADDWFC 02,W
042BE:  MOVWF  03
042C0:  MOVF   01,W
042C2:  ADDLW  E3
042C4:  MOVWF  01
042C6:  MOVLW  02
042C8:  ADDWFC 03,F
042CA:  MOVFF  01,B02
042CE:  MOVFF  03,B03
042D2:  CLRF   x20
042D4:  MOVFF  B01,B1F
042D8:  MOVLW  01
042DA:  MOVWF  x22
042DC:  MOVLW  59
042DE:  MOVWF  x21
042E0:  MOVLB  0
042E2:  CALL   38A8
042E6:  MOVFF  01,B04
042EA:  MOVLW  11
042EC:  MOVLB  B
042EE:  ADDWF  01,W
042F0:  MOVWF  01
042F2:  MOVLW  00
042F4:  ADDWFC 02,W
042F6:  MOVWF  03
042F8:  MOVF   01,W
042FA:  ADDLW  E3
042FC:  MOVWF  FE9
042FE:  MOVLW  02
04300:  ADDWFC 03,W
04302:  MOVWF  FEA
04304:  MOVFF  FEF,B04
04308:  MOVFF  FEC,B05
0430C:  MOVFF  FEC,B06
04310:  MOVFF  FEC,B07
04314:  CLRF   x20
04316:  MOVFF  B00,B1F
0431A:  MOVLB  0
0431C:  CALL   136C
04320:  MOVFF  B07,B22
04324:  MOVFF  B06,B21
04328:  MOVFF  B05,B20
0432C:  MOVFF  B04,B1F
04330:  MOVFF  03,B26
04334:  MOVFF  02,B25
04338:  MOVFF  01,B24
0433C:  MOVFF  00,B23
04340:  CALL   13A2
04344:  MOVFF  00,B04
04348:  MOVFF  01,B05
0434C:  MOVFF  02,B06
04350:  MOVFF  03,B07
04354:  MOVLB  B
04356:  CLRF   x20
04358:  MOVFF  B01,B1F
0435C:  MOVLW  01
0435E:  MOVWF  x22
04360:  MOVLW  59
04362:  MOVWF  x21
04364:  MOVLB  0
04366:  CALL   38A8
0436A:  MOVFF  02,B09
0436E:  MOVFF  01,B08
04372:  MOVLW  15
04374:  MOVLB  B
04376:  ADDWF  01,W
04378:  MOVWF  01
0437A:  MOVLW  00
0437C:  ADDWFC 02,W
0437E:  MOVWF  03
04380:  MOVF   01,W
04382:  ADDLW  E3
04384:  MOVWF  FE9
04386:  MOVLW  02
04388:  ADDWFC 03,W
0438A:  MOVWF  FEA
0438C:  MOVFF  FEF,00
04390:  MOVFF  FEC,01
04394:  MOVFF  FEC,02
04398:  MOVFF  FEC,03
0439C:  MOVFF  B07,B26
043A0:  MOVFF  B06,B25
043A4:  MOVFF  B05,B24
043A8:  MOVFF  B04,B23
043AC:  MOVFF  03,B2A
043B0:  MOVFF  02,B29
043B4:  MOVFF  01,B28
043B8:  MOVFF  00,B27
043BC:  MOVLB  0
043BE:  CALL   3908
043C2:  MOVFF  B03,FEA
043C6:  MOVFF  B02,FE9
043CA:  MOVFF  00,FEF
043CE:  MOVFF  01,FEC
043D2:  MOVFF  02,FEC
043D6:  MOVFF  03,FEC
....................      return Flujo[canal].Flujo; 
043DA:  MOVLB  B
043DC:  CLRF   x20
043DE:  MOVFF  B01,B1F
043E2:  MOVLW  01
043E4:  MOVWF  x22
043E6:  MOVLW  59
043E8:  MOVWF  x21
043EA:  MOVLB  0
043EC:  CALL   38A8
043F0:  MOVFF  02,B03
043F4:  MOVFF  01,B02
043F8:  MOVLW  11
043FA:  MOVLB  B
043FC:  ADDWF  01,W
043FE:  MOVWF  01
04400:  MOVLW  00
04402:  ADDWFC 02,W
04404:  MOVWF  03
04406:  MOVF   01,W
04408:  ADDLW  E3
0440A:  MOVWF  FE9
0440C:  MOVLW  02
0440E:  ADDWFC 03,W
04410:  MOVWF  FEA
04412:  MOVFF  FEF,00
04416:  MOVFF  FEC,01
0441A:  MOVFF  FEC,02
0441E:  MOVFF  FEC,03
.................... } 
04422:  MOVLB  0
04424:  GOTO   667C (RETURN)
....................  
.................... float D6FW101(int8 media,canal){ 
04428:  MOVLB  B
0442A:  CLRF   x05
0442C:  CLRF   x04
0442E:  CLRF   x03
04430:  CLRF   x02
04432:  CLRF   x09
04434:  CLRF   x08
04436:  CLRF   x07
04438:  CLRF   x06
0443A:  CLRF   x0D
0443C:  CLRF   x0C
0443E:  CLRF   x0B
04440:  CLRF   x0A
04442:  MOVLW  3D
04444:  MOVWF  x11
04446:  MOVLW  9B
04448:  MOVWF  x10
0444A:  MOVLW  75
0444C:  MOVWF  x0F
0444E:  MOVLW  7D
04450:  MOVWF  x0E
04452:  MOVLW  A5
04454:  MOVWF  x15
04456:  MOVLW  BD
04458:  MOVWF  x14
0445A:  MOVLW  21
0445C:  MOVWF  x13
0445E:  MOVLW  7E
04460:  MOVWF  x12
04462:  CLRF   x19
04464:  CLRF   x18
04466:  CLRF   x17
04468:  CLRF   x16
0446A:  CLRF   x1D
0446C:  CLRF   x1C
0446E:  CLRF   x1B
04470:  CLRF   x1A
04472:  CLRF   x1E
....................    static float a=-0.054947,b=0.56321,c=-0.45502; 
....................    float flow=0.0,promedio=0.0,adc=0.0,Adn=0.47970,AdnV=0.63180,Qdn=0,flowV=0.0;//Areas en m2 
....................    int8 pos=0; 
....................     
....................    promedio=0.0; 
04474:  CLRF   x09
04476:  CLRF   x08
04478:  CLRF   x07
0447A:  CLRF   x06
....................    Qdn=0.0; 
0447C:  CLRF   x19
0447E:  CLRF   x18
04480:  CLRF   x17
04482:  CLRF   x16
....................    adc=sensores(canal); 
04484:  MOVFF  B01,B1F
04488:  MOVLB  0
0448A:  CALL   38CA
0448E:  MOVFF  02,B20
04492:  MOVFF  01,B1F
04496:  CALL   136C
0449A:  MOVFF  03,B0D
0449E:  MOVFF  02,B0C
044A2:  MOVFF  01,B0B
044A6:  MOVFF  00,B0A
....................    adc=(adc/1023)*5.0; 
044AA:  MOVFF  B0D,B22
044AE:  MOVFF  B0C,B21
044B2:  MOVFF  B0B,B20
044B6:  MOVFF  B0A,B1F
044BA:  MOVLB  B
044BC:  CLRF   x26
044BE:  MOVLW  C0
044C0:  MOVWF  x25
044C2:  MOVLW  7F
044C4:  MOVWF  x24
044C6:  MOVLW  88
044C8:  MOVWF  x23
044CA:  MOVLB  0
044CC:  CALL   13A2
044D0:  MOVFF  00,B1F
044D4:  MOVFF  01,B20
044D8:  MOVFF  02,B21
044DC:  MOVFF  03,B22
044E0:  MOVFF  03,B26
044E4:  MOVFF  02,B25
044E8:  MOVFF  01,B24
044EC:  MOVFF  00,B23
044F0:  MOVLB  B
044F2:  CLRF   x2A
044F4:  CLRF   x29
044F6:  MOVLW  20
044F8:  MOVWF  x28
044FA:  MOVLW  81
044FC:  MOVWF  x27
044FE:  MOVLB  0
04500:  CALL   3908
04504:  MOVFF  03,B0D
04508:  MOVFF  02,B0C
0450C:  MOVFF  01,B0B
04510:  MOVFF  00,B0A
....................    flow=(adc*adc*a)+(adc*b)+c; 
04514:  MOVFF  B0D,B26
04518:  MOVFF  B0C,B25
0451C:  MOVFF  B0B,B24
04520:  MOVFF  B0A,B23
04524:  MOVFF  B0D,B2A
04528:  MOVFF  B0C,B29
0452C:  MOVFF  B0B,B28
04530:  MOVFF  B0A,B27
04534:  CALL   3908
04538:  MOVFF  00,B1F
0453C:  MOVFF  01,B20
04540:  MOVFF  02,B21
04544:  MOVFF  03,B22
04548:  MOVFF  03,B26
0454C:  MOVFF  02,B25
04550:  MOVFF  01,B24
04554:  MOVFF  00,B23
04558:  MOVFF  AF7,B2A
0455C:  MOVFF  AF6,B29
04560:  MOVFF  AF5,B28
04564:  MOVFF  AF4,B27
04568:  CALL   3908
0456C:  MOVFF  00,B1F
04570:  MOVFF  01,B20
04574:  MOVFF  02,B21
04578:  MOVFF  03,B22
0457C:  MOVFF  B0D,B26
04580:  MOVFF  B0C,B25
04584:  MOVFF  B0B,B24
04588:  MOVFF  B0A,B23
0458C:  MOVFF  AFB,B2A
04590:  MOVFF  AFA,B29
04594:  MOVFF  AF9,B28
04598:  MOVFF  AF8,B27
0459C:  CALL   3908
045A0:  BCF    FD8.1
045A2:  MOVFF  B22,B26
045A6:  MOVFF  B21,B25
045AA:  MOVFF  B20,B24
045AE:  MOVFF  B1F,B23
045B2:  MOVFF  03,B2A
045B6:  MOVFF  02,B29
045BA:  MOVFF  01,B28
045BE:  MOVFF  00,B27
045C2:  CALL   1500
045C6:  MOVFF  00,B1F
045CA:  MOVFF  01,B20
045CE:  MOVFF  02,B21
045D2:  MOVFF  03,B22
045D6:  BCF    FD8.1
045D8:  MOVFF  03,B26
045DC:  MOVFF  02,B25
045E0:  MOVFF  01,B24
045E4:  MOVFF  00,B23
045E8:  MOVFF  AFF,B2A
045EC:  MOVFF  AFE,B29
045F0:  MOVFF  AFD,B28
045F4:  MOVFF  AFC,B27
045F8:  CALL   1500
045FC:  MOVFF  03,B05
04600:  MOVFF  02,B04
04604:  MOVFF  01,B03
04608:  MOVFF  00,B02
....................    flow=flow-0.04; 
0460C:  BSF    FD8.1
0460E:  MOVFF  B05,B26
04612:  MOVFF  B04,B25
04616:  MOVFF  B03,B24
0461A:  MOVFF  B02,B23
0461E:  MOVLW  0A
04620:  MOVLB  B
04622:  MOVWF  x2A
04624:  MOVLW  D7
04626:  MOVWF  x29
04628:  MOVLW  23
0462A:  MOVWF  x28
0462C:  MOVLW  7A
0462E:  MOVWF  x27
04630:  MOVLB  0
04632:  CALL   1500
04636:  MOVFF  03,B05
0463A:  MOVFF  02,B04
0463E:  MOVFF  01,B03
04642:  MOVFF  00,B02
....................    if(flow<0.0) 
04646:  MOVFF  B05,B22
0464A:  MOVFF  B04,B21
0464E:  MOVFF  B03,B20
04652:  MOVFF  B02,B1F
04656:  MOVLB  B
04658:  CLRF   x26
0465A:  CLRF   x25
0465C:  CLRF   x24
0465E:  CLRF   x23
04660:  MOVLB  0
04662:  CALL   241C
04666:  BNC   4674
....................       flow=0.0; 
04668:  MOVLB  B
0466A:  CLRF   x05
0466C:  CLRF   x04
0466E:  CLRF   x03
04670:  CLRF   x02
04672:  MOVLB  0
....................        
....................    Qdn=Adn*flow;    
04674:  MOVFF  B11,B26
04678:  MOVFF  B10,B25
0467C:  MOVFF  B0F,B24
04680:  MOVFF  B0E,B23
04684:  MOVFF  B05,B2A
04688:  MOVFF  B04,B29
0468C:  MOVFF  B03,B28
04690:  MOVFF  B02,B27
04694:  CALL   3908
04698:  MOVFF  03,B19
0469C:  MOVFF  02,B18
046A0:  MOVFF  01,B17
046A4:  MOVFF  00,B16
....................    flowV=Qdn/AdnV; 
046A8:  MOVFF  B19,B22
046AC:  MOVFF  B18,B21
046B0:  MOVFF  B17,B20
046B4:  MOVFF  B16,B1F
046B8:  MOVFF  B15,B26
046BC:  MOVFF  B14,B25
046C0:  MOVFF  B13,B24
046C4:  MOVFF  B12,B23
046C8:  CALL   13A2
046CC:  MOVFF  03,B1D
046D0:  MOVFF  02,B1C
046D4:  MOVFF  01,B1B
046D8:  MOVFF  00,B1A
....................     
....................    if(pos>media) 
046DC:  MOVLB  B
046DE:  MOVF   x1E,W
046E0:  SUBWF  x00,W
046E2:  BC    46E6
....................       pos=0; 
046E4:  CLRF   x1E
....................     
....................    prom[pos]=flowV; 
046E6:  MOVF   x1E,W
046E8:  MULLW  04
046EA:  MOVF   FF3,W
046EC:  CLRF   03
046EE:  ADDLW  91
046F0:  MOVWF  FE9
046F2:  MOVLW  02
046F4:  ADDWFC 03,W
046F6:  MOVWF  FEA
046F8:  MOVFF  B1A,FEF
046FC:  MOVFF  B1B,FEC
04700:  MOVFF  B1C,FEC
04704:  MOVFF  B1D,FEC
....................    pos++; 
04708:  INCF   x1E,F
....................     
....................    for(i=0;i<=(media-1);i++){ 
0470A:  MOVLB  2
0470C:  CLRF   xCF
0470E:  MOVLW  01
04710:  MOVLB  B
04712:  SUBWF  x00,W
04714:  MOVLB  2
04716:  SUBWF  xCF,W
04718:  BZ    471C
0471A:  BC    478C
....................       promedio+=prom[h]; 
0471C:  MOVLB  0
0471E:  MOVF   x8D,W
04720:  MULLW  04
04722:  MOVF   FF3,W
04724:  CLRF   03
04726:  ADDLW  91
04728:  MOVWF  FE9
0472A:  MOVLW  02
0472C:  ADDWFC 03,W
0472E:  MOVWF  FEA
04730:  MOVFF  FEF,00
04734:  MOVFF  FEC,01
04738:  MOVFF  FEC,02
0473C:  MOVFF  FEC,03
04740:  MOVFF  FEA,B20
04744:  MOVFF  FE9,B1F
04748:  BCF    FD8.1
0474A:  MOVFF  B09,B26
0474E:  MOVFF  B08,B25
04752:  MOVFF  B07,B24
04756:  MOVFF  B06,B23
0475A:  MOVFF  03,B2A
0475E:  MOVFF  02,B29
04762:  MOVFF  01,B28
04766:  MOVFF  00,B27
0476A:  CALL   1500
0476E:  MOVFF  B20,FEA
04772:  MOVFF  B1F,FE9
04776:  MOVFF  03,B09
0477A:  MOVFF  02,B08
0477E:  MOVFF  01,B07
04782:  MOVFF  00,B06
....................    }  
04786:  MOVLB  2
04788:  INCF   xCF,F
0478A:  BRA    470E
....................    promedio=promedio/media; 
0478C:  MOVLB  B
0478E:  CLRF   x20
04790:  MOVFF  B00,B1F
04794:  MOVLB  0
04796:  CALL   136C
0479A:  MOVFF  B09,B22
0479E:  MOVFF  B08,B21
047A2:  MOVFF  B07,B20
047A6:  MOVFF  B06,B1F
047AA:  MOVFF  03,B26
047AE:  MOVFF  02,B25
047B2:  MOVFF  01,B24
047B6:  MOVFF  00,B23
047BA:  CALL   13A2
047BE:  MOVFF  03,B09
047C2:  MOVFF  02,B08
047C6:  MOVFF  01,B07
047CA:  MOVFF  00,B06
....................    return promedio*Flujo[canal].Ajuste; 
047CE:  MOVLB  B
047D0:  CLRF   x20
047D2:  MOVFF  B01,B1F
047D6:  MOVLW  01
047D8:  MOVWF  x22
047DA:  MOVLW  59
047DC:  MOVWF  x21
047DE:  MOVLB  0
047E0:  CALL   38A8
047E4:  MOVFF  02,B20
047E8:  MOVFF  01,B1F
047EC:  MOVLW  15
047EE:  MOVLB  B
047F0:  ADDWF  01,W
047F2:  MOVWF  01
047F4:  MOVLW  00
047F6:  ADDWFC 02,W
047F8:  MOVWF  03
047FA:  MOVF   01,W
047FC:  ADDLW  E3
047FE:  MOVWF  FE9
04800:  MOVLW  02
04802:  ADDWFC 03,W
04804:  MOVWF  FEA
04806:  MOVFF  FEF,00
0480A:  MOVFF  FEC,01
0480E:  MOVFF  FEC,02
04812:  MOVFF  FEC,03
04816:  MOVFF  B09,B26
0481A:  MOVFF  B08,B25
0481E:  MOVFF  B07,B24
04822:  MOVFF  B06,B23
04826:  MOVFF  03,B2A
0482A:  MOVFF  02,B29
0482E:  MOVFF  01,B28
04832:  MOVFF  00,B27
04836:  MOVLB  0
04838:  CALL   3908
....................    //return flowV; 
....................  
.................... } 
0483C:  GOTO   669C (RETURN)
....................  
.................... float Leer_Sensor_Presion(int8 media,int8 canal){ 
....................    Presion[canal].promediopresion=0.0; 
04840:  MOVLB  B
04842:  CLRF   x20
04844:  MOVFF  B01,B1F
04848:  CLRF   x22
0484A:  MOVLW  44
0484C:  MOVWF  x21
0484E:  MOVLB  0
04850:  CALL   38A8
04854:  MOVFF  01,B02
04858:  MOVLW  40
0485A:  MOVLB  B
0485C:  ADDWF  01,W
0485E:  MOVWF  01
04860:  MOVLW  00
04862:  ADDWFC 02,W
04864:  MOVWF  03
04866:  MOVF   01,W
04868:  ADDLW  A0
0486A:  MOVWF  FE9
0486C:  MOVLW  09
0486E:  ADDWFC 03,W
04870:  MOVWF  FEA
04872:  CLRF   FEF
04874:  CLRF   FEC
04876:  CLRF   FEC
04878:  CLRF   FEC
....................     
....................    Presion[canal].adc=sensores(canal); 
0487A:  CLRF   x20
0487C:  MOVFF  B01,B1F
04880:  CLRF   x22
04882:  MOVLW  44
04884:  MOVWF  x21
04886:  MOVLB  0
04888:  CALL   38A8
0488C:  MOVFF  01,B02
04890:  MOVLW  A0
04892:  MOVLB  B
04894:  ADDWF  01,W
04896:  MOVWF  01
04898:  MOVLW  09
0489A:  ADDWFC 02,W
0489C:  MOVWF  03
0489E:  MOVFF  01,B02
048A2:  MOVWF  x03
048A4:  MOVFF  B01,B1F
048A8:  MOVLB  0
048AA:  CALL   38CA
048AE:  MOVFF  B03,FEA
048B2:  MOVFF  B02,FE9
048B6:  MOVFF  02,FEC
048BA:  MOVF   FED,F
048BC:  MOVFF  01,FEF
....................    Presion[canal].V1=Presion[canal].adc;  
048C0:  MOVLB  B
048C2:  CLRF   x20
048C4:  MOVFF  B01,B1F
048C8:  CLRF   x22
048CA:  MOVLW  44
048CC:  MOVWF  x21
048CE:  MOVLB  0
048D0:  CALL   38A8
048D4:  MOVFF  01,B02
048D8:  MOVLW  02
048DA:  MOVLB  B
048DC:  ADDWF  01,W
048DE:  MOVWF  01
048E0:  MOVLW  00
048E2:  ADDWFC 02,W
048E4:  MOVWF  03
048E6:  MOVF   01,W
048E8:  ADDLW  A0
048EA:  MOVWF  01
048EC:  MOVLW  09
048EE:  ADDWFC 03,F
048F0:  MOVFF  01,B02
048F4:  MOVFF  03,B03
048F8:  CLRF   x20
048FA:  MOVFF  B01,B1F
048FE:  CLRF   x22
04900:  MOVLW  44
04902:  MOVWF  x21
04904:  MOVLB  0
04906:  CALL   38A8
0490A:  MOVFF  02,B05
0490E:  MOVFF  01,B04
04912:  MOVLW  A0
04914:  MOVLB  B
04916:  ADDWF  01,W
04918:  MOVWF  FE9
0491A:  MOVLW  09
0491C:  ADDWFC 02,W
0491E:  MOVWF  FEA
04920:  MOVFF  FEC,03
04924:  MOVF   FED,F
04926:  MOVFF  FEF,B1F
0492A:  MOVFF  03,B20
0492E:  MOVLB  0
04930:  CALL   136C
04934:  MOVFF  B03,FEA
04938:  MOVFF  B02,FE9
0493C:  MOVFF  00,FEF
04940:  MOVFF  01,FEC
04944:  MOVFF  02,FEC
04948:  MOVFF  03,FEC
....................    Presion[canal].Presion=(Presion[canal].V1/Presion[canal].G)-1.0;// Presion=(Voltaje/Ganancia)-1 
0494C:  MOVLB  B
0494E:  CLRF   x20
04950:  MOVFF  B01,B1F
04954:  CLRF   x22
04956:  MOVLW  44
04958:  MOVWF  x21
0495A:  MOVLB  0
0495C:  CALL   38A8
04960:  MOVFF  01,B02
04964:  MOVLW  0A
04966:  MOVLB  B
04968:  ADDWF  01,W
0496A:  MOVWF  01
0496C:  MOVLW  00
0496E:  ADDWFC 02,W
04970:  MOVWF  03
04972:  MOVF   01,W
04974:  ADDLW  A0
04976:  MOVWF  01
04978:  MOVLW  09
0497A:  ADDWFC 03,F
0497C:  MOVFF  01,B02
04980:  MOVFF  03,B03
04984:  CLRF   x20
04986:  MOVFF  B01,B1F
0498A:  CLRF   x22
0498C:  MOVLW  44
0498E:  MOVWF  x21
04990:  MOVLB  0
04992:  CALL   38A8
04996:  MOVFF  01,B04
0499A:  MOVLW  02
0499C:  MOVLB  B
0499E:  ADDWF  01,W
049A0:  MOVWF  01
049A2:  MOVLW  00
049A4:  ADDWFC 02,W
049A6:  MOVWF  03
049A8:  MOVF   01,W
049AA:  ADDLW  A0
049AC:  MOVWF  FE9
049AE:  MOVLW  09
049B0:  ADDWFC 03,W
049B2:  MOVWF  FEA
049B4:  MOVFF  FEF,B04
049B8:  MOVFF  FEC,B05
049BC:  MOVFF  FEC,B06
049C0:  MOVFF  FEC,B07
049C4:  CLRF   x20
049C6:  MOVFF  B01,B1F
049CA:  CLRF   x22
049CC:  MOVLW  44
049CE:  MOVWF  x21
049D0:  MOVLB  0
049D2:  CALL   38A8
049D6:  MOVFF  02,B09
049DA:  MOVFF  01,B08
049DE:  MOVLW  06
049E0:  MOVLB  B
049E2:  ADDWF  01,W
049E4:  MOVWF  01
049E6:  MOVLW  00
049E8:  ADDWFC 02,W
049EA:  MOVWF  03
049EC:  MOVF   01,W
049EE:  ADDLW  A0
049F0:  MOVWF  FE9
049F2:  MOVLW  09
049F4:  ADDWFC 03,W
049F6:  MOVWF  FEA
049F8:  MOVFF  FEF,00
049FC:  MOVFF  FEC,01
04A00:  MOVFF  FEC,02
04A04:  MOVFF  FEC,03
04A08:  MOVFF  B07,B22
04A0C:  MOVFF  B06,B21
04A10:  MOVFF  B05,B20
04A14:  MOVFF  B04,B1F
04A18:  MOVFF  03,B26
04A1C:  MOVFF  02,B25
04A20:  MOVFF  01,B24
04A24:  MOVFF  00,B23
04A28:  MOVLB  0
04A2A:  CALL   13A2
04A2E:  MOVFF  00,B04
04A32:  MOVFF  01,B05
04A36:  MOVFF  02,B06
04A3A:  MOVFF  03,B07
04A3E:  MOVFF  FEA,B09
04A42:  MOVFF  FE9,B08
04A46:  BSF    FD8.1
04A48:  MOVFF  03,B26
04A4C:  MOVFF  02,B25
04A50:  MOVFF  01,B24
04A54:  MOVFF  00,B23
04A58:  MOVLB  B
04A5A:  CLRF   x2A
04A5C:  CLRF   x29
04A5E:  CLRF   x28
04A60:  MOVLW  7F
04A62:  MOVWF  x27
04A64:  MOVLB  0
04A66:  CALL   1500
04A6A:  MOVFF  B09,FEA
04A6E:  MOVFF  B08,FE9
04A72:  MOVFF  B03,FEA
04A76:  MOVFF  B02,FE9
04A7A:  MOVFF  00,FEF
04A7E:  MOVFF  01,FEC
04A82:  MOVFF  02,FEC
04A86:  MOVFF  03,FEC
....................    //V1 = (x_uno*5.0)/1023.0;   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
....................    //if(canal==4){ 
....................    //   Presion[canal].Presion=(Presion[canal].V1/Gdn)-1.0;// Presion=(Voltaje/Ganancia)-1 
....................    //}else{ 
....................    //} 
....................     
....................    if(Presion[canal].Presion<0.0){ 
04A8A:  MOVLB  B
04A8C:  CLRF   x20
04A8E:  MOVFF  B01,B1F
04A92:  CLRF   x22
04A94:  MOVLW  44
04A96:  MOVWF  x21
04A98:  MOVLB  0
04A9A:  CALL   38A8
04A9E:  MOVFF  01,B02
04AA2:  MOVLW  0A
04AA4:  MOVLB  B
04AA6:  ADDWF  01,W
04AA8:  MOVWF  01
04AAA:  MOVLW  00
04AAC:  ADDWFC 02,W
04AAE:  MOVWF  03
04AB0:  MOVF   01,W
04AB2:  ADDLW  A0
04AB4:  MOVWF  FE9
04AB6:  MOVLW  09
04AB8:  ADDWFC 03,W
04ABA:  MOVWF  FEA
04ABC:  MOVFF  FEF,B02
04AC0:  MOVFF  FEC,B03
04AC4:  MOVFF  FEC,B04
04AC8:  MOVFF  FEC,B05
04ACC:  MOVFF  B05,B22
04AD0:  MOVFF  B04,B21
04AD4:  MOVFF  B03,B20
04AD8:  MOVFF  B02,B1F
04ADC:  CLRF   x26
04ADE:  CLRF   x25
04AE0:  CLRF   x24
04AE2:  CLRF   x23
04AE4:  MOVLB  0
04AE6:  CALL   241C
04AEA:  BNC   4B26
....................       Presion[canal].Presion=0.0; 
04AEC:  MOVLB  B
04AEE:  CLRF   x20
04AF0:  MOVFF  B01,B1F
04AF4:  CLRF   x22
04AF6:  MOVLW  44
04AF8:  MOVWF  x21
04AFA:  MOVLB  0
04AFC:  CALL   38A8
04B00:  MOVFF  01,B02
04B04:  MOVLW  0A
04B06:  MOVLB  B
04B08:  ADDWF  01,W
04B0A:  MOVWF  01
04B0C:  MOVLW  00
04B0E:  ADDWFC 02,W
04B10:  MOVWF  03
04B12:  MOVF   01,W
04B14:  ADDLW  A0
04B16:  MOVWF  FE9
04B18:  MOVLW  09
04B1A:  ADDWFC 03,W
04B1C:  MOVWF  FEA
04B1E:  CLRF   FEF
04B20:  CLRF   FEC
04B22:  CLRF   FEC
04B24:  CLRF   FEC
....................    } 
....................  
....................    if(Presion[canal].r>media-1) 
04B26:  MOVLB  B
04B28:  CLRF   x20
04B2A:  MOVFF  B01,B1F
04B2E:  CLRF   x22
04B30:  MOVLW  44
04B32:  MOVWF  x21
04B34:  MOVLB  0
04B36:  CALL   38A8
04B3A:  MOVFF  02,B03
04B3E:  MOVFF  01,B02
04B42:  MOVLW  12
04B44:  MOVLB  B
04B46:  ADDWF  01,W
04B48:  MOVWF  01
04B4A:  MOVLW  00
04B4C:  ADDWFC 02,W
04B4E:  MOVWF  03
04B50:  MOVF   01,W
04B52:  ADDLW  A0
04B54:  MOVWF  FE9
04B56:  MOVLW  09
04B58:  ADDWFC 03,W
04B5A:  MOVWF  FEA
04B5C:  MOVFF  FEF,B02
04B60:  MOVLW  01
04B62:  SUBWF  x00,W
04B64:  SUBWF  x02,W
04B66:  BZ    4B9C
04B68:  BNC   4B9C
....................    {Presion[canal].r=0;} 
04B6A:  CLRF   x20
04B6C:  MOVFF  B01,B1F
04B70:  CLRF   x22
04B72:  MOVLW  44
04B74:  MOVWF  x21
04B76:  MOVLB  0
04B78:  CALL   38A8
04B7C:  MOVFF  01,B02
04B80:  MOVLW  12
04B82:  MOVLB  B
04B84:  ADDWF  01,W
04B86:  MOVWF  01
04B88:  MOVLW  00
04B8A:  ADDWFC 02,W
04B8C:  MOVWF  03
04B8E:  MOVF   01,W
04B90:  ADDLW  A0
04B92:  MOVWF  FE9
04B94:  MOVLW  09
04B96:  ADDWFC 03,W
04B98:  MOVWF  FEA
04B9A:  CLRF   FEF
....................    Presion[canal].PromPresion[Presion[canal].r]=Presion[canal].Presion*4.02;Presion[canal].r++; 
04B9C:  CLRF   x20
04B9E:  MOVFF  B01,B1F
04BA2:  CLRF   x22
04BA4:  MOVLW  44
04BA6:  MOVWF  x21
04BA8:  MOVLB  0
04BAA:  CALL   38A8
04BAE:  MOVFF  02,B03
04BB2:  MOVFF  01,B02
04BB6:  MOVLW  18
04BB8:  MOVLB  B
04BBA:  ADDWF  x02,F
04BBC:  MOVLW  00
04BBE:  ADDWFC x03,F
04BC0:  CLRF   x20
04BC2:  MOVFF  B01,B1F
04BC6:  CLRF   x22
04BC8:  MOVLW  44
04BCA:  MOVWF  x21
04BCC:  MOVLB  0
04BCE:  CALL   38A8
04BD2:  MOVFF  02,B05
04BD6:  MOVFF  01,B04
04BDA:  MOVLW  12
04BDC:  MOVLB  B
04BDE:  ADDWF  01,W
04BE0:  MOVWF  01
04BE2:  MOVLW  00
04BE4:  ADDWFC 02,W
04BE6:  MOVWF  03
04BE8:  MOVF   01,W
04BEA:  ADDLW  A0
04BEC:  MOVWF  FE9
04BEE:  MOVLW  09
04BF0:  ADDWFC 03,W
04BF2:  MOVWF  FEA
04BF4:  CLRF   x20
04BF6:  MOVFF  FEF,B1F
04BFA:  CLRF   x22
04BFC:  MOVLW  04
04BFE:  MOVWF  x21
04C00:  MOVLB  0
04C02:  CALL   38A8
04C06:  MOVFF  02,03
04C0A:  MOVF   01,W
04C0C:  MOVLB  B
04C0E:  ADDWF  x02,W
04C10:  MOVWF  01
04C12:  MOVF   x03,W
04C14:  ADDWFC 03,F
04C16:  MOVF   01,W
04C18:  ADDLW  A0
04C1A:  MOVWF  01
04C1C:  MOVLW  09
04C1E:  ADDWFC 03,F
04C20:  MOVFF  01,B02
04C24:  MOVFF  03,B03
04C28:  CLRF   x20
04C2A:  MOVFF  B01,B1F
04C2E:  CLRF   x22
04C30:  MOVLW  44
04C32:  MOVWF  x21
04C34:  MOVLB  0
04C36:  CALL   38A8
04C3A:  MOVFF  01,B04
04C3E:  MOVLW  0A
04C40:  MOVLB  B
04C42:  ADDWF  01,W
04C44:  MOVWF  01
04C46:  MOVLW  00
04C48:  ADDWFC 02,W
04C4A:  MOVWF  03
04C4C:  MOVF   01,W
04C4E:  ADDLW  A0
04C50:  MOVWF  FE9
04C52:  MOVLW  09
04C54:  ADDWFC 03,W
04C56:  MOVWF  FEA
04C58:  MOVFF  FEF,B04
04C5C:  MOVFF  FEC,B05
04C60:  MOVFF  FEC,B06
04C64:  MOVFF  FEC,B07
04C68:  MOVFF  B07,B26
04C6C:  MOVFF  B06,B25
04C70:  MOVFF  B05,B24
04C74:  MOVFF  B04,B23
04C78:  MOVLW  D7
04C7A:  MOVWF  x2A
04C7C:  MOVLW  A3
04C7E:  MOVWF  x29
04C80:  CLRF   x28
04C82:  MOVLW  81
04C84:  MOVWF  x27
04C86:  MOVLB  0
04C88:  CALL   3908
04C8C:  MOVFF  B03,FEA
04C90:  MOVFF  B02,FE9
04C94:  MOVFF  00,FEF
04C98:  MOVFF  01,FEC
04C9C:  MOVFF  02,FEC
04CA0:  MOVFF  03,FEC
04CA4:  MOVLB  B
04CA6:  CLRF   x20
04CA8:  MOVFF  B01,B1F
04CAC:  CLRF   x22
04CAE:  MOVLW  44
04CB0:  MOVWF  x21
04CB2:  MOVLB  0
04CB4:  CALL   38A8
04CB8:  MOVFF  01,B02
04CBC:  MOVLW  12
04CBE:  MOVLB  B
04CC0:  ADDWF  01,W
04CC2:  MOVWF  01
04CC4:  MOVLW  00
04CC6:  ADDWFC 02,W
04CC8:  MOVWF  03
04CCA:  MOVF   01,W
04CCC:  ADDLW  A0
04CCE:  MOVWF  FE9
04CD0:  MOVLW  09
04CD2:  ADDWFC 03,W
04CD4:  MOVWF  FEA
04CD6:  INCF   FEF,F
....................           
....................    for(q=0;q<=(media-1);q++) 
04CD8:  MOVLB  0
04CDA:  CLRF   x8A
04CDC:  MOVLW  01
04CDE:  MOVLB  B
04CE0:  SUBWF  x00,W
04CE2:  MOVLB  0
04CE4:  SUBWF  x8A,W
04CE6:  BZ    4CEC
04CE8:  BTFSC  FD8.0
04CEA:  BRA    4DF2
....................    { 
....................       Presion[canal].promediopresion+=Presion[canal].PromPresion[q]; 
04CEC:  MOVLB  B
04CEE:  CLRF   x20
04CF0:  MOVFF  B01,B1F
04CF4:  CLRF   x22
04CF6:  MOVLW  44
04CF8:  MOVWF  x21
04CFA:  MOVLB  0
04CFC:  CALL   38A8
04D00:  MOVFF  01,B02
04D04:  MOVLW  40
04D06:  MOVLB  B
04D08:  ADDWF  01,W
04D0A:  MOVWF  01
04D0C:  MOVLW  00
04D0E:  ADDWFC 02,W
04D10:  MOVWF  03
04D12:  MOVF   01,W
04D14:  ADDLW  A0
04D16:  MOVWF  01
04D18:  MOVLW  09
04D1A:  ADDWFC 03,F
04D1C:  MOVFF  01,B02
04D20:  MOVFF  03,B03
04D24:  MOVFF  03,FEA
04D28:  MOVFF  01,FE9
04D2C:  MOVFF  FEF,B04
04D30:  MOVFF  FEC,B05
04D34:  MOVFF  FEC,B06
04D38:  MOVFF  FEC,B07
04D3C:  CLRF   x20
04D3E:  MOVFF  B01,B1F
04D42:  CLRF   x22
04D44:  MOVLW  44
04D46:  MOVWF  x21
04D48:  MOVLB  0
04D4A:  CALL   38A8
04D4E:  MOVFF  02,B09
04D52:  MOVFF  01,B08
04D56:  MOVLW  18
04D58:  MOVLB  B
04D5A:  ADDWF  x08,F
04D5C:  MOVLW  00
04D5E:  ADDWFC x09,F
04D60:  CLRF   x20
04D62:  MOVFF  8A,B1F
04D66:  CLRF   x22
04D68:  MOVLW  04
04D6A:  MOVWF  x21
04D6C:  MOVLB  0
04D6E:  CALL   38A8
04D72:  MOVFF  02,03
04D76:  MOVF   01,W
04D78:  MOVLB  B
04D7A:  ADDWF  x08,W
04D7C:  MOVWF  01
04D7E:  MOVF   x09,W
04D80:  ADDWFC 03,F
04D82:  MOVF   01,W
04D84:  ADDLW  A0
04D86:  MOVWF  FE9
04D88:  MOVLW  09
04D8A:  ADDWFC 03,W
04D8C:  MOVWF  FEA
04D8E:  MOVFF  FEF,00
04D92:  MOVFF  FEC,01
04D96:  MOVFF  FEC,02
04D9A:  MOVFF  FEC,03
04D9E:  MOVFF  FEA,B09
04DA2:  MOVFF  FE9,B08
04DA6:  BCF    FD8.1
04DA8:  MOVFF  B07,B26
04DAC:  MOVFF  B06,B25
04DB0:  MOVFF  B05,B24
04DB4:  MOVFF  B04,B23
04DB8:  MOVFF  03,B2A
04DBC:  MOVFF  02,B29
04DC0:  MOVFF  01,B28
04DC4:  MOVFF  00,B27
04DC8:  MOVLB  0
04DCA:  CALL   1500
04DCE:  MOVFF  B09,FEA
04DD2:  MOVFF  B08,FE9
04DD6:  MOVFF  B03,FEA
04DDA:  MOVFF  B02,FE9
04DDE:  MOVFF  00,FEF
04DE2:  MOVFF  01,FEC
04DE6:  MOVFF  02,FEC
04DEA:  MOVFF  03,FEC
....................    }  
04DEE:  INCF   x8A,F
04DF0:  BRA    4CDC
....................    Presion[canal].promediopresion=Presion[canal].promediopresion/media;    
04DF2:  MOVLB  B
04DF4:  CLRF   x20
04DF6:  MOVFF  B01,B1F
04DFA:  CLRF   x22
04DFC:  MOVLW  44
04DFE:  MOVWF  x21
04E00:  MOVLB  0
04E02:  CALL   38A8
04E06:  MOVFF  01,B02
04E0A:  MOVLW  40
04E0C:  MOVLB  B
04E0E:  ADDWF  01,W
04E10:  MOVWF  01
04E12:  MOVLW  00
04E14:  ADDWFC 02,W
04E16:  MOVWF  03
04E18:  MOVF   01,W
04E1A:  ADDLW  A0
04E1C:  MOVWF  01
04E1E:  MOVLW  09
04E20:  ADDWFC 03,F
04E22:  MOVFF  01,B02
04E26:  MOVFF  03,B03
04E2A:  CLRF   x20
04E2C:  MOVFF  B01,B1F
04E30:  CLRF   x22
04E32:  MOVLW  44
04E34:  MOVWF  x21
04E36:  MOVLB  0
04E38:  CALL   38A8
04E3C:  MOVFF  01,B04
04E40:  MOVLW  40
04E42:  MOVLB  B
04E44:  ADDWF  01,W
04E46:  MOVWF  01
04E48:  MOVLW  00
04E4A:  ADDWFC 02,W
04E4C:  MOVWF  03
04E4E:  MOVF   01,W
04E50:  ADDLW  A0
04E52:  MOVWF  FE9
04E54:  MOVLW  09
04E56:  ADDWFC 03,W
04E58:  MOVWF  FEA
04E5A:  MOVFF  FEF,B04
04E5E:  MOVFF  FEC,B05
04E62:  MOVFF  FEC,B06
04E66:  MOVFF  FEC,B07
04E6A:  CLRF   x20
04E6C:  MOVFF  B00,B1F
04E70:  MOVLB  0
04E72:  CALL   136C
04E76:  MOVFF  B07,B22
04E7A:  MOVFF  B06,B21
04E7E:  MOVFF  B05,B20
04E82:  MOVFF  B04,B1F
04E86:  MOVFF  03,B26
04E8A:  MOVFF  02,B25
04E8E:  MOVFF  01,B24
04E92:  MOVFF  00,B23
04E96:  CALL   13A2
04E9A:  MOVFF  B03,FEA
04E9E:  MOVFF  B02,FE9
04EA2:  MOVFF  00,FEF
04EA6:  MOVFF  01,FEC
04EAA:  MOVFF  02,FEC
04EAE:  MOVFF  03,FEC
....................     
....................    return Presion[canal].promediopresion*Presion[canal].Ajuste; 
04EB2:  MOVLB  B
04EB4:  CLRF   x20
04EB6:  MOVFF  B01,B1F
04EBA:  CLRF   x22
04EBC:  MOVLW  44
04EBE:  MOVWF  x21
04EC0:  MOVLB  0
04EC2:  CALL   38A8
04EC6:  MOVFF  01,B02
04ECA:  MOVLW  40
04ECC:  MOVLB  B
04ECE:  ADDWF  01,W
04ED0:  MOVWF  01
04ED2:  MOVLW  00
04ED4:  ADDWFC 02,W
04ED6:  MOVWF  03
04ED8:  MOVF   01,W
04EDA:  ADDLW  A0
04EDC:  MOVWF  FE9
04EDE:  MOVLW  09
04EE0:  ADDWFC 03,W
04EE2:  MOVWF  FEA
04EE4:  MOVFF  FEF,B02
04EE8:  MOVFF  FEC,B03
04EEC:  MOVFF  FEC,B04
04EF0:  MOVFF  FEC,B05
04EF4:  CLRF   x20
04EF6:  MOVFF  B01,B1F
04EFA:  CLRF   x22
04EFC:  MOVLW  44
04EFE:  MOVWF  x21
04F00:  MOVLB  0
04F02:  CALL   38A8
04F06:  MOVFF  02,B07
04F0A:  MOVFF  01,B06
04F0E:  MOVLW  14
04F10:  MOVLB  B
04F12:  ADDWF  01,W
04F14:  MOVWF  01
04F16:  MOVLW  00
04F18:  ADDWFC 02,W
04F1A:  MOVWF  03
04F1C:  MOVF   01,W
04F1E:  ADDLW  A0
04F20:  MOVWF  FE9
04F22:  MOVLW  09
04F24:  ADDWFC 03,W
04F26:  MOVWF  FEA
04F28:  MOVFF  FEF,00
04F2C:  MOVFF  FEC,01
04F30:  MOVFF  FEC,02
04F34:  MOVFF  FEC,03
04F38:  MOVFF  B05,B26
04F3C:  MOVFF  B04,B25
04F40:  MOVFF  B03,B24
04F44:  MOVFF  B02,B23
04F48:  MOVFF  03,B2A
04F4C:  MOVFF  02,B29
04F50:  MOVFF  01,B28
04F54:  MOVFF  00,B27
04F58:  MOVLB  0
04F5A:  CALL   3908
....................     
....................    //if(canal==4){//return Presion[canal].promediopresion*Presion[canal].Ajuste; 
....................    //   return Presion[canal].promediopresion*Ajustedn; 
....................    //}else{ 
....................        
....................    //} 
.................... } 
04F5E:  RETLW  00
....................  
.................... float leeTemperatura(int8 media){ 
04F60:  MOVLB  B
04F62:  CLRF   x04
04F64:  CLRF   x03
04F66:  CLRF   x02
04F68:  CLRF   x01
04F6A:  CLRF   x08
04F6C:  CLRF   x07
04F6E:  CLRF   x06
04F70:  CLRF   x05
04F72:  CLRF   x0C
04F74:  CLRF   x0B
04F76:  CLRF   x0A
04F78:  CLRF   x09
04F7A:  CLRF   x10
04F7C:  CLRF   x0F
04F7E:  CLRF   x0E
04F80:  CLRF   x0D
....................    float ADC=0,V=0,T=0,Tempera=0; 
....................    ADC=sensores(0); 
04F82:  CLRF   x1F
04F84:  MOVLB  0
04F86:  CALL   38CA
04F8A:  MOVFF  02,B20
04F8E:  MOVFF  01,B1F
04F92:  CALL   136C
04F96:  MOVFF  03,B04
04F9A:  MOVFF  02,B03
04F9E:  MOVFF  01,B02
04FA2:  MOVFF  00,B01
....................    V=5*ADC/1023; 
04FA6:  MOVLB  B
04FA8:  CLRF   x26
04FAA:  CLRF   x25
04FAC:  MOVLW  20
04FAE:  MOVWF  x24
04FB0:  MOVLW  81
04FB2:  MOVWF  x23
04FB4:  MOVFF  B04,B2A
04FB8:  MOVFF  B03,B29
04FBC:  MOVFF  B02,B28
04FC0:  MOVFF  B01,B27
04FC4:  MOVLB  0
04FC6:  CALL   3908
04FCA:  MOVFF  00,B11
04FCE:  MOVFF  01,B12
04FD2:  MOVFF  02,B13
04FD6:  MOVFF  03,B14
04FDA:  MOVFF  03,B22
04FDE:  MOVFF  02,B21
04FE2:  MOVFF  01,B20
04FE6:  MOVFF  00,B1F
04FEA:  MOVLB  B
04FEC:  CLRF   x26
04FEE:  MOVLW  C0
04FF0:  MOVWF  x25
04FF2:  MOVLW  7F
04FF4:  MOVWF  x24
04FF6:  MOVLW  88
04FF8:  MOVWF  x23
04FFA:  MOVLB  0
04FFC:  CALL   13A2
05000:  MOVFF  03,B08
05004:  MOVFF  02,B07
05008:  MOVFF  01,B06
0500C:  MOVFF  00,B05
....................    T=V/0.01; 
05010:  MOVFF  B08,B22
05014:  MOVFF  B07,B21
05018:  MOVFF  B06,B20
0501C:  MOVFF  B05,B1F
05020:  MOVLW  0A
05022:  MOVLB  B
05024:  MOVWF  x26
05026:  MOVLW  D7
05028:  MOVWF  x25
0502A:  MOVLW  23
0502C:  MOVWF  x24
0502E:  MOVLW  78
05030:  MOVWF  x23
05032:  MOVLB  0
05034:  CALL   13A2
05038:  MOVFF  03,B0C
0503C:  MOVFF  02,B0B
05040:  MOVFF  01,B0A
05044:  MOVFF  00,B09
....................    if(l2>media) 
05048:  MOVLB  2
0504A:  MOVF   xD0,W
0504C:  MOVLB  B
0504E:  SUBWF  x00,W
05050:  BC    5056
....................       l2=0; 
05052:  MOVLB  2
05054:  CLRF   xD0
....................        
....................    promedio2[l2]=T;l2++; 
05056:  MOVLB  2
05058:  MOVF   xD0,W
0505A:  MULLW  04
0505C:  MOVF   FF3,W
0505E:  CLRF   03
05060:  ADDLW  A1
05062:  MOVWF  FE9
05064:  MOVLW  01
05066:  ADDWFC 03,W
05068:  MOVWF  FEA
0506A:  MOVFF  B09,FEF
0506E:  MOVFF  B0A,FEC
05072:  MOVFF  B0B,FEC
05076:  MOVFF  B0C,FEC
0507A:  INCF   xD0,F
....................    Tempera=0; 
0507C:  MOVLB  B
0507E:  CLRF   x10
05080:  CLRF   x0F
05082:  CLRF   x0E
05084:  CLRF   x0D
....................       
....................      for(h2=0;h2<=(media-1);h2++){ 
05086:  MOVLB  2
05088:  CLRF   xD1
0508A:  MOVLW  01
0508C:  MOVLB  B
0508E:  SUBWF  x00,W
05090:  MOVLB  2
05092:  SUBWF  xD1,W
05094:  BZ    5098
05096:  BC    5108
....................         Tempera+=promedio2[h2]; 
05098:  MOVF   xD1,W
0509A:  MULLW  04
0509C:  MOVF   FF3,W
0509E:  CLRF   03
050A0:  ADDLW  A1
050A2:  MOVWF  FE9
050A4:  MOVLW  01
050A6:  ADDWFC 03,W
050A8:  MOVWF  FEA
050AA:  MOVFF  FEF,00
050AE:  MOVFF  FEC,01
050B2:  MOVFF  FEC,02
050B6:  MOVFF  FEC,03
050BA:  MOVFF  FEA,B12
050BE:  MOVFF  FE9,B11
050C2:  BCF    FD8.1
050C4:  MOVFF  B10,B26
050C8:  MOVFF  B0F,B25
050CC:  MOVFF  B0E,B24
050D0:  MOVFF  B0D,B23
050D4:  MOVFF  03,B2A
050D8:  MOVFF  02,B29
050DC:  MOVFF  01,B28
050E0:  MOVFF  00,B27
050E4:  MOVLB  0
050E6:  CALL   1500
050EA:  MOVFF  B12,FEA
050EE:  MOVFF  B11,FE9
050F2:  MOVFF  03,B10
050F6:  MOVFF  02,B0F
050FA:  MOVFF  01,B0E
050FE:  MOVFF  00,B0D
....................      }       
05102:  MOVLB  2
05104:  INCF   xD1,F
05106:  BRA    508A
....................    return Tempera/media; 
05108:  MOVLB  B
0510A:  CLRF   x20
0510C:  MOVFF  B00,B1F
05110:  MOVLB  0
05112:  CALL   136C
05116:  MOVFF  B10,B22
0511A:  MOVFF  B0F,B21
0511E:  MOVFF  B0E,B20
05122:  MOVFF  B0D,B1F
05126:  MOVFF  03,B26
0512A:  MOVFF  02,B25
0512E:  MOVFF  01,B24
05132:  MOVFF  00,B23
05136:  CALL   13A2
.................... } 
0513A:  GOTO   66F8 (RETURN)
....................  
.................... void LeeEEPROM(void){ 
....................    Password[0]=read_eeprom(0); 
*
01778:  MOVFF  FF2,B00
0177C:  BCF    FF2.6
0177E:  BCF    FF2.7
01780:  CLRF   FAA
01782:  CLRF   FA9
01784:  BCF    FA6.6
01786:  BCF    FA6.7
01788:  BSF    FA6.0
0178A:  MOVF   FA8,W
0178C:  MOVLB  B
0178E:  BTFSC  x00.6
01790:  BSF    FF2.6
01792:  BTFSC  x00.7
01794:  BSF    FF2.7
01796:  MOVLB  0
01798:  MOVWF  xD1
....................    delay_ms(10); 
0179A:  MOVLW  0A
0179C:  MOVLB  B
0179E:  MOVWF  x22
017A0:  MOVLB  0
017A2:  RCALL  11F6
....................    Password[1]=read_eeprom(1); 
017A4:  MOVFF  FF2,B00
017A8:  BCF    FF2.6
017AA:  BCF    FF2.7
017AC:  CLRF   FAA
017AE:  MOVLW  01
017B0:  MOVWF  FA9
017B2:  BCF    FA6.6
017B4:  BCF    FA6.7
017B6:  BSF    FA6.0
017B8:  MOVF   FA8,W
017BA:  MOVLB  B
017BC:  BTFSC  x00.6
017BE:  BSF    FF2.6
017C0:  BTFSC  x00.7
017C2:  BSF    FF2.7
017C4:  MOVLB  0
017C6:  MOVWF  xD2
....................    delay_ms(10); 
017C8:  MOVLW  0A
017CA:  MOVLB  B
017CC:  MOVWF  x22
017CE:  MOVLB  0
017D0:  RCALL  11F6
....................    Password[2]=read_eeprom(2); 
017D2:  MOVFF  FF2,B00
017D6:  BCF    FF2.6
017D8:  BCF    FF2.7
017DA:  CLRF   FAA
017DC:  MOVLW  02
017DE:  MOVWF  FA9
017E0:  BCF    FA6.6
017E2:  BCF    FA6.7
017E4:  BSF    FA6.0
017E6:  MOVF   FA8,W
017E8:  MOVLB  B
017EA:  BTFSC  x00.6
017EC:  BSF    FF2.6
017EE:  BTFSC  x00.7
017F0:  BSF    FF2.7
017F2:  MOVLB  0
017F4:  MOVWF  xD3
....................    delay_ms(10); 
017F6:  MOVLW  0A
017F8:  MOVLB  B
017FA:  MOVWF  x22
017FC:  MOVLB  0
017FE:  RCALL  11F6
....................    Password[3]=read_eeprom(3); 
01800:  MOVFF  FF2,B00
01804:  BCF    FF2.6
01806:  BCF    FF2.7
01808:  CLRF   FAA
0180A:  MOVLW  03
0180C:  MOVWF  FA9
0180E:  BCF    FA6.6
01810:  BCF    FA6.7
01812:  BSF    FA6.0
01814:  MOVF   FA8,W
01816:  MOVLB  B
01818:  BTFSC  x00.6
0181A:  BSF    FF2.6
0181C:  BTFSC  x00.7
0181E:  BSF    FF2.7
01820:  MOVLB  0
01822:  MOVWF  xD4
....................    delay_ms(10); 
01824:  MOVLW  0A
01826:  MOVLB  B
01828:  MOVWF  x22
0182A:  MOVLB  0
0182C:  RCALL  11F6
....................    mPurgap=read_eeprom(4); 
0182E:  MOVFF  FF2,B00
01832:  BCF    FF2.6
01834:  BCF    FF2.7
01836:  CLRF   FAA
01838:  MOVLW  04
0183A:  MOVWF  FA9
0183C:  BCF    FA6.6
0183E:  BCF    FA6.7
01840:  BSF    FA6.0
01842:  MOVF   FA8,W
01844:  MOVLB  B
01846:  BTFSC  x00.6
01848:  BSF    FF2.6
0184A:  BTFSC  x00.7
0184C:  BSF    FF2.7
0184E:  MOVLB  0
01850:  MOVWF  xAF
....................    delay_ms(10); 
01852:  MOVLW  0A
01854:  MOVLB  B
01856:  MOVWF  x22
01858:  MOVLB  0
0185A:  RCALL  11F6
....................    sPurgap=read_eeprom(5); 
0185C:  MOVFF  FF2,B00
01860:  BCF    FF2.6
01862:  BCF    FF2.7
01864:  CLRF   FAA
01866:  MOVLW  05
01868:  MOVWF  FA9
0186A:  BCF    FA6.6
0186C:  BCF    FA6.7
0186E:  BSF    FA6.0
01870:  MOVF   FA8,W
01872:  MOVLB  B
01874:  BTFSC  x00.6
01876:  BSF    FF2.6
01878:  BTFSC  x00.7
0187A:  BSF    FF2.7
0187C:  MOVLB  0
0187E:  MOVWF  xAD
....................    delay_ms(10); 
01880:  MOVLW  0A
01882:  MOVLB  B
01884:  MOVWF  x22
01886:  MOVLB  0
01888:  RCALL  11F6
....................    mPPurgap=read_eeprom(6); 
0188A:  MOVFF  FF2,B00
0188E:  BCF    FF2.6
01890:  BCF    FF2.7
01892:  CLRF   FAA
01894:  MOVLW  06
01896:  MOVWF  FA9
01898:  BCF    FA6.6
0189A:  BCF    FA6.7
0189C:  BSF    FA6.0
0189E:  MOVF   FA8,W
018A0:  MOVLB  B
018A2:  BTFSC  x00.6
018A4:  BSF    FF2.6
018A6:  BTFSC  x00.7
018A8:  BSF    FF2.7
018AA:  MOVLB  0
018AC:  MOVWF  xB3
....................    delay_ms(10); 
018AE:  MOVLW  0A
018B0:  MOVLB  B
018B2:  MOVWF  x22
018B4:  MOVLB  0
018B6:  RCALL  11F6
....................    sPPurgap=read_eeprom(7); 
018B8:  MOVFF  FF2,B00
018BC:  BCF    FF2.6
018BE:  BCF    FF2.7
018C0:  CLRF   FAA
018C2:  MOVLW  07
018C4:  MOVWF  FA9
018C6:  BCF    FA6.6
018C8:  BCF    FA6.7
018CA:  BSF    FA6.0
018CC:  MOVF   FA8,W
018CE:  MOVLB  B
018D0:  BTFSC  x00.6
018D2:  BSF    FF2.6
018D4:  BTFSC  x00.7
018D6:  BSF    FF2.7
018D8:  MOVLB  0
018DA:  MOVWF  xB1
....................    delay_ms(10); 
018DC:  MOVLW  0A
018DE:  MOVLB  B
018E0:  MOVWF  x22
018E2:  MOVLB  0
018E4:  RCALL  11F6
....................    mUVp=read_eeprom(8); 
018E6:  MOVFF  FF2,B00
018EA:  BCF    FF2.6
018EC:  BCF    FF2.7
018EE:  CLRF   FAA
018F0:  MOVLW  08
018F2:  MOVWF  FA9
018F4:  BCF    FA6.6
018F6:  BCF    FA6.7
018F8:  BSF    FA6.0
018FA:  MOVF   FA8,W
018FC:  MOVLB  B
018FE:  BTFSC  x00.6
01900:  BSF    FF2.6
01902:  BTFSC  x00.7
01904:  BSF    FF2.7
01906:  MOVLB  0
01908:  MOVWF  xB7
....................    delay_ms(10); 
0190A:  MOVLW  0A
0190C:  MOVLB  B
0190E:  MOVWF  x22
01910:  MOVLB  0
01912:  RCALL  11F6
....................    sUVp=read_eeprom(9); 
01914:  MOVFF  FF2,B00
01918:  BCF    FF2.6
0191A:  BCF    FF2.7
0191C:  CLRF   FAA
0191E:  MOVLW  09
01920:  MOVWF  FA9
01922:  BCF    FA6.6
01924:  BCF    FA6.7
01926:  BSF    FA6.0
01928:  MOVF   FA8,W
0192A:  MOVLB  B
0192C:  BTFSC  x00.6
0192E:  BSF    FF2.6
01930:  BTFSC  x00.7
01932:  BSF    FF2.7
01934:  MOVLB  0
01936:  MOVWF  xB6
....................    delay_ms(10); 
01938:  MOVLW  0A
0193A:  MOVLB  B
0193C:  MOVWF  x22
0193E:  MOVLB  0
01940:  RCALL  11F6
....................     
....................    Tuv[0]=read_eeprom(12); 
01942:  MOVFF  FF2,B00
01946:  BCF    FF2.6
01948:  BCF    FF2.7
0194A:  CLRF   FAA
0194C:  MOVLW  0C
0194E:  MOVWF  FA9
01950:  BCF    FA6.6
01952:  BCF    FA6.7
01954:  BSF    FA6.0
01956:  MOVF   FA8,W
01958:  MOVLB  B
0195A:  BTFSC  x00.6
0195C:  BSF    FF2.6
0195E:  BTFSC  x00.7
01960:  BSF    FF2.7
01962:  MOVLB  0
01964:  MOVWF  xC9
....................    delay_ms(10); 
01966:  MOVLW  0A
01968:  MOVLB  B
0196A:  MOVWF  x22
0196C:  MOVLB  0
0196E:  RCALL  11F6
....................    Tuv[1]=read_eeprom(13); 
01970:  MOVFF  FF2,B00
01974:  BCF    FF2.6
01976:  BCF    FF2.7
01978:  CLRF   FAA
0197A:  MOVLW  0D
0197C:  MOVWF  FA9
0197E:  BCF    FA6.6
01980:  BCF    FA6.7
01982:  BSF    FA6.0
01984:  MOVF   FA8,W
01986:  MOVLB  B
01988:  BTFSC  x00.6
0198A:  BSF    FF2.6
0198C:  BTFSC  x00.7
0198E:  BSF    FF2.7
01990:  MOVLB  0
01992:  MOVWF  xCA
....................    delay_ms(10); 
01994:  MOVLW  0A
01996:  MOVLB  B
01998:  MOVWF  x22
0199A:  MOVLB  0
0199C:  RCALL  11F6
....................    Tuv[2]=read_eeprom(14); 
0199E:  MOVFF  FF2,B00
019A2:  BCF    FF2.6
019A4:  BCF    FF2.7
019A6:  CLRF   FAA
019A8:  MOVLW  0E
019AA:  MOVWF  FA9
019AC:  BCF    FA6.6
019AE:  BCF    FA6.7
019B0:  BSF    FA6.0
019B2:  MOVF   FA8,W
019B4:  MOVLB  B
019B6:  BTFSC  x00.6
019B8:  BSF    FF2.6
019BA:  BTFSC  x00.7
019BC:  BSF    FF2.7
019BE:  MOVLB  0
019C0:  MOVWF  xCB
....................    delay_ms(10); 
019C2:  MOVLW  0A
019C4:  MOVLB  B
019C6:  MOVWF  x22
019C8:  MOVLB  0
019CA:  RCALL  11F6
....................    Tuv[3]=read_eeprom(15); 
019CC:  MOVFF  FF2,B00
019D0:  BCF    FF2.6
019D2:  BCF    FF2.7
019D4:  CLRF   FAA
019D6:  MOVLW  0F
019D8:  MOVWF  FA9
019DA:  BCF    FA6.6
019DC:  BCF    FA6.7
019DE:  BSF    FA6.0
019E0:  MOVF   FA8,W
019E2:  MOVLB  B
019E4:  BTFSC  x00.6
019E6:  BSF    FF2.6
019E8:  BTFSC  x00.7
019EA:  BSF    FF2.7
019EC:  MOVLB  0
019EE:  MOVWF  xCC
....................    delay_ms(10); 
019F0:  MOVLW  0A
019F2:  MOVLB  B
019F4:  MOVWF  x22
019F6:  MOVLB  0
019F8:  CALL   11F6
....................    Ttrabajo[0]=read_eeprom(16); 
019FC:  MOVFF  FF2,B00
01A00:  BCF    FF2.6
01A02:  BCF    FF2.7
01A04:  CLRF   FAA
01A06:  MOVLW  10
01A08:  MOVWF  FA9
01A0A:  BCF    FA6.6
01A0C:  BCF    FA6.7
01A0E:  BSF    FA6.0
01A10:  MOVF   FA8,W
01A12:  MOVLB  B
01A14:  BTFSC  x00.6
01A16:  BSF    FF2.6
01A18:  BTFSC  x00.7
01A1A:  BSF    FF2.7
01A1C:  MOVLB  0
01A1E:  MOVWF  xCD
....................    delay_ms(10); 
01A20:  MOVLW  0A
01A22:  MOVLB  B
01A24:  MOVWF  x22
01A26:  MOVLB  0
01A28:  CALL   11F6
....................    Ttrabajo[1]=read_eeprom(17); 
01A2C:  MOVFF  FF2,B00
01A30:  BCF    FF2.6
01A32:  BCF    FF2.7
01A34:  CLRF   FAA
01A36:  MOVLW  11
01A38:  MOVWF  FA9
01A3A:  BCF    FA6.6
01A3C:  BCF    FA6.7
01A3E:  BSF    FA6.0
01A40:  MOVF   FA8,W
01A42:  MOVLB  B
01A44:  BTFSC  x00.6
01A46:  BSF    FF2.6
01A48:  BTFSC  x00.7
01A4A:  BSF    FF2.7
01A4C:  MOVLB  0
01A4E:  MOVWF  xCE
....................    delay_ms(10); 
01A50:  MOVLW  0A
01A52:  MOVLB  B
01A54:  MOVWF  x22
01A56:  MOVLB  0
01A58:  CALL   11F6
....................    Ttrabajo[2]=read_eeprom(18); 
01A5C:  MOVFF  FF2,B00
01A60:  BCF    FF2.6
01A62:  BCF    FF2.7
01A64:  CLRF   FAA
01A66:  MOVLW  12
01A68:  MOVWF  FA9
01A6A:  BCF    FA6.6
01A6C:  BCF    FA6.7
01A6E:  BSF    FA6.0
01A70:  MOVF   FA8,W
01A72:  MOVLB  B
01A74:  BTFSC  x00.6
01A76:  BSF    FF2.6
01A78:  BTFSC  x00.7
01A7A:  BSF    FF2.7
01A7C:  MOVLB  0
01A7E:  MOVWF  xCF
....................    delay_ms(10); 
01A80:  MOVLW  0A
01A82:  MOVLB  B
01A84:  MOVWF  x22
01A86:  MOVLB  0
01A88:  CALL   11F6
....................    Ttrabajo[3]=read_eeprom(19); 
01A8C:  MOVFF  FF2,B00
01A90:  BCF    FF2.6
01A92:  BCF    FF2.7
01A94:  CLRF   FAA
01A96:  MOVLW  13
01A98:  MOVWF  FA9
01A9A:  BCF    FA6.6
01A9C:  BCF    FA6.7
01A9E:  BSF    FA6.0
01AA0:  MOVF   FA8,W
01AA2:  MOVLB  B
01AA4:  BTFSC  x00.6
01AA6:  BSF    FF2.6
01AA8:  BTFSC  x00.7
01AAA:  BSF    FF2.7
01AAC:  MOVLB  0
01AAE:  MOVWF  xD0
....................    delay_ms(10); 
01AB0:  MOVLW  0A
01AB2:  MOVLB  B
01AB4:  MOVWF  x22
01AB6:  MOVLB  0
01AB8:  CALL   11F6
....................    //flag_alarma=read_eeprom(20); 
....................    //delay_ms(10); 
....................     
....................    delay_ms(10); 
01ABC:  MOVLW  0A
01ABE:  MOVLB  B
01AC0:  MOVWF  x22
01AC2:  MOVLB  0
01AC4:  CALL   11F6
....................    Entero=read_eeprom(25); 
01AC8:  MOVFF  FF2,B00
01ACC:  BCF    FF2.6
01ACE:  BCF    FF2.7
01AD0:  CLRF   FAA
01AD2:  MOVLW  19
01AD4:  MOVWF  FA9
01AD6:  BCF    FA6.6
01AD8:  BCF    FA6.7
01ADA:  BSF    FA6.0
01ADC:  MOVF   FA8,W
01ADE:  MOVLB  B
01AE0:  BTFSC  x00.6
01AE2:  BSF    FF2.6
01AE4:  BTFSC  x00.7
01AE6:  BSF    FF2.7
01AE8:  MOVLB  0
01AEA:  MOVWF  x8E
....................    delay_ms(10); 
01AEC:  MOVLW  0A
01AEE:  MOVLB  B
01AF0:  MOVWF  x22
01AF2:  MOVLB  0
01AF4:  CALL   11F6
....................    Temporal=read_eeprom(26); 
01AF8:  MOVFF  FF2,B00
01AFC:  BCF    FF2.6
01AFE:  BCF    FF2.7
01B00:  CLRF   FAA
01B02:  MOVLW  1A
01B04:  MOVWF  FA9
01B06:  BCF    FA6.6
01B08:  BCF    FA6.7
01B0A:  BSF    FA6.0
01B0C:  MOVF   FA8,W
01B0E:  MOVLB  B
01B10:  BTFSC  x00.6
01B12:  BSF    FF2.6
01B14:  BTFSC  x00.7
01B16:  BSF    FF2.7
01B18:  CLRF   x20
01B1A:  MOVWF  x1F
01B1C:  MOVLB  0
01B1E:  RCALL  136C
01B20:  MOVFF  03,100
01B24:  MOVFF  02,FF
01B28:  MOVFF  01,FE
01B2C:  MOVFF  00,FD
....................    delay_ms(10); 
01B30:  MOVLW  0A
01B32:  MOVLB  B
01B34:  MOVWF  x22
01B36:  MOVLB  0
01B38:  CALL   11F6
....................    Temporal=Temporal/10.0; 
01B3C:  MOVFF  100,B22
01B40:  MOVFF  FF,B21
01B44:  MOVFF  FE,B20
01B48:  MOVFF  FD,B1F
01B4C:  MOVLB  B
01B4E:  CLRF   x26
01B50:  CLRF   x25
01B52:  MOVLW  20
01B54:  MOVWF  x24
01B56:  MOVLW  82
01B58:  MOVWF  x23
01B5A:  MOVLB  0
01B5C:  RCALL  13A2
01B5E:  MOVFF  03,100
01B62:  MOVFF  02,FF
01B66:  MOVFF  01,FE
01B6A:  MOVFF  00,FD
....................    Flujo[1].Ajuste=Entero+Temporal; 
01B6E:  MOVLB  B
01B70:  CLRF   x20
01B72:  MOVFF  8E,B1F
01B76:  MOVLB  0
01B78:  CALL   136C
01B7C:  BCF    FD8.1
01B7E:  MOVFF  03,B26
01B82:  MOVFF  02,B25
01B86:  MOVFF  01,B24
01B8A:  MOVFF  00,B23
01B8E:  MOVFF  100,B2A
01B92:  MOVFF  FF,B29
01B96:  MOVFF  FE,B28
01B9A:  MOVFF  FD,B27
01B9E:  RCALL  1500
01BA0:  MOVFF  03,454
01BA4:  MOVFF  02,453
01BA8:  MOVFF  01,452
01BAC:  MOVFF  00,451
....................     
....................     
....................    Entero=read_eeprom(27); 
01BB0:  MOVFF  FF2,B00
01BB4:  BCF    FF2.6
01BB6:  BCF    FF2.7
01BB8:  CLRF   FAA
01BBA:  MOVLW  1B
01BBC:  MOVWF  FA9
01BBE:  BCF    FA6.6
01BC0:  BCF    FA6.7
01BC2:  BSF    FA6.0
01BC4:  MOVF   FA8,W
01BC6:  MOVLB  B
01BC8:  BTFSC  x00.6
01BCA:  BSF    FF2.6
01BCC:  BTFSC  x00.7
01BCE:  BSF    FF2.7
01BD0:  MOVLB  0
01BD2:  MOVWF  x8E
....................    delay_ms(10); 
01BD4:  MOVLW  0A
01BD6:  MOVLB  B
01BD8:  MOVWF  x22
01BDA:  MOVLB  0
01BDC:  CALL   11F6
....................    Temporal=read_eeprom(28); 
01BE0:  MOVFF  FF2,B00
01BE4:  BCF    FF2.6
01BE6:  BCF    FF2.7
01BE8:  CLRF   FAA
01BEA:  MOVLW  1C
01BEC:  MOVWF  FA9
01BEE:  BCF    FA6.6
01BF0:  BCF    FA6.7
01BF2:  BSF    FA6.0
01BF4:  MOVF   FA8,W
01BF6:  MOVLB  B
01BF8:  BTFSC  x00.6
01BFA:  BSF    FF2.6
01BFC:  BTFSC  x00.7
01BFE:  BSF    FF2.7
01C00:  CLRF   x20
01C02:  MOVWF  x1F
01C04:  MOVLB  0
01C06:  CALL   136C
01C0A:  MOVFF  03,100
01C0E:  MOVFF  02,FF
01C12:  MOVFF  01,FE
01C16:  MOVFF  00,FD
....................    delay_ms(10); 
01C1A:  MOVLW  0A
01C1C:  MOVLB  B
01C1E:  MOVWF  x22
01C20:  MOVLB  0
01C22:  CALL   11F6
....................    Temporal=Temporal/10.0; 
01C26:  MOVFF  100,B22
01C2A:  MOVFF  FF,B21
01C2E:  MOVFF  FE,B20
01C32:  MOVFF  FD,B1F
01C36:  MOVLB  B
01C38:  CLRF   x26
01C3A:  CLRF   x25
01C3C:  MOVLW  20
01C3E:  MOVWF  x24
01C40:  MOVLW  82
01C42:  MOVWF  x23
01C44:  MOVLB  0
01C46:  CALL   13A2
01C4A:  MOVFF  03,100
01C4E:  MOVFF  02,FF
01C52:  MOVFF  01,FE
01C56:  MOVFF  00,FD
....................    Flujo[2].Ajuste=Entero+Temporal; 
01C5A:  MOVLB  B
01C5C:  CLRF   x20
01C5E:  MOVFF  8E,B1F
01C62:  MOVLB  0
01C64:  CALL   136C
01C68:  BCF    FD8.1
01C6A:  MOVFF  03,B26
01C6E:  MOVFF  02,B25
01C72:  MOVFF  01,B24
01C76:  MOVFF  00,B23
01C7A:  MOVFF  100,B2A
01C7E:  MOVFF  FF,B29
01C82:  MOVFF  FE,B28
01C86:  MOVFF  FD,B27
01C8A:  RCALL  1500
01C8C:  MOVFF  03,5AD
01C90:  MOVFF  02,5AC
01C94:  MOVFF  01,5AB
01C98:  MOVFF  00,5AA
....................     
....................    delay_ms(10); 
01C9C:  MOVLW  0A
01C9E:  MOVLB  B
01CA0:  MOVWF  x22
01CA2:  MOVLB  0
01CA4:  CALL   11F6
....................    Entero=read_eeprom(29);//Decimal1=read_eeprom(26); 
01CA8:  MOVFF  FF2,B00
01CAC:  BCF    FF2.6
01CAE:  BCF    FF2.7
01CB0:  CLRF   FAA
01CB2:  MOVLW  1D
01CB4:  MOVWF  FA9
01CB6:  BCF    FA6.6
01CB8:  BCF    FA6.7
01CBA:  BSF    FA6.0
01CBC:  MOVF   FA8,W
01CBE:  MOVLB  B
01CC0:  BTFSC  x00.6
01CC2:  BSF    FF2.6
01CC4:  BTFSC  x00.7
01CC6:  BSF    FF2.7
01CC8:  MOVLB  0
01CCA:  MOVWF  x8E
....................    delay_ms(10); 
01CCC:  MOVLW  0A
01CCE:  MOVLB  B
01CD0:  MOVWF  x22
01CD2:  MOVLB  0
01CD4:  CALL   11F6
....................    Temporal=read_eeprom(30); 
01CD8:  MOVFF  FF2,B00
01CDC:  BCF    FF2.6
01CDE:  BCF    FF2.7
01CE0:  CLRF   FAA
01CE2:  MOVLW  1E
01CE4:  MOVWF  FA9
01CE6:  BCF    FA6.6
01CE8:  BCF    FA6.7
01CEA:  BSF    FA6.0
01CEC:  MOVF   FA8,W
01CEE:  MOVLB  B
01CF0:  BTFSC  x00.6
01CF2:  BSF    FF2.6
01CF4:  BTFSC  x00.7
01CF6:  BSF    FF2.7
01CF8:  CLRF   x20
01CFA:  MOVWF  x1F
01CFC:  MOVLB  0
01CFE:  CALL   136C
01D02:  MOVFF  03,100
01D06:  MOVFF  02,FF
01D0A:  MOVFF  01,FE
01D0E:  MOVFF  00,FD
....................    delay_ms(10); 
01D12:  MOVLW  0A
01D14:  MOVLB  B
01D16:  MOVWF  x22
01D18:  MOVLB  0
01D1A:  CALL   11F6
....................    Temporal=Temporal/10.0; 
01D1E:  MOVFF  100,B22
01D22:  MOVFF  FF,B21
01D26:  MOVFF  FE,B20
01D2A:  MOVFF  FD,B1F
01D2E:  MOVLB  B
01D30:  CLRF   x26
01D32:  CLRF   x25
01D34:  MOVLW  20
01D36:  MOVWF  x24
01D38:  MOVLW  82
01D3A:  MOVWF  x23
01D3C:  MOVLB  0
01D3E:  CALL   13A2
01D42:  MOVFF  03,100
01D46:  MOVFF  02,FF
01D4A:  MOVFF  01,FE
01D4E:  MOVFF  00,FD
....................    Presion[4].Ajuste=Entero+Temporal; 
01D52:  MOVLB  B
01D54:  CLRF   x20
01D56:  MOVFF  8E,B1F
01D5A:  MOVLB  0
01D5C:  CALL   136C
01D60:  BCF    FD8.1
01D62:  MOVFF  03,B26
01D66:  MOVFF  02,B25
01D6A:  MOVFF  01,B24
01D6E:  MOVFF  00,B23
01D72:  MOVFF  100,B2A
01D76:  MOVFF  FF,B29
01D7A:  MOVFF  FE,B28
01D7E:  MOVFF  FD,B27
01D82:  CALL   1500
01D86:  MOVFF  03,AC7
01D8A:  MOVFF  02,AC6
01D8E:  MOVFF  01,AC5
01D92:  MOVFF  00,AC4
....................    //Ajustedn=Entero+Temporal; 
....................     
....................     
....................    Entero=read_eeprom(31);//Decimal1=read_eeprom(26); 
01D96:  MOVFF  FF2,B00
01D9A:  BCF    FF2.6
01D9C:  BCF    FF2.7
01D9E:  CLRF   FAA
01DA0:  MOVLW  1F
01DA2:  MOVWF  FA9
01DA4:  BCF    FA6.6
01DA6:  BCF    FA6.7
01DA8:  BSF    FA6.0
01DAA:  MOVF   FA8,W
01DAC:  MOVLB  B
01DAE:  BTFSC  x00.6
01DB0:  BSF    FF2.6
01DB2:  BTFSC  x00.7
01DB4:  BSF    FF2.7
01DB6:  MOVLB  0
01DB8:  MOVWF  x8E
....................    delay_ms(10); 
01DBA:  MOVLW  0A
01DBC:  MOVLB  B
01DBE:  MOVWF  x22
01DC0:  MOVLB  0
01DC2:  CALL   11F6
....................    Temporal=read_eeprom(32); 
01DC6:  MOVFF  FF2,B00
01DCA:  BCF    FF2.6
01DCC:  BCF    FF2.7
01DCE:  CLRF   FAA
01DD0:  MOVLW  20
01DD2:  MOVWF  FA9
01DD4:  BCF    FA6.6
01DD6:  BCF    FA6.7
01DD8:  BSF    FA6.0
01DDA:  MOVF   FA8,W
01DDC:  MOVLB  B
01DDE:  BTFSC  x00.6
01DE0:  BSF    FF2.6
01DE2:  BTFSC  x00.7
01DE4:  BSF    FF2.7
01DE6:  CLRF   x20
01DE8:  MOVWF  x1F
01DEA:  MOVLB  0
01DEC:  CALL   136C
01DF0:  MOVFF  03,100
01DF4:  MOVFF  02,FF
01DF8:  MOVFF  01,FE
01DFC:  MOVFF  00,FD
....................    delay_ms(10); 
01E00:  MOVLW  0A
01E02:  MOVLB  B
01E04:  MOVWF  x22
01E06:  MOVLB  0
01E08:  CALL   11F6
....................    Temporal=Temporal/10.0; 
01E0C:  MOVFF  100,B22
01E10:  MOVFF  FF,B21
01E14:  MOVFF  FE,B20
01E18:  MOVFF  FD,B1F
01E1C:  MOVLB  B
01E1E:  CLRF   x26
01E20:  CLRF   x25
01E22:  MOVLW  20
01E24:  MOVWF  x24
01E26:  MOVLW  82
01E28:  MOVWF  x23
01E2A:  MOVLB  0
01E2C:  CALL   13A2
01E30:  MOVFF  03,100
01E34:  MOVFF  02,FF
01E38:  MOVFF  01,FE
01E3C:  MOVFF  00,FD
....................    Presion[3].Ajuste=Entero+Temporal; 
01E40:  MOVLB  B
01E42:  CLRF   x20
01E44:  MOVFF  8E,B1F
01E48:  MOVLB  0
01E4A:  CALL   136C
01E4E:  BCF    FD8.1
01E50:  MOVFF  03,B26
01E54:  MOVFF  02,B25
01E58:  MOVFF  01,B24
01E5C:  MOVFF  00,B23
01E60:  MOVFF  100,B2A
01E64:  MOVFF  FF,B29
01E68:  MOVFF  FE,B28
01E6C:  MOVFF  FD,B27
01E70:  CALL   1500
01E74:  MOVFF  03,A83
01E78:  MOVFF  02,A82
01E7C:  MOVFF  01,A81
01E80:  MOVFF  00,A80
....................     
....................    Flujo[1].zero_actual=make16(read_eeprom(34),read_eeprom(33)); 
01E84:  MOVFF  FF2,B00
01E88:  BCF    FF2.6
01E8A:  BCF    FF2.7
01E8C:  CLRF   FAA
01E8E:  MOVLW  22
01E90:  MOVWF  FA9
01E92:  BCF    FA6.6
01E94:  BCF    FA6.7
01E96:  BSF    FA6.0
01E98:  MOVF   FA8,W
01E9A:  MOVLB  B
01E9C:  BTFSC  x00.6
01E9E:  BSF    FF2.6
01EA0:  BTFSC  x00.7
01EA2:  BSF    FF2.7
01EA4:  MOVWF  x01
01EA6:  MOVFF  FF2,B02
01EAA:  BCF    FF2.6
01EAC:  BCF    FF2.7
01EAE:  CLRF   FAA
01EB0:  MOVLW  21
01EB2:  MOVWF  FA9
01EB4:  BCF    FA6.6
01EB6:  BCF    FA6.7
01EB8:  BSF    FA6.0
01EBA:  MOVF   FA8,W
01EBC:  BTFSC  x02.6
01EBE:  BSF    FF2.6
01EC0:  BTFSC  x02.7
01EC2:  BSF    FF2.7
01EC4:  MOVWF  x03
01EC6:  MOVFF  B01,03
01ECA:  MOVF   x03,W
01ECC:  MOVWF  x1F
01ECE:  MOVFF  03,B20
01ED2:  MOVLB  0
01ED4:  CALL   136C
01ED8:  MOVFF  03,43F
01EDC:  MOVFF  02,43E
01EE0:  MOVFF  01,43D
01EE4:  MOVFF  00,43C
....................    delay_ms(10); 
01EE8:  MOVLW  0A
01EEA:  MOVLB  B
01EEC:  MOVWF  x22
01EEE:  MOVLB  0
01EF0:  CALL   11F6
....................    Flujo[2].zero_actual=make16(read_eeprom(36),read_eeprom(35)); 
01EF4:  MOVFF  FF2,B00
01EF8:  BCF    FF2.6
01EFA:  BCF    FF2.7
01EFC:  CLRF   FAA
01EFE:  MOVLW  24
01F00:  MOVWF  FA9
01F02:  BCF    FA6.6
01F04:  BCF    FA6.7
01F06:  BSF    FA6.0
01F08:  MOVF   FA8,W
01F0A:  MOVLB  B
01F0C:  BTFSC  x00.6
01F0E:  BSF    FF2.6
01F10:  BTFSC  x00.7
01F12:  BSF    FF2.7
01F14:  MOVWF  x01
01F16:  MOVFF  FF2,B02
01F1A:  BCF    FF2.6
01F1C:  BCF    FF2.7
01F1E:  CLRF   FAA
01F20:  MOVLW  23
01F22:  MOVWF  FA9
01F24:  BCF    FA6.6
01F26:  BCF    FA6.7
01F28:  BSF    FA6.0
01F2A:  MOVF   FA8,W
01F2C:  BTFSC  x02.6
01F2E:  BSF    FF2.6
01F30:  BTFSC  x02.7
01F32:  BSF    FF2.7
01F34:  MOVWF  x03
01F36:  MOVFF  B01,03
01F3A:  MOVF   x03,W
01F3C:  MOVWF  x1F
01F3E:  MOVFF  03,B20
01F42:  MOVLB  0
01F44:  CALL   136C
01F48:  MOVFF  03,598
01F4C:  MOVFF  02,597
01F50:  MOVFF  01,596
01F54:  MOVFF  00,595
....................    delay_ms(10); 
01F58:  MOVLW  0A
01F5A:  MOVLB  B
01F5C:  MOVWF  x22
01F5E:  MOVLB  0
01F60:  CALL   11F6
....................     
....................    minutos_trabajo=make16(read_eeprom(38),read_eeprom(37)); 
01F64:  MOVFF  FF2,B00
01F68:  BCF    FF2.6
01F6A:  BCF    FF2.7
01F6C:  CLRF   FAA
01F6E:  MOVLW  26
01F70:  MOVWF  FA9
01F72:  BCF    FA6.6
01F74:  BCF    FA6.7
01F76:  BSF    FA6.0
01F78:  MOVF   FA8,W
01F7A:  MOVLB  B
01F7C:  BTFSC  x00.6
01F7E:  BSF    FF2.6
01F80:  BTFSC  x00.7
01F82:  BSF    FF2.7
01F84:  MOVWF  x01
01F86:  MOVFF  FF2,B02
01F8A:  BCF    FF2.6
01F8C:  BCF    FF2.7
01F8E:  CLRF   FAA
01F90:  MOVLW  25
01F92:  MOVWF  FA9
01F94:  BCF    FA6.6
01F96:  BCF    FA6.7
01F98:  BSF    FA6.0
01F9A:  MOVF   FA8,W
01F9C:  BTFSC  x02.6
01F9E:  BSF    FF2.6
01FA0:  BTFSC  x02.7
01FA2:  BSF    FF2.7
01FA4:  MOVWF  x03
01FA6:  MOVFF  B01,C4
01FAA:  MOVFF  B03,C3
....................    delay_ms(10); 
01FAE:  MOVLW  0A
01FB0:  MOVWF  x22
01FB2:  MOVLB  0
01FB4:  CALL   11F6
....................    minutos_uv=read_eeprom(39); 
01FB8:  MOVFF  FF2,B00
01FBC:  BCF    FF2.6
01FBE:  BCF    FF2.7
01FC0:  CLRF   FAA
01FC2:  MOVLW  27
01FC4:  MOVWF  FA9
01FC6:  BCF    FA6.6
01FC8:  BCF    FA6.7
01FCA:  BSF    FA6.0
01FCC:  MOVF   FA8,W
01FCE:  MOVLB  B
01FD0:  BTFSC  x00.6
01FD2:  BSF    FF2.6
01FD4:  BTFSC  x00.7
01FD6:  BSF    FF2.7
01FD8:  MOVLB  0
01FDA:  CLRF   xC2
01FDC:  MOVWF  xC1
....................    delay_ms(10); 
01FDE:  MOVLW  0A
01FE0:  MOVLB  B
01FE2:  MOVWF  x22
01FE4:  MOVLB  0
01FE6:  CALL   11F6
....................    Vel1=read_eeprom(40); 
01FEA:  MOVFF  FF2,B00
01FEE:  BCF    FF2.6
01FF0:  BCF    FF2.7
01FF2:  CLRF   FAA
01FF4:  MOVLW  28
01FF6:  MOVWF  FA9
01FF8:  BCF    FA6.6
01FFA:  BCF    FA6.7
01FFC:  BSF    FA6.0
01FFE:  MOVF   FA8,W
02000:  MOVLB  B
02002:  BTFSC  x00.6
02004:  BSF    FF2.6
02006:  BTFSC  x00.7
02008:  BSF    FF2.7
0200A:  MOVLB  0
0200C:  MOVWF  x93
....................    delay_ms(10); 
0200E:  MOVLW  0A
02010:  MOVLB  B
02012:  MOVWF  x22
02014:  MOVLB  0
02016:  CALL   11F6
....................    Vel2=read_eeprom(41); 
0201A:  MOVFF  FF2,B00
0201E:  BCF    FF2.6
02020:  BCF    FF2.7
02022:  CLRF   FAA
02024:  MOVLW  29
02026:  MOVWF  FA9
02028:  BCF    FA6.6
0202A:  BCF    FA6.7
0202C:  BSF    FA6.0
0202E:  MOVF   FA8,W
02030:  MOVLB  B
02032:  BTFSC  x00.6
02034:  BSF    FF2.6
02036:  BTFSC  x00.7
02038:  BSF    FF2.7
0203A:  MOVLB  0
0203C:  MOVWF  x94
....................    delay_ms(10); 
0203E:  MOVLW  0A
02040:  MOVLB  B
02042:  MOVWF  x22
02044:  MOVLB  0
02046:  CALL   11F6
....................     
....................    Flujo[1].Diferencia=make16(read_eeprom(43),read_eeprom(42)); 
0204A:  MOVFF  FF2,B00
0204E:  BCF    FF2.6
02050:  BCF    FF2.7
02052:  CLRF   FAA
02054:  MOVLW  2B
02056:  MOVWF  FA9
02058:  BCF    FA6.6
0205A:  BCF    FA6.7
0205C:  BSF    FA6.0
0205E:  MOVF   FA8,W
02060:  MOVLB  B
02062:  BTFSC  x00.6
02064:  BSF    FF2.6
02066:  BTFSC  x00.7
02068:  BSF    FF2.7
0206A:  MOVWF  x01
0206C:  MOVFF  FF2,B02
02070:  BCF    FF2.6
02072:  BCF    FF2.7
02074:  CLRF   FAA
02076:  MOVLW  2A
02078:  MOVWF  FA9
0207A:  BCF    FA6.6
0207C:  BCF    FA6.7
0207E:  BSF    FA6.0
02080:  MOVF   FA8,W
02082:  BTFSC  x02.6
02084:  BSF    FF2.6
02086:  BTFSC  x02.7
02088:  BSF    FF2.7
0208A:  MOVWF  x03
0208C:  MOVFF  B01,03
02090:  MOVF   x03,W
02092:  MOVWF  x1F
02094:  MOVFF  03,B20
02098:  MOVLB  0
0209A:  CALL   136C
0209E:  MOVFF  03,443
020A2:  MOVFF  02,442
020A6:  MOVFF  01,441
020AA:  MOVFF  00,440
....................    delay_ms(10); 
020AE:  MOVLW  0A
020B0:  MOVLB  B
020B2:  MOVWF  x22
020B4:  MOVLB  0
020B6:  CALL   11F6
....................    Flujo[2].Diferencia=make16(read_eeprom(45),read_eeprom(44)); 
020BA:  MOVFF  FF2,B00
020BE:  BCF    FF2.6
020C0:  BCF    FF2.7
020C2:  CLRF   FAA
020C4:  MOVLW  2D
020C6:  MOVWF  FA9
020C8:  BCF    FA6.6
020CA:  BCF    FA6.7
020CC:  BSF    FA6.0
020CE:  MOVF   FA8,W
020D0:  MOVLB  B
020D2:  BTFSC  x00.6
020D4:  BSF    FF2.6
020D6:  BTFSC  x00.7
020D8:  BSF    FF2.7
020DA:  MOVWF  x01
020DC:  MOVFF  FF2,B02
020E0:  BCF    FF2.6
020E2:  BCF    FF2.7
020E4:  CLRF   FAA
020E6:  MOVLW  2C
020E8:  MOVWF  FA9
020EA:  BCF    FA6.6
020EC:  BCF    FA6.7
020EE:  BSF    FA6.0
020F0:  MOVF   FA8,W
020F2:  BTFSC  x02.6
020F4:  BSF    FF2.6
020F6:  BTFSC  x02.7
020F8:  BSF    FF2.7
020FA:  MOVWF  x03
020FC:  MOVFF  B01,03
02100:  MOVF   x03,W
02102:  MOVWF  x1F
02104:  MOVFF  03,B20
02108:  MOVLB  0
0210A:  CALL   136C
0210E:  MOVFF  03,59C
02112:  MOVFF  02,59B
02116:  MOVFF  01,59A
0211A:  MOVFF  00,599
....................    delay_ms(10); 
0211E:  MOVLW  0A
02120:  MOVLB  B
02122:  MOVWF  x22
02124:  MOVLB  0
02126:  CALL   11F6
....................    Presion[4].G=make16(read_eeprom(47),read_eeprom(46)); 
0212A:  MOVFF  FF2,B00
0212E:  BCF    FF2.6
02130:  BCF    FF2.7
02132:  CLRF   FAA
02134:  MOVLW  2F
02136:  MOVWF  FA9
02138:  BCF    FA6.6
0213A:  BCF    FA6.7
0213C:  BSF    FA6.0
0213E:  MOVF   FA8,W
02140:  MOVLB  B
02142:  BTFSC  x00.6
02144:  BSF    FF2.6
02146:  BTFSC  x00.7
02148:  BSF    FF2.7
0214A:  MOVWF  x01
0214C:  MOVFF  FF2,B02
02150:  BCF    FF2.6
02152:  BCF    FF2.7
02154:  CLRF   FAA
02156:  MOVLW  2E
02158:  MOVWF  FA9
0215A:  BCF    FA6.6
0215C:  BCF    FA6.7
0215E:  BSF    FA6.0
02160:  MOVF   FA8,W
02162:  BTFSC  x02.6
02164:  BSF    FF2.6
02166:  BTFSC  x02.7
02168:  BSF    FF2.7
0216A:  MOVWF  x03
0216C:  MOVFF  B01,03
02170:  MOVF   x03,W
02172:  MOVWF  x1F
02174:  MOVFF  03,B20
02178:  MOVLB  0
0217A:  CALL   136C
0217E:  MOVFF  03,AB9
02182:  MOVFF  02,AB8
02186:  MOVFF  01,AB7
0218A:  MOVFF  00,AB6
....................    //Gdn=make16(read_eeprom(47),read_eeprom(46)); 
....................    delay_ms(10); 
0218E:  MOVLW  0A
02190:  MOVLB  B
02192:  MOVWF  x22
02194:  MOVLB  0
02196:  CALL   11F6
....................    Presion[3].G=make16(read_eeprom(49),read_eeprom(48)); 
0219A:  MOVFF  FF2,B00
0219E:  BCF    FF2.6
021A0:  BCF    FF2.7
021A2:  CLRF   FAA
021A4:  MOVLW  31
021A6:  MOVWF  FA9
021A8:  BCF    FA6.6
021AA:  BCF    FA6.7
021AC:  BSF    FA6.0
021AE:  MOVF   FA8,W
021B0:  MOVLB  B
021B2:  BTFSC  x00.6
021B4:  BSF    FF2.6
021B6:  BTFSC  x00.7
021B8:  BSF    FF2.7
021BA:  MOVWF  x01
021BC:  MOVFF  FF2,B02
021C0:  BCF    FF2.6
021C2:  BCF    FF2.7
021C4:  CLRF   FAA
021C6:  MOVLW  30
021C8:  MOVWF  FA9
021CA:  BCF    FA6.6
021CC:  BCF    FA6.7
021CE:  BSF    FA6.0
021D0:  MOVF   FA8,W
021D2:  BTFSC  x02.6
021D4:  BSF    FF2.6
021D6:  BTFSC  x02.7
021D8:  BSF    FF2.7
021DA:  MOVWF  x03
021DC:  MOVFF  B01,03
021E0:  MOVF   x03,W
021E2:  MOVWF  x1F
021E4:  MOVFF  03,B20
021E8:  MOVLB  0
021EA:  CALL   136C
021EE:  MOVFF  03,A75
021F2:  MOVFF  02,A74
021F6:  MOVFF  01,A73
021FA:  MOVFF  00,A72
....................    delay_ms(10); 
021FE:  MOVLW  0A
02200:  MOVLB  B
02202:  MOVWF  x22
02204:  MOVLB  0
02206:  CALL   11F6
....................    Flujo[1].negativo=read_eeprom(50); 
0220A:  MOVFF  FF2,B00
0220E:  BCF    FF2.6
02210:  BCF    FF2.7
02212:  CLRF   FAA
02214:  MOVLW  32
02216:  MOVWF  FA9
02218:  BCF    FA6.6
0221A:  BCF    FA6.7
0221C:  BSF    FA6.0
0221E:  MOVF   FA8,W
02220:  MOVLB  B
02222:  BTFSC  x00.6
02224:  BSF    FF2.6
02226:  BTFSC  x00.7
02228:  BSF    FF2.7
0222A:  MOVLB  4
0222C:  MOVWF  x46
....................    delay_ms(10); 
0222E:  MOVLW  0A
02230:  MOVLB  B
02232:  MOVWF  x22
02234:  MOVLB  0
02236:  CALL   11F6
....................    Flujo[2].negativo=read_eeprom(51); 
0223A:  MOVFF  FF2,B00
0223E:  BCF    FF2.6
02240:  BCF    FF2.7
02242:  CLRF   FAA
02244:  MOVLW  33
02246:  MOVWF  FA9
02248:  BCF    FA6.6
0224A:  BCF    FA6.7
0224C:  BSF    FA6.0
0224E:  MOVF   FA8,W
02250:  MOVLB  B
02252:  BTFSC  x00.6
02254:  BSF    FF2.6
02256:  BTFSC  x00.7
02258:  BSF    FF2.7
0225A:  MOVLB  5
0225C:  MOVWF  x9F
....................    delay_ms(10); 
0225E:  MOVLW  0A
02260:  MOVLB  B
02262:  MOVWF  x22
02264:  MOVLB  0
02266:  CALL   11F6
....................  
....................    Entero=read_eeprom(52); 
0226A:  MOVFF  FF2,B00
0226E:  BCF    FF2.6
02270:  BCF    FF2.7
02272:  CLRF   FAA
02274:  MOVLW  34
02276:  MOVWF  FA9
02278:  BCF    FA6.6
0227A:  BCF    FA6.7
0227C:  BSF    FA6.0
0227E:  MOVF   FA8,W
02280:  MOVLB  B
02282:  BTFSC  x00.6
02284:  BSF    FF2.6
02286:  BTFSC  x00.7
02288:  BSF    FF2.7
0228A:  MOVLB  0
0228C:  MOVWF  x8E
....................    delay_ms(10); 
0228E:  MOVLW  0A
02290:  MOVLB  B
02292:  MOVWF  x22
02294:  MOVLB  0
02296:  CALL   11F6
....................    Temporal=read_eeprom(53); 
0229A:  MOVFF  FF2,B00
0229E:  BCF    FF2.6
022A0:  BCF    FF2.7
022A2:  CLRF   FAA
022A4:  MOVLW  35
022A6:  MOVWF  FA9
022A8:  BCF    FA6.6
022AA:  BCF    FA6.7
022AC:  BSF    FA6.0
022AE:  MOVF   FA8,W
022B0:  MOVLB  B
022B2:  BTFSC  x00.6
022B4:  BSF    FF2.6
022B6:  BTFSC  x00.7
022B8:  BSF    FF2.7
022BA:  CLRF   x20
022BC:  MOVWF  x1F
022BE:  MOVLB  0
022C0:  CALL   136C
022C4:  MOVFF  03,100
022C8:  MOVFF  02,FF
022CC:  MOVFF  01,FE
022D0:  MOVFF  00,FD
....................    delay_ms(10); 
022D4:  MOVLW  0A
022D6:  MOVLB  B
022D8:  MOVWF  x22
022DA:  MOVLB  0
022DC:  CALL   11F6
....................    Temporal=Temporal/100.0; 
022E0:  MOVFF  100,B22
022E4:  MOVFF  FF,B21
022E8:  MOVFF  FE,B20
022EC:  MOVFF  FD,B1F
022F0:  MOVLB  B
022F2:  CLRF   x26
022F4:  CLRF   x25
022F6:  MOVLW  48
022F8:  MOVWF  x24
022FA:  MOVLW  85
022FC:  MOVWF  x23
022FE:  MOVLB  0
02300:  CALL   13A2
02304:  MOVFF  03,100
02308:  MOVFF  02,FF
0230C:  MOVFF  01,FE
02310:  MOVFF  00,FD
....................    Relacion=Entero+Temporal; 
02314:  MOVLB  B
02316:  CLRF   x20
02318:  MOVFF  8E,B1F
0231C:  MOVLB  0
0231E:  CALL   136C
02322:  BCF    FD8.1
02324:  MOVFF  03,B26
02328:  MOVFF  02,B25
0232C:  MOVFF  01,B24
02330:  MOVFF  00,B23
02334:  MOVFF  100,B2A
02338:  MOVFF  FF,B29
0233C:  MOVFF  FE,B28
02340:  MOVFF  FD,B27
02344:  CALL   1500
02348:  MOVFF  03,2C4
0234C:  MOVFF  02,2C3
02350:  MOVFF  01,2C2
02354:  MOVFF  00,2C1
....................    codigoSubir=read_eeprom(54); 
02358:  MOVFF  FF2,B00
0235C:  BCF    FF2.6
0235E:  BCF    FF2.7
02360:  CLRF   FAA
02362:  MOVLW  36
02364:  MOVWF  FA9
02366:  BCF    FA6.6
02368:  BCF    FA6.7
0236A:  BSF    FA6.0
0236C:  MOVF   FA8,W
0236E:  MOVLB  B
02370:  BTFSC  x00.6
02372:  BSF    FF2.6
02374:  BTFSC  x00.7
02376:  BSF    FF2.7
02378:  MOVLB  0
0237A:  MOVWF  x87
....................    delay_ms(10); 
0237C:  MOVLW  0A
0237E:  MOVLB  B
02380:  MOVWF  x22
02382:  MOVLB  0
02384:  CALL   11F6
....................    codigoBajar=read_eeprom(55); 
02388:  MOVFF  FF2,B00
0238C:  BCF    FF2.6
0238E:  BCF    FF2.7
02390:  CLRF   FAA
02392:  MOVLW  37
02394:  MOVWF  FA9
02396:  BCF    FA6.6
02398:  BCF    FA6.7
0239A:  BSF    FA6.0
0239C:  MOVF   FA8,W
0239E:  MOVLB  B
023A0:  BTFSC  x00.6
023A2:  BSF    FF2.6
023A4:  BTFSC  x00.7
023A6:  BSF    FF2.7
023A8:  MOVLB  0
023AA:  MOVWF  x88
....................    delay_ms(10); 
023AC:  MOVLW  0A
023AE:  MOVLB  B
023B0:  MOVWF  x22
023B2:  MOVLB  0
023B4:  CALL   11F6
....................    codigoDetener=read_eeprom(56); 
023B8:  MOVFF  FF2,B00
023BC:  BCF    FF2.6
023BE:  BCF    FF2.7
023C0:  CLRF   FAA
023C2:  MOVLW  38
023C4:  MOVWF  FA9
023C6:  BCF    FA6.6
023C8:  BCF    FA6.7
023CA:  BSF    FA6.0
023CC:  MOVF   FA8,W
023CE:  MOVLB  B
023D0:  BTFSC  x00.6
023D2:  BSF    FF2.6
023D4:  BTFSC  x00.7
023D6:  BSF    FF2.7
023D8:  MOVLB  0
023DA:  MOVWF  x89
....................    delay_ms(10); 
023DC:  MOVLW  0A
023DE:  MOVLB  B
023E0:  MOVWF  x22
023E2:  MOVLB  0
023E4:  CALL   11F6
....................    mediaMovil=read_eeprom(57); 
023E8:  MOVFF  FF2,B00
023EC:  BCF    FF2.6
023EE:  BCF    FF2.7
023F0:  CLRF   FAA
023F2:  MOVLW  39
023F4:  MOVWF  FA9
023F6:  BCF    FA6.6
023F8:  BCF    FA6.7
023FA:  BSF    FA6.0
023FC:  MOVF   FA8,W
023FE:  MOVLB  B
02400:  BTFSC  x00.6
02402:  BSF    FF2.6
02404:  BTFSC  x00.7
02406:  BSF    FF2.7
02408:  MOVLB  0
0240A:  MOVWF  x95
....................    delay_ms(10); 
0240C:  MOVLW  0A
0240E:  MOVLB  B
02410:  MOVWF  x22
02412:  MOVLB  0
02414:  CALL   11F6
.................... } 
02418:  GOTO   64FC (RETURN)
....................  
.................... void LimitaValores(void){ 
....................    if(Password[0]>9 || Password[0]<0){ 
*
02496:  BTFSC  xD1.7
02498:  BRA    24A0
0249A:  MOVF   xD1,W
0249C:  SUBLW  09
0249E:  BNC   24A6
024A0:  BTFSC  xD1.7
024A2:  BRA    24A6
024A4:  BRA    24DE
....................       Password[0]=0;write_eeprom(0,0);delay_ms(10); 
024A6:  CLRF   xD1
024A8:  CLRF   FAA
024AA:  CLRF   FA9
024AC:  CLRF   FA8
024AE:  BCF    FA6.6
024B0:  BCF    FA6.7
024B2:  BSF    FA6.2
024B4:  MOVF   FF2,W
024B6:  MOVWF  00
024B8:  BCF    FF2.6
024BA:  BCF    FF2.7
024BC:  MOVLB  F
024BE:  MOVLW  55
024C0:  MOVWF  FA7
024C2:  MOVLW  AA
024C4:  MOVWF  FA7
024C6:  BSF    FA6.1
024C8:  BTFSC  FA6.1
024CA:  BRA    24C8
024CC:  BCF    FA6.2
024CE:  MOVF   00,W
024D0:  IORWF  FF2,F
024D2:  MOVLW  0A
024D4:  MOVLB  B
024D6:  MOVWF  x22
024D8:  MOVLB  0
024DA:  CALL   11F6
....................    } 
....................    if(Password[1]>9 || Password[1]<0){ 
024DE:  BTFSC  xD2.7
024E0:  BRA    24E8
024E2:  MOVF   xD2,W
024E4:  SUBLW  09
024E6:  BNC   24EE
024E8:  BTFSC  xD2.7
024EA:  BRA    24EE
024EC:  BRA    2528
....................       Password[1]=0;write_eeprom(1,0);delay_ms(10); 
024EE:  CLRF   xD2
024F0:  CLRF   FAA
024F2:  MOVLW  01
024F4:  MOVWF  FA9
024F6:  CLRF   FA8
024F8:  BCF    FA6.6
024FA:  BCF    FA6.7
024FC:  BSF    FA6.2
024FE:  MOVF   FF2,W
02500:  MOVWF  00
02502:  BCF    FF2.6
02504:  BCF    FF2.7
02506:  MOVLB  F
02508:  MOVLW  55
0250A:  MOVWF  FA7
0250C:  MOVLW  AA
0250E:  MOVWF  FA7
02510:  BSF    FA6.1
02512:  BTFSC  FA6.1
02514:  BRA    2512
02516:  BCF    FA6.2
02518:  MOVF   00,W
0251A:  IORWF  FF2,F
0251C:  MOVLW  0A
0251E:  MOVLB  B
02520:  MOVWF  x22
02522:  MOVLB  0
02524:  CALL   11F6
....................    } 
....................    if(Password[2]>9 || Password[2]<0){ 
02528:  BTFSC  xD3.7
0252A:  BRA    2532
0252C:  MOVF   xD3,W
0252E:  SUBLW  09
02530:  BNC   2538
02532:  BTFSC  xD3.7
02534:  BRA    2538
02536:  BRA    2572
....................       Password[2]=0;write_eeprom(2,0);delay_ms(10); 
02538:  CLRF   xD3
0253A:  CLRF   FAA
0253C:  MOVLW  02
0253E:  MOVWF  FA9
02540:  CLRF   FA8
02542:  BCF    FA6.6
02544:  BCF    FA6.7
02546:  BSF    FA6.2
02548:  MOVF   FF2,W
0254A:  MOVWF  00
0254C:  BCF    FF2.6
0254E:  BCF    FF2.7
02550:  MOVLB  F
02552:  MOVLW  55
02554:  MOVWF  FA7
02556:  MOVLW  AA
02558:  MOVWF  FA7
0255A:  BSF    FA6.1
0255C:  BTFSC  FA6.1
0255E:  BRA    255C
02560:  BCF    FA6.2
02562:  MOVF   00,W
02564:  IORWF  FF2,F
02566:  MOVLW  0A
02568:  MOVLB  B
0256A:  MOVWF  x22
0256C:  MOVLB  0
0256E:  CALL   11F6
....................    } 
....................    if(Password[3]>9 || Password[3]<0){ 
02572:  BTFSC  xD4.7
02574:  BRA    257C
02576:  MOVF   xD4,W
02578:  SUBLW  09
0257A:  BNC   2582
0257C:  BTFSC  xD4.7
0257E:  BRA    2582
02580:  BRA    25BC
....................       Password[3]=0;write_eeprom(3,0);delay_ms(10); 
02582:  CLRF   xD4
02584:  CLRF   FAA
02586:  MOVLW  03
02588:  MOVWF  FA9
0258A:  CLRF   FA8
0258C:  BCF    FA6.6
0258E:  BCF    FA6.7
02590:  BSF    FA6.2
02592:  MOVF   FF2,W
02594:  MOVWF  00
02596:  BCF    FF2.6
02598:  BCF    FF2.7
0259A:  MOVLB  F
0259C:  MOVLW  55
0259E:  MOVWF  FA7
025A0:  MOVLW  AA
025A2:  MOVWF  FA7
025A4:  BSF    FA6.1
025A6:  BTFSC  FA6.1
025A8:  BRA    25A6
025AA:  BCF    FA6.2
025AC:  MOVF   00,W
025AE:  IORWF  FF2,F
025B0:  MOVLW  0A
025B2:  MOVLB  B
025B4:  MOVWF  x22
025B6:  MOVLB  0
025B8:  CALL   11F6
....................    } 
....................    if(mPurgap>99){ 
025BC:  MOVF   xAF,W
025BE:  SUBLW  63
025C0:  BC    2600
....................       mPurgaP=1;write_eeprom(4,1);delay_ms(10); 
025C2:  MOVLW  01
025C4:  MOVWF  xAF
025C6:  CLRF   FAA
025C8:  MOVLW  04
025CA:  MOVWF  FA9
025CC:  MOVLW  01
025CE:  MOVWF  FA8
025D0:  BCF    FA6.6
025D2:  BCF    FA6.7
025D4:  BSF    FA6.2
025D6:  MOVF   FF2,W
025D8:  MOVWF  00
025DA:  BCF    FF2.6
025DC:  BCF    FF2.7
025DE:  MOVLB  F
025E0:  MOVLW  55
025E2:  MOVWF  FA7
025E4:  MOVLW  AA
025E6:  MOVWF  FA7
025E8:  BSF    FA6.1
025EA:  BTFSC  FA6.1
025EC:  BRA    25EA
025EE:  BCF    FA6.2
025F0:  MOVF   00,W
025F2:  IORWF  FF2,F
025F4:  MOVLW  0A
025F6:  MOVLB  B
025F8:  MOVWF  x22
025FA:  MOVLB  0
025FC:  CALL   11F6
....................    } 
....................    if(sPurgap>59){ 
02600:  MOVF   xAD,W
02602:  SUBLW  3B
02604:  BC    2640
....................       sPurgaP=0;write_eeprom(5,0);delay_ms(10); 
02606:  CLRF   xAD
02608:  CLRF   FAA
0260A:  MOVLW  05
0260C:  MOVWF  FA9
0260E:  CLRF   FA8
02610:  BCF    FA6.6
02612:  BCF    FA6.7
02614:  BSF    FA6.2
02616:  MOVF   FF2,W
02618:  MOVWF  00
0261A:  BCF    FF2.6
0261C:  BCF    FF2.7
0261E:  MOVLB  F
02620:  MOVLW  55
02622:  MOVWF  FA7
02624:  MOVLW  AA
02626:  MOVWF  FA7
02628:  BSF    FA6.1
0262A:  BTFSC  FA6.1
0262C:  BRA    262A
0262E:  BCF    FA6.2
02630:  MOVF   00,W
02632:  IORWF  FF2,F
02634:  MOVLW  0A
02636:  MOVLB  B
02638:  MOVWF  x22
0263A:  MOVLB  0
0263C:  CALL   11F6
....................    } 
....................    if(mPPurgap>99){ 
02640:  MOVF   xB3,W
02642:  SUBLW  63
02644:  BC    2684
....................       mPPurgaP=1;write_eeprom(6,1);delay_ms(10); 
02646:  MOVLW  01
02648:  MOVWF  xB3
0264A:  CLRF   FAA
0264C:  MOVLW  06
0264E:  MOVWF  FA9
02650:  MOVLW  01
02652:  MOVWF  FA8
02654:  BCF    FA6.6
02656:  BCF    FA6.7
02658:  BSF    FA6.2
0265A:  MOVF   FF2,W
0265C:  MOVWF  00
0265E:  BCF    FF2.6
02660:  BCF    FF2.7
02662:  MOVLB  F
02664:  MOVLW  55
02666:  MOVWF  FA7
02668:  MOVLW  AA
0266A:  MOVWF  FA7
0266C:  BSF    FA6.1
0266E:  BTFSC  FA6.1
02670:  BRA    266E
02672:  BCF    FA6.2
02674:  MOVF   00,W
02676:  IORWF  FF2,F
02678:  MOVLW  0A
0267A:  MOVLB  B
0267C:  MOVWF  x22
0267E:  MOVLB  0
02680:  CALL   11F6
....................    } 
....................    if(sPPurgap>59){ 
02684:  MOVF   xB1,W
02686:  SUBLW  3B
02688:  BC    26C4
....................       sPPurgaP=0;write_eeprom(7,0);delay_ms(10); 
0268A:  CLRF   xB1
0268C:  CLRF   FAA
0268E:  MOVLW  07
02690:  MOVWF  FA9
02692:  CLRF   FA8
02694:  BCF    FA6.6
02696:  BCF    FA6.7
02698:  BSF    FA6.2
0269A:  MOVF   FF2,W
0269C:  MOVWF  00
0269E:  BCF    FF2.6
026A0:  BCF    FF2.7
026A2:  MOVLB  F
026A4:  MOVLW  55
026A6:  MOVWF  FA7
026A8:  MOVLW  AA
026AA:  MOVWF  FA7
026AC:  BSF    FA6.1
026AE:  BTFSC  FA6.1
026B0:  BRA    26AE
026B2:  BCF    FA6.2
026B4:  MOVF   00,W
026B6:  IORWF  FF2,F
026B8:  MOVLW  0A
026BA:  MOVLB  B
026BC:  MOVWF  x22
026BE:  MOVLB  0
026C0:  CALL   11F6
....................    } 
....................    if(mUVp>99){ 
026C4:  MOVF   xB7,W
026C6:  SUBLW  63
026C8:  BC    2708
....................       mUVP=1;write_eeprom(8,1);delay_ms(10); 
026CA:  MOVLW  01
026CC:  MOVWF  xB7
026CE:  CLRF   FAA
026D0:  MOVLW  08
026D2:  MOVWF  FA9
026D4:  MOVLW  01
026D6:  MOVWF  FA8
026D8:  BCF    FA6.6
026DA:  BCF    FA6.7
026DC:  BSF    FA6.2
026DE:  MOVF   FF2,W
026E0:  MOVWF  00
026E2:  BCF    FF2.6
026E4:  BCF    FF2.7
026E6:  MOVLB  F
026E8:  MOVLW  55
026EA:  MOVWF  FA7
026EC:  MOVLW  AA
026EE:  MOVWF  FA7
026F0:  BSF    FA6.1
026F2:  BTFSC  FA6.1
026F4:  BRA    26F2
026F6:  BCF    FA6.2
026F8:  MOVF   00,W
026FA:  IORWF  FF2,F
026FC:  MOVLW  0A
026FE:  MOVLB  B
02700:  MOVWF  x22
02702:  MOVLB  0
02704:  CALL   11F6
....................    } 
....................    if(sUVp>59){ 
02708:  MOVF   xB6,W
0270A:  SUBLW  3B
0270C:  BC    2748
....................       sUVP=0;write_eeprom(9,0);delay_ms(10); 
0270E:  CLRF   xB6
02710:  CLRF   FAA
02712:  MOVLW  09
02714:  MOVWF  FA9
02716:  CLRF   FA8
02718:  BCF    FA6.6
0271A:  BCF    FA6.7
0271C:  BSF    FA6.2
0271E:  MOVF   FF2,W
02720:  MOVWF  00
02722:  BCF    FF2.6
02724:  BCF    FF2.7
02726:  MOVLB  F
02728:  MOVLW  55
0272A:  MOVWF  FA7
0272C:  MOVLW  AA
0272E:  MOVWF  FA7
02730:  BSF    FA6.1
02732:  BTFSC  FA6.1
02734:  BRA    2732
02736:  BCF    FA6.2
02738:  MOVF   00,W
0273A:  IORWF  FF2,F
0273C:  MOVLW  0A
0273E:  MOVLB  B
02740:  MOVWF  x22
02742:  MOVLB  0
02744:  CALL   11F6
....................    } 
....................    if(Tuv[0]>9 || Tuv[0]<0){ 
02748:  BTFSC  xC9.7
0274A:  BRA    2752
0274C:  MOVF   xC9,W
0274E:  SUBLW  09
02750:  BNC   2758
02752:  BTFSC  xC9.7
02754:  BRA    2758
02756:  BRA    2792
....................       Tuv[0]=0;write_eeprom(12,0);delay_ms(10); 
02758:  CLRF   xC9
0275A:  CLRF   FAA
0275C:  MOVLW  0C
0275E:  MOVWF  FA9
02760:  CLRF   FA8
02762:  BCF    FA6.6
02764:  BCF    FA6.7
02766:  BSF    FA6.2
02768:  MOVF   FF2,W
0276A:  MOVWF  00
0276C:  BCF    FF2.6
0276E:  BCF    FF2.7
02770:  MOVLB  F
02772:  MOVLW  55
02774:  MOVWF  FA7
02776:  MOVLW  AA
02778:  MOVWF  FA7
0277A:  BSF    FA6.1
0277C:  BTFSC  FA6.1
0277E:  BRA    277C
02780:  BCF    FA6.2
02782:  MOVF   00,W
02784:  IORWF  FF2,F
02786:  MOVLW  0A
02788:  MOVLB  B
0278A:  MOVWF  x22
0278C:  MOVLB  0
0278E:  CALL   11F6
....................    } 
....................    if(Tuv[1]>9 || Tuv[1]<0){ 
02792:  BTFSC  xCA.7
02794:  BRA    279C
02796:  MOVF   xCA,W
02798:  SUBLW  09
0279A:  BNC   27A2
0279C:  BTFSC  xCA.7
0279E:  BRA    27A2
027A0:  BRA    27DC
....................       Tuv[1]=0;write_eeprom(13,0);delay_ms(10); 
027A2:  CLRF   xCA
027A4:  CLRF   FAA
027A6:  MOVLW  0D
027A8:  MOVWF  FA9
027AA:  CLRF   FA8
027AC:  BCF    FA6.6
027AE:  BCF    FA6.7
027B0:  BSF    FA6.2
027B2:  MOVF   FF2,W
027B4:  MOVWF  00
027B6:  BCF    FF2.6
027B8:  BCF    FF2.7
027BA:  MOVLB  F
027BC:  MOVLW  55
027BE:  MOVWF  FA7
027C0:  MOVLW  AA
027C2:  MOVWF  FA7
027C4:  BSF    FA6.1
027C6:  BTFSC  FA6.1
027C8:  BRA    27C6
027CA:  BCF    FA6.2
027CC:  MOVF   00,W
027CE:  IORWF  FF2,F
027D0:  MOVLW  0A
027D2:  MOVLB  B
027D4:  MOVWF  x22
027D6:  MOVLB  0
027D8:  CALL   11F6
....................    } 
....................    if(Tuv[2]>9 || Tuv[2]<0){ 
027DC:  BTFSC  xCB.7
027DE:  BRA    27E6
027E0:  MOVF   xCB,W
027E2:  SUBLW  09
027E4:  BNC   27EC
027E6:  BTFSC  xCB.7
027E8:  BRA    27EC
027EA:  BRA    2826
....................       Tuv[2]=0;write_eeprom(14,0);delay_ms(10); 
027EC:  CLRF   xCB
027EE:  CLRF   FAA
027F0:  MOVLW  0E
027F2:  MOVWF  FA9
027F4:  CLRF   FA8
027F6:  BCF    FA6.6
027F8:  BCF    FA6.7
027FA:  BSF    FA6.2
027FC:  MOVF   FF2,W
027FE:  MOVWF  00
02800:  BCF    FF2.6
02802:  BCF    FF2.7
02804:  MOVLB  F
02806:  MOVLW  55
02808:  MOVWF  FA7
0280A:  MOVLW  AA
0280C:  MOVWF  FA7
0280E:  BSF    FA6.1
02810:  BTFSC  FA6.1
02812:  BRA    2810
02814:  BCF    FA6.2
02816:  MOVF   00,W
02818:  IORWF  FF2,F
0281A:  MOVLW  0A
0281C:  MOVLB  B
0281E:  MOVWF  x22
02820:  MOVLB  0
02822:  CALL   11F6
....................    } 
....................    if(Tuv[3]>9 || Tuv[3]<0){ 
02826:  BTFSC  xCC.7
02828:  BRA    2830
0282A:  MOVF   xCC,W
0282C:  SUBLW  09
0282E:  BNC   2836
02830:  BTFSC  xCC.7
02832:  BRA    2836
02834:  BRA    2870
....................       Tuv[3]=0;write_eeprom(15,0);delay_ms(10); 
02836:  CLRF   xCC
02838:  CLRF   FAA
0283A:  MOVLW  0F
0283C:  MOVWF  FA9
0283E:  CLRF   FA8
02840:  BCF    FA6.6
02842:  BCF    FA6.7
02844:  BSF    FA6.2
02846:  MOVF   FF2,W
02848:  MOVWF  00
0284A:  BCF    FF2.6
0284C:  BCF    FF2.7
0284E:  MOVLB  F
02850:  MOVLW  55
02852:  MOVWF  FA7
02854:  MOVLW  AA
02856:  MOVWF  FA7
02858:  BSF    FA6.1
0285A:  BTFSC  FA6.1
0285C:  BRA    285A
0285E:  BCF    FA6.2
02860:  MOVF   00,W
02862:  IORWF  FF2,F
02864:  MOVLW  0A
02866:  MOVLB  B
02868:  MOVWF  x22
0286A:  MOVLB  0
0286C:  CALL   11F6
....................    } 
....................    if(Ttrabajo[0]>9 || Ttrabajo[0]<0){ 
02870:  BTFSC  xCD.7
02872:  BRA    287A
02874:  MOVF   xCD,W
02876:  SUBLW  09
02878:  BNC   2880
0287A:  BTFSC  xCD.7
0287C:  BRA    2880
0287E:  BRA    28BA
....................       Ttrabajo[0]=0;write_eeprom(16,0);delay_ms(10); 
02880:  CLRF   xCD
02882:  CLRF   FAA
02884:  MOVLW  10
02886:  MOVWF  FA9
02888:  CLRF   FA8
0288A:  BCF    FA6.6
0288C:  BCF    FA6.7
0288E:  BSF    FA6.2
02890:  MOVF   FF2,W
02892:  MOVWF  00
02894:  BCF    FF2.6
02896:  BCF    FF2.7
02898:  MOVLB  F
0289A:  MOVLW  55
0289C:  MOVWF  FA7
0289E:  MOVLW  AA
028A0:  MOVWF  FA7
028A2:  BSF    FA6.1
028A4:  BTFSC  FA6.1
028A6:  BRA    28A4
028A8:  BCF    FA6.2
028AA:  MOVF   00,W
028AC:  IORWF  FF2,F
028AE:  MOVLW  0A
028B0:  MOVLB  B
028B2:  MOVWF  x22
028B4:  MOVLB  0
028B6:  CALL   11F6
....................    } 
....................    if(Ttrabajo[1]>9 || Ttrabajo[1]<0){ 
028BA:  BTFSC  xCE.7
028BC:  BRA    28C4
028BE:  MOVF   xCE,W
028C0:  SUBLW  09
028C2:  BNC   28CA
028C4:  BTFSC  xCE.7
028C6:  BRA    28CA
028C8:  BRA    2904
....................       Ttrabajo[1]=0;write_eeprom(17,0);delay_ms(10); 
028CA:  CLRF   xCE
028CC:  CLRF   FAA
028CE:  MOVLW  11
028D0:  MOVWF  FA9
028D2:  CLRF   FA8
028D4:  BCF    FA6.6
028D6:  BCF    FA6.7
028D8:  BSF    FA6.2
028DA:  MOVF   FF2,W
028DC:  MOVWF  00
028DE:  BCF    FF2.6
028E0:  BCF    FF2.7
028E2:  MOVLB  F
028E4:  MOVLW  55
028E6:  MOVWF  FA7
028E8:  MOVLW  AA
028EA:  MOVWF  FA7
028EC:  BSF    FA6.1
028EE:  BTFSC  FA6.1
028F0:  BRA    28EE
028F2:  BCF    FA6.2
028F4:  MOVF   00,W
028F6:  IORWF  FF2,F
028F8:  MOVLW  0A
028FA:  MOVLB  B
028FC:  MOVWF  x22
028FE:  MOVLB  0
02900:  CALL   11F6
....................    } 
....................    if(Ttrabajo[2]>9 || Ttrabajo[2]<0){ 
02904:  BTFSC  xCF.7
02906:  BRA    290E
02908:  MOVF   xCF,W
0290A:  SUBLW  09
0290C:  BNC   2914
0290E:  BTFSC  xCF.7
02910:  BRA    2914
02912:  BRA    294E
....................       Ttrabajo[2]=0;write_eeprom(18,0);delay_ms(10); 
02914:  CLRF   xCF
02916:  CLRF   FAA
02918:  MOVLW  12
0291A:  MOVWF  FA9
0291C:  CLRF   FA8
0291E:  BCF    FA6.6
02920:  BCF    FA6.7
02922:  BSF    FA6.2
02924:  MOVF   FF2,W
02926:  MOVWF  00
02928:  BCF    FF2.6
0292A:  BCF    FF2.7
0292C:  MOVLB  F
0292E:  MOVLW  55
02930:  MOVWF  FA7
02932:  MOVLW  AA
02934:  MOVWF  FA7
02936:  BSF    FA6.1
02938:  BTFSC  FA6.1
0293A:  BRA    2938
0293C:  BCF    FA6.2
0293E:  MOVF   00,W
02940:  IORWF  FF2,F
02942:  MOVLW  0A
02944:  MOVLB  B
02946:  MOVWF  x22
02948:  MOVLB  0
0294A:  CALL   11F6
....................    } 
....................    if(Ttrabajo[3]>9 || Ttrabajo[3]<0){ 
0294E:  BTFSC  xD0.7
02950:  BRA    2958
02952:  MOVF   xD0,W
02954:  SUBLW  09
02956:  BNC   295E
02958:  BTFSC  xD0.7
0295A:  BRA    295E
0295C:  BRA    2998
....................       Ttrabajo[3]=0;write_eeprom(19,0);delay_ms(10); 
0295E:  CLRF   xD0
02960:  CLRF   FAA
02962:  MOVLW  13
02964:  MOVWF  FA9
02966:  CLRF   FA8
02968:  BCF    FA6.6
0296A:  BCF    FA6.7
0296C:  BSF    FA6.2
0296E:  MOVF   FF2,W
02970:  MOVWF  00
02972:  BCF    FF2.6
02974:  BCF    FF2.7
02976:  MOVLB  F
02978:  MOVLW  55
0297A:  MOVWF  FA7
0297C:  MOVLW  AA
0297E:  MOVWF  FA7
02980:  BSF    FA6.1
02982:  BTFSC  FA6.1
02984:  BRA    2982
02986:  BCF    FA6.2
02988:  MOVF   00,W
0298A:  IORWF  FF2,F
0298C:  MOVLW  0A
0298E:  MOVLB  B
02990:  MOVWF  x22
02992:  MOVLB  0
02994:  CALL   11F6
....................    } 
....................    if(Flujo[1].Ajuste>10.0 || Flujo[1].Ajuste==0.0){ 
02998:  MOVLB  B
0299A:  CLRF   x22
0299C:  CLRF   x21
0299E:  MOVLW  20
029A0:  MOVWF  x20
029A2:  MOVLW  82
029A4:  MOVWF  x1F
029A6:  MOVFF  454,B26
029AA:  MOVFF  453,B25
029AE:  MOVFF  452,B24
029B2:  MOVFF  451,B23
029B6:  MOVLB  0
029B8:  RCALL  241C
029BA:  BC    29DC
029BC:  MOVFF  454,B22
029C0:  MOVFF  453,B21
029C4:  MOVFF  452,B20
029C8:  MOVFF  451,B1F
029CC:  MOVLB  B
029CE:  CLRF   x26
029D0:  CLRF   x25
029D2:  CLRF   x24
029D4:  CLRF   x23
029D6:  MOVLB  0
029D8:  RCALL  241C
029DA:  BNZ   2A62
....................       Flujo[1].Ajuste=1.1;write_eeprom(25,1);delay_ms(10);write_eeprom(26,5);delay_ms(10); 
029DC:  MOVLW  CD
029DE:  MOVLB  4
029E0:  MOVWF  x54
029E2:  MOVLW  CC
029E4:  MOVWF  x53
029E6:  MOVLW  0C
029E8:  MOVWF  x52
029EA:  MOVLW  7F
029EC:  MOVWF  x51
029EE:  CLRF   FAA
029F0:  MOVLW  19
029F2:  MOVWF  FA9
029F4:  MOVLW  01
029F6:  MOVWF  FA8
029F8:  BCF    FA6.6
029FA:  BCF    FA6.7
029FC:  BSF    FA6.2
029FE:  MOVF   FF2,W
02A00:  MOVWF  00
02A02:  BCF    FF2.6
02A04:  BCF    FF2.7
02A06:  MOVLB  F
02A08:  MOVLW  55
02A0A:  MOVWF  FA7
02A0C:  MOVLW  AA
02A0E:  MOVWF  FA7
02A10:  BSF    FA6.1
02A12:  BTFSC  FA6.1
02A14:  BRA    2A12
02A16:  BCF    FA6.2
02A18:  MOVF   00,W
02A1A:  IORWF  FF2,F
02A1C:  MOVLW  0A
02A1E:  MOVLB  B
02A20:  MOVWF  x22
02A22:  MOVLB  0
02A24:  CALL   11F6
02A28:  CLRF   FAA
02A2A:  MOVLW  1A
02A2C:  MOVWF  FA9
02A2E:  MOVLW  05
02A30:  MOVWF  FA8
02A32:  BCF    FA6.6
02A34:  BCF    FA6.7
02A36:  BSF    FA6.2
02A38:  MOVF   FF2,W
02A3A:  MOVWF  00
02A3C:  BCF    FF2.6
02A3E:  BCF    FF2.7
02A40:  MOVLB  F
02A42:  MOVLW  55
02A44:  MOVWF  FA7
02A46:  MOVLW  AA
02A48:  MOVWF  FA7
02A4A:  BSF    FA6.1
02A4C:  BTFSC  FA6.1
02A4E:  BRA    2A4C
02A50:  BCF    FA6.2
02A52:  MOVF   00,W
02A54:  IORWF  FF2,F
02A56:  MOVLW  0A
02A58:  MOVLB  B
02A5A:  MOVWF  x22
02A5C:  MOVLB  0
02A5E:  CALL   11F6
....................    } 
....................    if(Flujo[2].Ajuste>10.0 || Flujo[2].Ajuste==0.0){ 
02A62:  MOVLB  B
02A64:  CLRF   x22
02A66:  CLRF   x21
02A68:  MOVLW  20
02A6A:  MOVWF  x20
02A6C:  MOVLW  82
02A6E:  MOVWF  x1F
02A70:  MOVFF  5AD,B26
02A74:  MOVFF  5AC,B25
02A78:  MOVFF  5AB,B24
02A7C:  MOVFF  5AA,B23
02A80:  MOVLB  0
02A82:  RCALL  241C
02A84:  BC    2AA6
02A86:  MOVFF  5AD,B22
02A8A:  MOVFF  5AC,B21
02A8E:  MOVFF  5AB,B20
02A92:  MOVFF  5AA,B1F
02A96:  MOVLB  B
02A98:  CLRF   x26
02A9A:  CLRF   x25
02A9C:  CLRF   x24
02A9E:  CLRF   x23
02AA0:  MOVLB  0
02AA2:  RCALL  241C
02AA4:  BNZ   2B2C
....................       Flujo[2].Ajuste=1.1;write_eeprom(27,1);delay_ms(10);write_eeprom(28,5);delay_ms(10); 
02AA6:  MOVLW  CD
02AA8:  MOVLB  5
02AAA:  MOVWF  xAD
02AAC:  MOVLW  CC
02AAE:  MOVWF  xAC
02AB0:  MOVLW  0C
02AB2:  MOVWF  xAB
02AB4:  MOVLW  7F
02AB6:  MOVWF  xAA
02AB8:  CLRF   FAA
02ABA:  MOVLW  1B
02ABC:  MOVWF  FA9
02ABE:  MOVLW  01
02AC0:  MOVWF  FA8
02AC2:  BCF    FA6.6
02AC4:  BCF    FA6.7
02AC6:  BSF    FA6.2
02AC8:  MOVF   FF2,W
02ACA:  MOVWF  00
02ACC:  BCF    FF2.6
02ACE:  BCF    FF2.7
02AD0:  MOVLB  F
02AD2:  MOVLW  55
02AD4:  MOVWF  FA7
02AD6:  MOVLW  AA
02AD8:  MOVWF  FA7
02ADA:  BSF    FA6.1
02ADC:  BTFSC  FA6.1
02ADE:  BRA    2ADC
02AE0:  BCF    FA6.2
02AE2:  MOVF   00,W
02AE4:  IORWF  FF2,F
02AE6:  MOVLW  0A
02AE8:  MOVLB  B
02AEA:  MOVWF  x22
02AEC:  MOVLB  0
02AEE:  CALL   11F6
02AF2:  CLRF   FAA
02AF4:  MOVLW  1C
02AF6:  MOVWF  FA9
02AF8:  MOVLW  05
02AFA:  MOVWF  FA8
02AFC:  BCF    FA6.6
02AFE:  BCF    FA6.7
02B00:  BSF    FA6.2
02B02:  MOVF   FF2,W
02B04:  MOVWF  00
02B06:  BCF    FF2.6
02B08:  BCF    FF2.7
02B0A:  MOVLB  F
02B0C:  MOVLW  55
02B0E:  MOVWF  FA7
02B10:  MOVLW  AA
02B12:  MOVWF  FA7
02B14:  BSF    FA6.1
02B16:  BTFSC  FA6.1
02B18:  BRA    2B16
02B1A:  BCF    FA6.2
02B1C:  MOVF   00,W
02B1E:  IORWF  FF2,F
02B20:  MOVLW  0A
02B22:  MOVLB  B
02B24:  MOVWF  x22
02B26:  MOVLB  0
02B28:  CALL   11F6
....................    } 
....................    if(Presion[4].Ajuste>2.0 || Presion[4].Ajuste==0.0){ 
02B2C:  MOVLB  B
02B2E:  CLRF   x22
02B30:  CLRF   x21
02B32:  CLRF   x20
02B34:  MOVLW  80
02B36:  MOVWF  x1F
02B38:  MOVFF  AC7,B26
02B3C:  MOVFF  AC6,B25
02B40:  MOVFF  AC5,B24
02B44:  MOVFF  AC4,B23
02B48:  MOVLB  0
02B4A:  RCALL  241C
02B4C:  BC    2B6E
02B4E:  MOVFF  AC7,B22
02B52:  MOVFF  AC6,B21
02B56:  MOVFF  AC5,B20
02B5A:  MOVFF  AC4,B1F
02B5E:  MOVLB  B
02B60:  CLRF   x26
02B62:  CLRF   x25
02B64:  CLRF   x24
02B66:  CLRF   x23
02B68:  MOVLB  0
02B6A:  RCALL  241C
02B6C:  BNZ   2BEC
....................       Presion[4].Ajuste=1.0;write_eeprom(29,1);delay_ms(10);write_eeprom(30,0);delay_ms(10); 
02B6E:  MOVLB  A
02B70:  CLRF   xC7
02B72:  CLRF   xC6
02B74:  CLRF   xC5
02B76:  MOVLW  7F
02B78:  MOVWF  xC4
02B7A:  CLRF   FAA
02B7C:  MOVLW  1D
02B7E:  MOVWF  FA9
02B80:  MOVLW  01
02B82:  MOVWF  FA8
02B84:  BCF    FA6.6
02B86:  BCF    FA6.7
02B88:  BSF    FA6.2
02B8A:  MOVF   FF2,W
02B8C:  MOVWF  00
02B8E:  BCF    FF2.6
02B90:  BCF    FF2.7
02B92:  MOVLB  F
02B94:  MOVLW  55
02B96:  MOVWF  FA7
02B98:  MOVLW  AA
02B9A:  MOVWF  FA7
02B9C:  BSF    FA6.1
02B9E:  BTFSC  FA6.1
02BA0:  BRA    2B9E
02BA2:  BCF    FA6.2
02BA4:  MOVF   00,W
02BA6:  IORWF  FF2,F
02BA8:  MOVLW  0A
02BAA:  MOVLB  B
02BAC:  MOVWF  x22
02BAE:  MOVLB  0
02BB0:  CALL   11F6
02BB4:  CLRF   FAA
02BB6:  MOVLW  1E
02BB8:  MOVWF  FA9
02BBA:  CLRF   FA8
02BBC:  BCF    FA6.6
02BBE:  BCF    FA6.7
02BC0:  BSF    FA6.2
02BC2:  MOVF   FF2,W
02BC4:  MOVWF  00
02BC6:  BCF    FF2.6
02BC8:  BCF    FF2.7
02BCA:  MOVLB  F
02BCC:  MOVLW  55
02BCE:  MOVWF  FA7
02BD0:  MOVLW  AA
02BD2:  MOVWF  FA7
02BD4:  BSF    FA6.1
02BD6:  BTFSC  FA6.1
02BD8:  BRA    2BD6
02BDA:  BCF    FA6.2
02BDC:  MOVF   00,W
02BDE:  IORWF  FF2,F
02BE0:  MOVLW  0A
02BE2:  MOVLB  B
02BE4:  MOVWF  x22
02BE6:  MOVLB  0
02BE8:  CALL   11F6
....................    } 
....................    if(Presion[3].Ajuste>2.0 || Presion[3].Ajuste==0.0){ 
02BEC:  MOVLB  B
02BEE:  CLRF   x22
02BF0:  CLRF   x21
02BF2:  CLRF   x20
02BF4:  MOVLW  80
02BF6:  MOVWF  x1F
02BF8:  MOVFF  A83,B26
02BFC:  MOVFF  A82,B25
02C00:  MOVFF  A81,B24
02C04:  MOVFF  A80,B23
02C08:  MOVLB  0
02C0A:  RCALL  241C
02C0C:  BC    2C30
02C0E:  MOVFF  A83,B22
02C12:  MOVFF  A82,B21
02C16:  MOVFF  A81,B20
02C1A:  MOVFF  A80,B1F
02C1E:  MOVLB  B
02C20:  CLRF   x26
02C22:  CLRF   x25
02C24:  CLRF   x24
02C26:  CLRF   x23
02C28:  MOVLB  0
02C2A:  CALL   241C
02C2E:  BNZ   2CAE
....................       Presion[3].Ajuste=1.0;write_eeprom(31,1);delay_ms(10);write_eeprom(32,0);delay_ms(10); 
02C30:  MOVLB  A
02C32:  CLRF   x83
02C34:  CLRF   x82
02C36:  CLRF   x81
02C38:  MOVLW  7F
02C3A:  MOVWF  x80
02C3C:  CLRF   FAA
02C3E:  MOVLW  1F
02C40:  MOVWF  FA9
02C42:  MOVLW  01
02C44:  MOVWF  FA8
02C46:  BCF    FA6.6
02C48:  BCF    FA6.7
02C4A:  BSF    FA6.2
02C4C:  MOVF   FF2,W
02C4E:  MOVWF  00
02C50:  BCF    FF2.6
02C52:  BCF    FF2.7
02C54:  MOVLB  F
02C56:  MOVLW  55
02C58:  MOVWF  FA7
02C5A:  MOVLW  AA
02C5C:  MOVWF  FA7
02C5E:  BSF    FA6.1
02C60:  BTFSC  FA6.1
02C62:  BRA    2C60
02C64:  BCF    FA6.2
02C66:  MOVF   00,W
02C68:  IORWF  FF2,F
02C6A:  MOVLW  0A
02C6C:  MOVLB  B
02C6E:  MOVWF  x22
02C70:  MOVLB  0
02C72:  CALL   11F6
02C76:  CLRF   FAA
02C78:  MOVLW  20
02C7A:  MOVWF  FA9
02C7C:  CLRF   FA8
02C7E:  BCF    FA6.6
02C80:  BCF    FA6.7
02C82:  BSF    FA6.2
02C84:  MOVF   FF2,W
02C86:  MOVWF  00
02C88:  BCF    FF2.6
02C8A:  BCF    FF2.7
02C8C:  MOVLB  F
02C8E:  MOVLW  55
02C90:  MOVWF  FA7
02C92:  MOVLW  AA
02C94:  MOVWF  FA7
02C96:  BSF    FA6.1
02C98:  BTFSC  FA6.1
02C9A:  BRA    2C98
02C9C:  BCF    FA6.2
02C9E:  MOVF   00,W
02CA0:  IORWF  FF2,F
02CA2:  MOVLW  0A
02CA4:  MOVLB  B
02CA6:  MOVWF  x22
02CA8:  MOVLB  0
02CAA:  CALL   11F6
....................    } 
....................    if(Flujo[1].zero_actual>260 ||Flujo[1].zero_actual<200 ){ 
02CAE:  MOVLB  B
02CB0:  CLRF   x22
02CB2:  CLRF   x21
02CB4:  MOVLW  02
02CB6:  MOVWF  x20
02CB8:  MOVLW  87
02CBA:  MOVWF  x1F
02CBC:  MOVFF  43F,B26
02CC0:  MOVFF  43E,B25
02CC4:  MOVFF  43D,B24
02CC8:  MOVFF  43C,B23
02CCC:  MOVLB  0
02CCE:  CALL   241C
02CD2:  BC    2CFA
02CD4:  MOVFF  43F,B22
02CD8:  MOVFF  43E,B21
02CDC:  MOVFF  43D,B20
02CE0:  MOVFF  43C,B1F
02CE4:  MOVLB  B
02CE6:  CLRF   x26
02CE8:  CLRF   x25
02CEA:  MOVLW  48
02CEC:  MOVWF  x24
02CEE:  MOVLW  86
02CF0:  MOVWF  x23
02CF2:  MOVLB  0
02CF4:  CALL   241C
02CF8:  BNC   2D7A
....................       Flujo[1].zero_actual=203;write_eeprom(33,203);delay_ms(10);write_eeprom(34,0);delay_ms(10); 
02CFA:  MOVLB  4
02CFC:  CLRF   x3F
02CFE:  CLRF   x3E
02D00:  MOVLW  4B
02D02:  MOVWF  x3D
02D04:  MOVLW  86
02D06:  MOVWF  x3C
02D08:  CLRF   FAA
02D0A:  MOVLW  21
02D0C:  MOVWF  FA9
02D0E:  MOVLW  CB
02D10:  MOVWF  FA8
02D12:  BCF    FA6.6
02D14:  BCF    FA6.7
02D16:  BSF    FA6.2
02D18:  MOVF   FF2,W
02D1A:  MOVWF  00
02D1C:  BCF    FF2.6
02D1E:  BCF    FF2.7
02D20:  MOVLB  F
02D22:  MOVLW  55
02D24:  MOVWF  FA7
02D26:  MOVLW  AA
02D28:  MOVWF  FA7
02D2A:  BSF    FA6.1
02D2C:  BTFSC  FA6.1
02D2E:  BRA    2D2C
02D30:  BCF    FA6.2
02D32:  MOVF   00,W
02D34:  IORWF  FF2,F
02D36:  MOVLW  0A
02D38:  MOVLB  B
02D3A:  MOVWF  x22
02D3C:  MOVLB  0
02D3E:  CALL   11F6
02D42:  CLRF   FAA
02D44:  MOVLW  22
02D46:  MOVWF  FA9
02D48:  CLRF   FA8
02D4A:  BCF    FA6.6
02D4C:  BCF    FA6.7
02D4E:  BSF    FA6.2
02D50:  MOVF   FF2,W
02D52:  MOVWF  00
02D54:  BCF    FF2.6
02D56:  BCF    FF2.7
02D58:  MOVLB  F
02D5A:  MOVLW  55
02D5C:  MOVWF  FA7
02D5E:  MOVLW  AA
02D60:  MOVWF  FA7
02D62:  BSF    FA6.1
02D64:  BTFSC  FA6.1
02D66:  BRA    2D64
02D68:  BCF    FA6.2
02D6A:  MOVF   00,W
02D6C:  IORWF  FF2,F
02D6E:  MOVLW  0A
02D70:  MOVLB  B
02D72:  MOVWF  x22
02D74:  MOVLB  0
02D76:  CALL   11F6
....................    } 
....................    if(Flujo[2].zero_actual>260 ||Flujo[2].zero_actual<200){ 
02D7A:  MOVLB  B
02D7C:  CLRF   x22
02D7E:  CLRF   x21
02D80:  MOVLW  02
02D82:  MOVWF  x20
02D84:  MOVLW  87
02D86:  MOVWF  x1F
02D88:  MOVFF  598,B26
02D8C:  MOVFF  597,B25
02D90:  MOVFF  596,B24
02D94:  MOVFF  595,B23
02D98:  MOVLB  0
02D9A:  CALL   241C
02D9E:  BC    2DC6
02DA0:  MOVFF  598,B22
02DA4:  MOVFF  597,B21
02DA8:  MOVFF  596,B20
02DAC:  MOVFF  595,B1F
02DB0:  MOVLB  B
02DB2:  CLRF   x26
02DB4:  CLRF   x25
02DB6:  MOVLW  48
02DB8:  MOVWF  x24
02DBA:  MOVLW  86
02DBC:  MOVWF  x23
02DBE:  MOVLB  0
02DC0:  CALL   241C
02DC4:  BNC   2E46
....................       Flujo[2].zero_actual=203;write_eeprom(35,203);delay_ms(10);write_eeprom(36,0);delay_ms(10); 
02DC6:  MOVLB  5
02DC8:  CLRF   x98
02DCA:  CLRF   x97
02DCC:  MOVLW  4B
02DCE:  MOVWF  x96
02DD0:  MOVLW  86
02DD2:  MOVWF  x95
02DD4:  CLRF   FAA
02DD6:  MOVLW  23
02DD8:  MOVWF  FA9
02DDA:  MOVLW  CB
02DDC:  MOVWF  FA8
02DDE:  BCF    FA6.6
02DE0:  BCF    FA6.7
02DE2:  BSF    FA6.2
02DE4:  MOVF   FF2,W
02DE6:  MOVWF  00
02DE8:  BCF    FF2.6
02DEA:  BCF    FF2.7
02DEC:  MOVLB  F
02DEE:  MOVLW  55
02DF0:  MOVWF  FA7
02DF2:  MOVLW  AA
02DF4:  MOVWF  FA7
02DF6:  BSF    FA6.1
02DF8:  BTFSC  FA6.1
02DFA:  BRA    2DF8
02DFC:  BCF    FA6.2
02DFE:  MOVF   00,W
02E00:  IORWF  FF2,F
02E02:  MOVLW  0A
02E04:  MOVLB  B
02E06:  MOVWF  x22
02E08:  MOVLB  0
02E0A:  CALL   11F6
02E0E:  CLRF   FAA
02E10:  MOVLW  24
02E12:  MOVWF  FA9
02E14:  CLRF   FA8
02E16:  BCF    FA6.6
02E18:  BCF    FA6.7
02E1A:  BSF    FA6.2
02E1C:  MOVF   FF2,W
02E1E:  MOVWF  00
02E20:  BCF    FF2.6
02E22:  BCF    FF2.7
02E24:  MOVLB  F
02E26:  MOVLW  55
02E28:  MOVWF  FA7
02E2A:  MOVLW  AA
02E2C:  MOVWF  FA7
02E2E:  BSF    FA6.1
02E30:  BTFSC  FA6.1
02E32:  BRA    2E30
02E34:  BCF    FA6.2
02E36:  MOVF   00,W
02E38:  IORWF  FF2,F
02E3A:  MOVLW  0A
02E3C:  MOVLB  B
02E3E:  MOVWF  x22
02E40:  MOVLB  0
02E42:  CALL   11F6
....................    } 
....................    if(minutos_trabajo>3600){ 
02E46:  MOVF   xC4,W
02E48:  SUBLW  0D
02E4A:  BC    2ECA
02E4C:  XORLW  FF
02E4E:  BNZ   2E56
02E50:  MOVF   xC3,W
02E52:  SUBLW  10
02E54:  BC    2ECA
....................       minutos_trabajo=0;write_eeprom(37,0);delay_ms(10);write_eeprom(38,0);delay_ms(10); 
02E56:  CLRF   xC4
02E58:  CLRF   xC3
02E5A:  CLRF   FAA
02E5C:  MOVLW  25
02E5E:  MOVWF  FA9
02E60:  CLRF   FA8
02E62:  BCF    FA6.6
02E64:  BCF    FA6.7
02E66:  BSF    FA6.2
02E68:  MOVF   FF2,W
02E6A:  MOVWF  00
02E6C:  BCF    FF2.6
02E6E:  BCF    FF2.7
02E70:  MOVLB  F
02E72:  MOVLW  55
02E74:  MOVWF  FA7
02E76:  MOVLW  AA
02E78:  MOVWF  FA7
02E7A:  BSF    FA6.1
02E7C:  BTFSC  FA6.1
02E7E:  BRA    2E7C
02E80:  BCF    FA6.2
02E82:  MOVF   00,W
02E84:  IORWF  FF2,F
02E86:  MOVLW  0A
02E88:  MOVLB  B
02E8A:  MOVWF  x22
02E8C:  MOVLB  0
02E8E:  CALL   11F6
02E92:  CLRF   FAA
02E94:  MOVLW  26
02E96:  MOVWF  FA9
02E98:  CLRF   FA8
02E9A:  BCF    FA6.6
02E9C:  BCF    FA6.7
02E9E:  BSF    FA6.2
02EA0:  MOVF   FF2,W
02EA2:  MOVWF  00
02EA4:  BCF    FF2.6
02EA6:  BCF    FF2.7
02EA8:  MOVLB  F
02EAA:  MOVLW  55
02EAC:  MOVWF  FA7
02EAE:  MOVLW  AA
02EB0:  MOVWF  FA7
02EB2:  BSF    FA6.1
02EB4:  BTFSC  FA6.1
02EB6:  BRA    2EB4
02EB8:  BCF    FA6.2
02EBA:  MOVF   00,W
02EBC:  IORWF  FF2,F
02EBE:  MOVLW  0A
02EC0:  MOVLB  B
02EC2:  MOVWF  x22
02EC4:  MOVLB  0
02EC6:  CALL   11F6
....................    } 
....................    if(minutos_uv>60){ 
02ECA:  MOVF   xC2,F
02ECC:  BNZ   2ED4
02ECE:  MOVF   xC1,W
02ED0:  SUBLW  3C
02ED2:  BC    2F10
....................       minutos_uv=0;write_eeprom(39,0);delay_ms(10); 
02ED4:  CLRF   xC2
02ED6:  CLRF   xC1
02ED8:  CLRF   FAA
02EDA:  MOVLW  27
02EDC:  MOVWF  FA9
02EDE:  CLRF   FA8
02EE0:  BCF    FA6.6
02EE2:  BCF    FA6.7
02EE4:  BSF    FA6.2
02EE6:  MOVF   FF2,W
02EE8:  MOVWF  00
02EEA:  BCF    FF2.6
02EEC:  BCF    FF2.7
02EEE:  MOVLB  F
02EF0:  MOVLW  55
02EF2:  MOVWF  FA7
02EF4:  MOVLW  AA
02EF6:  MOVWF  FA7
02EF8:  BSF    FA6.1
02EFA:  BTFSC  FA6.1
02EFC:  BRA    2EFA
02EFE:  BCF    FA6.2
02F00:  MOVF   00,W
02F02:  IORWF  FF2,F
02F04:  MOVLW  0A
02F06:  MOVLB  B
02F08:  MOVWF  x22
02F0A:  MOVLB  0
02F0C:  CALL   11F6
....................    } 
....................    if(Vel1>6){ 
02F10:  MOVF   x93,W
02F12:  SUBLW  06
02F14:  BC    2F54
....................       Vel1=2;write_eeprom(40,2);delay_ms(10); 
02F16:  MOVLW  02
02F18:  MOVWF  x93
02F1A:  CLRF   FAA
02F1C:  MOVLW  28
02F1E:  MOVWF  FA9
02F20:  MOVLW  02
02F22:  MOVWF  FA8
02F24:  BCF    FA6.6
02F26:  BCF    FA6.7
02F28:  BSF    FA6.2
02F2A:  MOVF   FF2,W
02F2C:  MOVWF  00
02F2E:  BCF    FF2.6
02F30:  BCF    FF2.7
02F32:  MOVLB  F
02F34:  MOVLW  55
02F36:  MOVWF  FA7
02F38:  MOVLW  AA
02F3A:  MOVWF  FA7
02F3C:  BSF    FA6.1
02F3E:  BTFSC  FA6.1
02F40:  BRA    2F3E
02F42:  BCF    FA6.2
02F44:  MOVF   00,W
02F46:  IORWF  FF2,F
02F48:  MOVLW  0A
02F4A:  MOVLB  B
02F4C:  MOVWF  x22
02F4E:  MOVLB  0
02F50:  CALL   11F6
....................    }    
....................    if(Vel2>6){ 
02F54:  MOVF   x94,W
02F56:  SUBLW  06
02F58:  BC    2F98
....................       Vel2=2;write_eeprom(41,2);delay_ms(10); 
02F5A:  MOVLW  02
02F5C:  MOVWF  x94
02F5E:  CLRF   FAA
02F60:  MOVLW  29
02F62:  MOVWF  FA9
02F64:  MOVLW  02
02F66:  MOVWF  FA8
02F68:  BCF    FA6.6
02F6A:  BCF    FA6.7
02F6C:  BSF    FA6.2
02F6E:  MOVF   FF2,W
02F70:  MOVWF  00
02F72:  BCF    FF2.6
02F74:  BCF    FF2.7
02F76:  MOVLB  F
02F78:  MOVLW  55
02F7A:  MOVWF  FA7
02F7C:  MOVLW  AA
02F7E:  MOVWF  FA7
02F80:  BSF    FA6.1
02F82:  BTFSC  FA6.1
02F84:  BRA    2F82
02F86:  BCF    FA6.2
02F88:  MOVF   00,W
02F8A:  IORWF  FF2,F
02F8C:  MOVLW  0A
02F8E:  MOVLB  B
02F90:  MOVWF  x22
02F92:  MOVLB  0
02F94:  CALL   11F6
....................    }    
....................     
....................    if(Flujo[1].Diferencia>80){ 
02F98:  MOVLB  B
02F9A:  CLRF   x22
02F9C:  CLRF   x21
02F9E:  MOVLW  20
02FA0:  MOVWF  x20
02FA2:  MOVLW  85
02FA4:  MOVWF  x1F
02FA6:  MOVFF  443,B26
02FAA:  MOVFF  442,B25
02FAE:  MOVFF  441,B24
02FB2:  MOVFF  440,B23
02FB6:  MOVLB  0
02FB8:  CALL   241C
02FBC:  BNC   3038
....................       Flujo[1].Diferencia=0;write_eeprom(42,0);delay_ms(10);write_eeprom(43,0);delay_ms(10); 
02FBE:  MOVLB  4
02FC0:  CLRF   x43
02FC2:  CLRF   x42
02FC4:  CLRF   x41
02FC6:  CLRF   x40
02FC8:  CLRF   FAA
02FCA:  MOVLW  2A
02FCC:  MOVWF  FA9
02FCE:  CLRF   FA8
02FD0:  BCF    FA6.6
02FD2:  BCF    FA6.7
02FD4:  BSF    FA6.2
02FD6:  MOVF   FF2,W
02FD8:  MOVWF  00
02FDA:  BCF    FF2.6
02FDC:  BCF    FF2.7
02FDE:  MOVLB  F
02FE0:  MOVLW  55
02FE2:  MOVWF  FA7
02FE4:  MOVLW  AA
02FE6:  MOVWF  FA7
02FE8:  BSF    FA6.1
02FEA:  BTFSC  FA6.1
02FEC:  BRA    2FEA
02FEE:  BCF    FA6.2
02FF0:  MOVF   00,W
02FF2:  IORWF  FF2,F
02FF4:  MOVLW  0A
02FF6:  MOVLB  B
02FF8:  MOVWF  x22
02FFA:  MOVLB  0
02FFC:  CALL   11F6
03000:  CLRF   FAA
03002:  MOVLW  2B
03004:  MOVWF  FA9
03006:  CLRF   FA8
03008:  BCF    FA6.6
0300A:  BCF    FA6.7
0300C:  BSF    FA6.2
0300E:  MOVF   FF2,W
03010:  MOVWF  00
03012:  BCF    FF2.6
03014:  BCF    FF2.7
03016:  MOVLB  F
03018:  MOVLW  55
0301A:  MOVWF  FA7
0301C:  MOVLW  AA
0301E:  MOVWF  FA7
03020:  BSF    FA6.1
03022:  BTFSC  FA6.1
03024:  BRA    3022
03026:  BCF    FA6.2
03028:  MOVF   00,W
0302A:  IORWF  FF2,F
0302C:  MOVLW  0A
0302E:  MOVLB  B
03030:  MOVWF  x22
03032:  MOVLB  0
03034:  CALL   11F6
....................    } 
....................    if(Flujo[2].Diferencia>80){ 
03038:  MOVLB  B
0303A:  CLRF   x22
0303C:  CLRF   x21
0303E:  MOVLW  20
03040:  MOVWF  x20
03042:  MOVLW  85
03044:  MOVWF  x1F
03046:  MOVFF  59C,B26
0304A:  MOVFF  59B,B25
0304E:  MOVFF  59A,B24
03052:  MOVFF  599,B23
03056:  MOVLB  0
03058:  CALL   241C
0305C:  BNC   30D8
....................       Flujo[2].Diferencia=0;write_eeprom(44,0);delay_ms(10);write_eeprom(45,0);delay_ms(10); 
0305E:  MOVLB  5
03060:  CLRF   x9C
03062:  CLRF   x9B
03064:  CLRF   x9A
03066:  CLRF   x99
03068:  CLRF   FAA
0306A:  MOVLW  2C
0306C:  MOVWF  FA9
0306E:  CLRF   FA8
03070:  BCF    FA6.6
03072:  BCF    FA6.7
03074:  BSF    FA6.2
03076:  MOVF   FF2,W
03078:  MOVWF  00
0307A:  BCF    FF2.6
0307C:  BCF    FF2.7
0307E:  MOVLB  F
03080:  MOVLW  55
03082:  MOVWF  FA7
03084:  MOVLW  AA
03086:  MOVWF  FA7
03088:  BSF    FA6.1
0308A:  BTFSC  FA6.1
0308C:  BRA    308A
0308E:  BCF    FA6.2
03090:  MOVF   00,W
03092:  IORWF  FF2,F
03094:  MOVLW  0A
03096:  MOVLB  B
03098:  MOVWF  x22
0309A:  MOVLB  0
0309C:  CALL   11F6
030A0:  CLRF   FAA
030A2:  MOVLW  2D
030A4:  MOVWF  FA9
030A6:  CLRF   FA8
030A8:  BCF    FA6.6
030AA:  BCF    FA6.7
030AC:  BSF    FA6.2
030AE:  MOVF   FF2,W
030B0:  MOVWF  00
030B2:  BCF    FF2.6
030B4:  BCF    FF2.7
030B6:  MOVLB  F
030B8:  MOVLW  55
030BA:  MOVWF  FA7
030BC:  MOVLW  AA
030BE:  MOVWF  FA7
030C0:  BSF    FA6.1
030C2:  BTFSC  FA6.1
030C4:  BRA    30C2
030C6:  BCF    FA6.2
030C8:  MOVF   00,W
030CA:  IORWF  FF2,F
030CC:  MOVLW  0A
030CE:  MOVLB  B
030D0:  MOVWF  x22
030D2:  MOVLB  0
030D4:  CALL   11F6
....................    } 
....................    if(Presion[4].G>280 || Presion[4].G<200){ 
030D8:  MOVLB  B
030DA:  CLRF   x22
030DC:  CLRF   x21
030DE:  MOVLW  0C
030E0:  MOVWF  x20
030E2:  MOVLW  87
030E4:  MOVWF  x1F
030E6:  MOVFF  AB9,B26
030EA:  MOVFF  AB8,B25
030EE:  MOVFF  AB7,B24
030F2:  MOVFF  AB6,B23
030F6:  MOVLB  0
030F8:  CALL   241C
030FC:  BC    3124
030FE:  MOVFF  AB9,B22
03102:  MOVFF  AB8,B21
03106:  MOVFF  AB7,B20
0310A:  MOVFF  AB6,B1F
0310E:  MOVLB  B
03110:  CLRF   x26
03112:  CLRF   x25
03114:  MOVLW  48
03116:  MOVWF  x24
03118:  MOVLW  86
0311A:  MOVWF  x23
0311C:  MOVLB  0
0311E:  CALL   241C
03122:  BNC   31A4
....................       Presion[4].G=220;write_eeprom(46,220);delay_ms(10);write_eeprom(47,0);delay_ms(10); 
03124:  MOVLB  A
03126:  CLRF   xB9
03128:  CLRF   xB8
0312A:  MOVLW  5C
0312C:  MOVWF  xB7
0312E:  MOVLW  86
03130:  MOVWF  xB6
03132:  CLRF   FAA
03134:  MOVLW  2E
03136:  MOVWF  FA9
03138:  MOVLW  DC
0313A:  MOVWF  FA8
0313C:  BCF    FA6.6
0313E:  BCF    FA6.7
03140:  BSF    FA6.2
03142:  MOVF   FF2,W
03144:  MOVWF  00
03146:  BCF    FF2.6
03148:  BCF    FF2.7
0314A:  MOVLB  F
0314C:  MOVLW  55
0314E:  MOVWF  FA7
03150:  MOVLW  AA
03152:  MOVWF  FA7
03154:  BSF    FA6.1
03156:  BTFSC  FA6.1
03158:  BRA    3156
0315A:  BCF    FA6.2
0315C:  MOVF   00,W
0315E:  IORWF  FF2,F
03160:  MOVLW  0A
03162:  MOVLB  B
03164:  MOVWF  x22
03166:  MOVLB  0
03168:  CALL   11F6
0316C:  CLRF   FAA
0316E:  MOVLW  2F
03170:  MOVWF  FA9
03172:  CLRF   FA8
03174:  BCF    FA6.6
03176:  BCF    FA6.7
03178:  BSF    FA6.2
0317A:  MOVF   FF2,W
0317C:  MOVWF  00
0317E:  BCF    FF2.6
03180:  BCF    FF2.7
03182:  MOVLB  F
03184:  MOVLW  55
03186:  MOVWF  FA7
03188:  MOVLW  AA
0318A:  MOVWF  FA7
0318C:  BSF    FA6.1
0318E:  BTFSC  FA6.1
03190:  BRA    318E
03192:  BCF    FA6.2
03194:  MOVF   00,W
03196:  IORWF  FF2,F
03198:  MOVLW  0A
0319A:  MOVLB  B
0319C:  MOVWF  x22
0319E:  MOVLB  0
031A0:  CALL   11F6
....................    } 
....................    if(Presion[3].G>280 || Presion[3].G<200){ 
031A4:  MOVLB  B
031A6:  CLRF   x22
031A8:  CLRF   x21
031AA:  MOVLW  0C
031AC:  MOVWF  x20
031AE:  MOVLW  87
031B0:  MOVWF  x1F
031B2:  MOVFF  A75,B26
031B6:  MOVFF  A74,B25
031BA:  MOVFF  A73,B24
031BE:  MOVFF  A72,B23
031C2:  MOVLB  0
031C4:  CALL   241C
031C8:  BC    31F0
031CA:  MOVFF  A75,B22
031CE:  MOVFF  A74,B21
031D2:  MOVFF  A73,B20
031D6:  MOVFF  A72,B1F
031DA:  MOVLB  B
031DC:  CLRF   x26
031DE:  CLRF   x25
031E0:  MOVLW  48
031E2:  MOVWF  x24
031E4:  MOVLW  86
031E6:  MOVWF  x23
031E8:  MOVLB  0
031EA:  CALL   241C
031EE:  BNC   3270
....................       Presion[3].G=220;write_eeprom(48,220);delay_ms(10);write_eeprom(49,0);delay_ms(10); 
031F0:  MOVLB  A
031F2:  CLRF   x75
031F4:  CLRF   x74
031F6:  MOVLW  5C
031F8:  MOVWF  x73
031FA:  MOVLW  86
031FC:  MOVWF  x72
031FE:  CLRF   FAA
03200:  MOVLW  30
03202:  MOVWF  FA9
03204:  MOVLW  DC
03206:  MOVWF  FA8
03208:  BCF    FA6.6
0320A:  BCF    FA6.7
0320C:  BSF    FA6.2
0320E:  MOVF   FF2,W
03210:  MOVWF  00
03212:  BCF    FF2.6
03214:  BCF    FF2.7
03216:  MOVLB  F
03218:  MOVLW  55
0321A:  MOVWF  FA7
0321C:  MOVLW  AA
0321E:  MOVWF  FA7
03220:  BSF    FA6.1
03222:  BTFSC  FA6.1
03224:  BRA    3222
03226:  BCF    FA6.2
03228:  MOVF   00,W
0322A:  IORWF  FF2,F
0322C:  MOVLW  0A
0322E:  MOVLB  B
03230:  MOVWF  x22
03232:  MOVLB  0
03234:  CALL   11F6
03238:  CLRF   FAA
0323A:  MOVLW  31
0323C:  MOVWF  FA9
0323E:  CLRF   FA8
03240:  BCF    FA6.6
03242:  BCF    FA6.7
03244:  BSF    FA6.2
03246:  MOVF   FF2,W
03248:  MOVWF  00
0324A:  BCF    FF2.6
0324C:  BCF    FF2.7
0324E:  MOVLB  F
03250:  MOVLW  55
03252:  MOVWF  FA7
03254:  MOVLW  AA
03256:  MOVWF  FA7
03258:  BSF    FA6.1
0325A:  BTFSC  FA6.1
0325C:  BRA    325A
0325E:  BCF    FA6.2
03260:  MOVF   00,W
03262:  IORWF  FF2,F
03264:  MOVLW  0A
03266:  MOVLB  B
03268:  MOVWF  x22
0326A:  MOVLB  0
0326C:  CALL   11F6
....................    } 
....................    if(Flujo[1].negativo>20){ 
03270:  MOVLB  4
03272:  MOVF   x46,W
03274:  SUBLW  14
03276:  BC    32B6
....................       Flujo[1].negativo=10;write_eeprom(50,10);delay_ms(10); 
03278:  MOVLW  0A
0327A:  MOVWF  x46
0327C:  CLRF   FAA
0327E:  MOVLW  32
03280:  MOVWF  FA9
03282:  MOVLW  0A
03284:  MOVWF  FA8
03286:  BCF    FA6.6
03288:  BCF    FA6.7
0328A:  BSF    FA6.2
0328C:  MOVF   FF2,W
0328E:  MOVWF  00
03290:  BCF    FF2.6
03292:  BCF    FF2.7
03294:  MOVLB  F
03296:  MOVLW  55
03298:  MOVWF  FA7
0329A:  MOVLW  AA
0329C:  MOVWF  FA7
0329E:  BSF    FA6.1
032A0:  BTFSC  FA6.1
032A2:  BRA    32A0
032A4:  BCF    FA6.2
032A6:  MOVF   00,W
032A8:  IORWF  FF2,F
032AA:  MOVLW  0A
032AC:  MOVLB  B
032AE:  MOVWF  x22
032B0:  MOVLB  0
032B2:  CALL   11F6
....................    } 
....................    if(Flujo[2].negativo>20){ 
032B6:  MOVLB  5
032B8:  MOVF   x9F,W
032BA:  SUBLW  14
032BC:  BC    32FC
....................       Flujo[2].negativo=10;write_eeprom(51,10);delay_ms(10); 
032BE:  MOVLW  0A
032C0:  MOVWF  x9F
032C2:  CLRF   FAA
032C4:  MOVLW  33
032C6:  MOVWF  FA9
032C8:  MOVLW  0A
032CA:  MOVWF  FA8
032CC:  BCF    FA6.6
032CE:  BCF    FA6.7
032D0:  BSF    FA6.2
032D2:  MOVF   FF2,W
032D4:  MOVWF  00
032D6:  BCF    FF2.6
032D8:  BCF    FF2.7
032DA:  MOVLB  F
032DC:  MOVLW  55
032DE:  MOVWF  FA7
032E0:  MOVLW  AA
032E2:  MOVWF  FA7
032E4:  BSF    FA6.1
032E6:  BTFSC  FA6.1
032E8:  BRA    32E6
032EA:  BCF    FA6.2
032EC:  MOVF   00,W
032EE:  IORWF  FF2,F
032F0:  MOVLW  0A
032F2:  MOVLB  B
032F4:  MOVWF  x22
032F6:  MOVLB  0
032F8:  CALL   11F6
....................    } 
....................    if(Relacion>1.0){ 
032FC:  MOVLB  B
032FE:  CLRF   x22
03300:  CLRF   x21
03302:  CLRF   x20
03304:  MOVLW  7F
03306:  MOVWF  x1F
03308:  MOVFF  2C4,B26
0330C:  MOVFF  2C3,B25
03310:  MOVFF  2C2,B24
03314:  MOVFF  2C1,B23
03318:  MOVLB  0
0331A:  CALL   241C
0331E:  BNC   33A4
....................       Relacion=0.57;write_eeprom(52,0);delay_ms(10);write_eeprom(53,57);delay_ms(10); 
03320:  MOVLW  85
03322:  MOVLB  2
03324:  MOVWF  xC4
03326:  MOVLW  EB
03328:  MOVWF  xC3
0332A:  MOVLW  11
0332C:  MOVWF  xC2
0332E:  MOVLW  7E
03330:  MOVWF  xC1
03332:  CLRF   FAA
03334:  MOVLW  34
03336:  MOVWF  FA9
03338:  CLRF   FA8
0333A:  BCF    FA6.6
0333C:  BCF    FA6.7
0333E:  BSF    FA6.2
03340:  MOVF   FF2,W
03342:  MOVWF  00
03344:  BCF    FF2.6
03346:  BCF    FF2.7
03348:  MOVLB  F
0334A:  MOVLW  55
0334C:  MOVWF  FA7
0334E:  MOVLW  AA
03350:  MOVWF  FA7
03352:  BSF    FA6.1
03354:  BTFSC  FA6.1
03356:  BRA    3354
03358:  BCF    FA6.2
0335A:  MOVF   00,W
0335C:  IORWF  FF2,F
0335E:  MOVLW  0A
03360:  MOVLB  B
03362:  MOVWF  x22
03364:  MOVLB  0
03366:  CALL   11F6
0336A:  CLRF   FAA
0336C:  MOVLW  35
0336E:  MOVWF  FA9
03370:  MOVLW  39
03372:  MOVWF  FA8
03374:  BCF    FA6.6
03376:  BCF    FA6.7
03378:  BSF    FA6.2
0337A:  MOVF   FF2,W
0337C:  MOVWF  00
0337E:  BCF    FF2.6
03380:  BCF    FF2.7
03382:  MOVLB  F
03384:  MOVLW  55
03386:  MOVWF  FA7
03388:  MOVLW  AA
0338A:  MOVWF  FA7
0338C:  BSF    FA6.1
0338E:  BTFSC  FA6.1
03390:  BRA    338E
03392:  BCF    FA6.2
03394:  MOVF   00,W
03396:  IORWF  FF2,F
03398:  MOVLW  0A
0339A:  MOVLB  B
0339C:  MOVWF  x22
0339E:  MOVLB  0
033A0:  CALL   11F6
....................    } 
....................    if(mediaMovil>80){ 
033A4:  MOVF   x95,W
033A6:  SUBLW  50
033A8:  BC    33E8
....................       mediaMovil=40;write_eeprom(57,60);delay_ms(10); 
033AA:  MOVLW  28
033AC:  MOVWF  x95
033AE:  CLRF   FAA
033B0:  MOVLW  39
033B2:  MOVWF  FA9
033B4:  MOVLW  3C
033B6:  MOVWF  FA8
033B8:  BCF    FA6.6
033BA:  BCF    FA6.7
033BC:  BSF    FA6.2
033BE:  MOVF   FF2,W
033C0:  MOVWF  00
033C2:  BCF    FF2.6
033C4:  BCF    FF2.7
033C6:  MOVLB  F
033C8:  MOVLW  55
033CA:  MOVWF  FA7
033CC:  MOVLW  AA
033CE:  MOVWF  FA7
033D0:  BSF    FA6.1
033D2:  BTFSC  FA6.1
033D4:  BRA    33D2
033D6:  BCF    FA6.2
033D8:  MOVF   00,W
033DA:  IORWF  FF2,F
033DC:  MOVLW  0A
033DE:  MOVLB  B
033E0:  MOVWF  x22
033E2:  MOVLB  0
033E4:  CALL   11F6
....................    } 
.................... } 
033E8:  GOTO   6500 (RETURN)
....................  
.................... void ApagaSalidas(){ 
....................    Alarma_off; 
*
0517A:  BCF    F8B.0
0517C:  BCF    F94.0
....................    LuzBlanca_off; 
0517E:  BSF    F8C.0
05180:  BCF    F95.0
....................    LuzUV_off; 
05182:  BSF    F8C.1
05184:  BCF    F95.1
....................    Aux_off; 
05186:  BSF    F8C.2
05188:  BCF    F95.2
....................    Toma_off; 
0518A:  BCF    F8B.1
0518C:  BCF    F94.1
....................    Motor_off; 
0518E:  BCF    F8B.3
05190:  BCF    F94.3
....................    Motor2_off; 
05192:  BCF    F8B.2
05194:  BCF    F94.2
.................... } 
05196:  RETLW  00
....................  
.................... void dibujaBarraDn(){ 
....................    if(barra>=0 && barra<=25){ 
*
05666:  MOVLB  B
05668:  CLRF   x22
0566A:  CLRF   x21
0566C:  CLRF   x20
0566E:  CLRF   x1F
05670:  MOVFF  110,B26
05674:  MOVFF  10F,B25
05678:  MOVFF  10E,B24
0567C:  MOVFF  10D,B23
05680:  MOVLB  0
05682:  CALL   241C
05686:  BC    568C
05688:  BTFSS  FD8.2
0568A:  BRA    5788
0568C:  MOVFF  110,B22
05690:  MOVFF  10F,B21
05694:  MOVFF  10E,B20
05698:  MOVFF  10D,B1F
0569C:  MOVLB  B
0569E:  CLRF   x26
056A0:  CLRF   x25
056A2:  MOVLW  48
056A4:  MOVWF  x24
056A6:  MOVLW  83
056A8:  MOVWF  x23
056AA:  MOVLB  0
056AC:  CALL   241C
056B0:  BC    56B4
056B2:  BNZ   5788
....................          printf("j0.val=%u",(int8)((barra*100)/25)); 
056B4:  MOVFF  110,B26
056B8:  MOVFF  10F,B25
056BC:  MOVFF  10E,B24
056C0:  MOVFF  10D,B23
056C4:  MOVLB  B
056C6:  CLRF   x2A
056C8:  CLRF   x29
056CA:  MOVLW  48
056CC:  MOVWF  x28
056CE:  MOVLW  85
056D0:  MOVWF  x27
056D2:  MOVLB  0
056D4:  CALL   3908
056D8:  MOVFF  00,B00
056DC:  MOVFF  01,B01
056E0:  MOVFF  02,B02
056E4:  MOVFF  03,B03
056E8:  MOVFF  03,B22
056EC:  MOVFF  02,B21
056F0:  MOVFF  01,B20
056F4:  MOVFF  00,B1F
056F8:  MOVLB  B
056FA:  CLRF   x26
056FC:  CLRF   x25
056FE:  MOVLW  48
05700:  MOVWF  x24
05702:  MOVLW  83
05704:  MOVWF  x23
05706:  MOVLB  0
05708:  CALL   13A2
0570C:  MOVFF  03,B03
05710:  MOVFF  02,B02
05714:  MOVFF  01,B01
05718:  MOVFF  00,B00
0571C:  RCALL  513E
0571E:  MOVFF  01,B00
05722:  MOVLW  5C
05724:  MOVWF  FF6
05726:  MOVLW  01
05728:  MOVWF  FF7
0572A:  MOVLW  00
0572C:  MOVWF  FF8
0572E:  MOVLW  07
05730:  MOVLB  B
05732:  MOVWF  x02
05734:  MOVLB  0
05736:  RCALL  5198
05738:  MOVFF  B00,B01
0573C:  MOVLW  1B
0573E:  MOVLB  B
05740:  MOVWF  x02
05742:  MOVLB  0
05744:  RCALL  51F6
....................          SendDataDisplay(); 
05746:  CALL   1336
....................          printf("j1.val=0"); 
0574A:  MOVLW  66
0574C:  MOVWF  FF6
0574E:  MOVLW  01
05750:  MOVWF  FF7
05752:  MOVLW  00
05754:  MOVWF  FF8
05756:  CALL   1304
....................          SendDataDisplay(); 
0575A:  CALL   1336
....................          printf("j2.val=0"); 
0575E:  MOVLW  70
05760:  MOVWF  FF6
05762:  MOVLW  01
05764:  MOVWF  FF7
05766:  MOVLW  00
05768:  MOVWF  FF8
0576A:  CALL   1304
....................          SendDataDisplay(); 
0576E:  CALL   1336
....................          printf("j3.val=0"); 
05772:  MOVLW  7A
05774:  MOVWF  FF6
05776:  MOVLW  01
05778:  MOVWF  FF7
0577A:  MOVLW  00
0577C:  MOVWF  FF8
0577E:  CALL   1304
....................          SendDataDisplay(); 
05782:  CALL   1336
....................       }else if(barra>25 && barra<=50){ 
05786:  BRA    5BA6
05788:  MOVLB  B
0578A:  CLRF   x22
0578C:  CLRF   x21
0578E:  MOVLW  48
05790:  MOVWF  x20
05792:  MOVLW  83
05794:  MOVWF  x1F
05796:  MOVFF  110,B26
0579A:  MOVFF  10F,B25
0579E:  MOVFF  10E,B24
057A2:  MOVFF  10D,B23
057A6:  MOVLB  0
057A8:  CALL   241C
057AC:  BTFSS  FD8.0
057AE:  BRA    58E4
057B0:  MOVFF  110,B22
057B4:  MOVFF  10F,B21
057B8:  MOVFF  10E,B20
057BC:  MOVFF  10D,B1F
057C0:  MOVLB  B
057C2:  CLRF   x26
057C4:  CLRF   x25
057C6:  MOVLW  48
057C8:  MOVWF  x24
057CA:  MOVLW  84
057CC:  MOVWF  x23
057CE:  MOVLB  0
057D0:  CALL   241C
057D4:  BC    57DA
057D6:  BTFSS  FD8.2
057D8:  BRA    58E4
....................          printf("j1.val=%u",(int8)(((barra*100)/25)-100)); 
057DA:  MOVFF  110,B26
057DE:  MOVFF  10F,B25
057E2:  MOVFF  10E,B24
057E6:  MOVFF  10D,B23
057EA:  MOVLB  B
057EC:  CLRF   x2A
057EE:  CLRF   x29
057F0:  MOVLW  48
057F2:  MOVWF  x28
057F4:  MOVLW  85
057F6:  MOVWF  x27
057F8:  MOVLB  0
057FA:  CALL   3908
057FE:  MOVFF  00,B00
05802:  MOVFF  01,B01
05806:  MOVFF  02,B02
0580A:  MOVFF  03,B03
0580E:  MOVFF  03,B22
05812:  MOVFF  02,B21
05816:  MOVFF  01,B20
0581A:  MOVFF  00,B1F
0581E:  MOVLB  B
05820:  CLRF   x26
05822:  CLRF   x25
05824:  MOVLW  48
05826:  MOVWF  x24
05828:  MOVLW  83
0582A:  MOVWF  x23
0582C:  MOVLB  0
0582E:  CALL   13A2
05832:  MOVFF  00,B00
05836:  MOVFF  01,B01
0583A:  MOVFF  02,B02
0583E:  MOVFF  03,B03
05842:  BSF    FD8.1
05844:  MOVFF  03,B26
05848:  MOVFF  02,B25
0584C:  MOVFF  01,B24
05850:  MOVFF  00,B23
05854:  MOVLB  B
05856:  CLRF   x2A
05858:  CLRF   x29
0585A:  MOVLW  48
0585C:  MOVWF  x28
0585E:  MOVLW  85
05860:  MOVWF  x27
05862:  MOVLB  0
05864:  CALL   1500
05868:  MOVFF  03,B03
0586C:  MOVFF  02,B02
05870:  MOVFF  01,B01
05874:  MOVFF  00,B00
05878:  RCALL  513E
0587A:  MOVFF  01,B00
0587E:  MOVLW  84
05880:  MOVWF  FF6
05882:  MOVLW  01
05884:  MOVWF  FF7
05886:  MOVLW  00
05888:  MOVWF  FF8
0588A:  MOVLW  07
0588C:  MOVLB  B
0588E:  MOVWF  x02
05890:  MOVLB  0
05892:  RCALL  5198
05894:  MOVFF  B00,B01
05898:  MOVLW  1B
0589A:  MOVLB  B
0589C:  MOVWF  x02
0589E:  MOVLB  0
058A0:  RCALL  51F6
....................          SendDataDisplay(); 
058A2:  CALL   1336
....................          printf("j0.val=100"); 
058A6:  MOVLW  8E
058A8:  MOVWF  FF6
058AA:  MOVLW  01
058AC:  MOVWF  FF7
058AE:  MOVLW  00
058B0:  MOVWF  FF8
058B2:  CALL   1304
....................          SendDataDisplay(); 
058B6:  CALL   1336
....................          printf("j2.val=0"); 
058BA:  MOVLW  9A
058BC:  MOVWF  FF6
058BE:  MOVLW  01
058C0:  MOVWF  FF7
058C2:  MOVLW  00
058C4:  MOVWF  FF8
058C6:  CALL   1304
....................          SendDataDisplay(); 
058CA:  CALL   1336
....................          printf("j3.val=0"); 
058CE:  MOVLW  A4
058D0:  MOVWF  FF6
058D2:  MOVLW  01
058D4:  MOVWF  FF7
058D6:  MOVLW  00
058D8:  MOVWF  FF8
058DA:  CALL   1304
....................          SendDataDisplay(); 
058DE:  CALL   1336
....................       }else if(barra>50 && barra<=75){ 
058E2:  BRA    5BA6
058E4:  MOVLB  B
058E6:  CLRF   x22
058E8:  CLRF   x21
058EA:  MOVLW  48
058EC:  MOVWF  x20
058EE:  MOVLW  84
058F0:  MOVWF  x1F
058F2:  MOVFF  110,B26
058F6:  MOVFF  10F,B25
058FA:  MOVFF  10E,B24
058FE:  MOVFF  10D,B23
05902:  MOVLB  0
05904:  CALL   241C
05908:  BTFSS  FD8.0
0590A:  BRA    5A46
0590C:  MOVFF  110,B22
05910:  MOVFF  10F,B21
05914:  MOVFF  10E,B20
05918:  MOVFF  10D,B1F
0591C:  MOVLB  B
0591E:  CLRF   x26
05920:  CLRF   x25
05922:  MOVLW  16
05924:  MOVWF  x24
05926:  MOVLW  85
05928:  MOVWF  x23
0592A:  MOVLB  0
0592C:  CALL   241C
05930:  BC    5936
05932:  BTFSS  FD8.2
05934:  BRA    5A46
....................          printf("j2.val=%u",(int8)(((barra*100)/25)-200)); 
05936:  MOVFF  110,B26
0593A:  MOVFF  10F,B25
0593E:  MOVFF  10E,B24
05942:  MOVFF  10D,B23
05946:  MOVLB  B
05948:  CLRF   x2A
0594A:  CLRF   x29
0594C:  MOVLW  48
0594E:  MOVWF  x28
05950:  MOVLW  85
05952:  MOVWF  x27
05954:  MOVLB  0
05956:  CALL   3908
0595A:  MOVFF  00,B00
0595E:  MOVFF  01,B01
05962:  MOVFF  02,B02
05966:  MOVFF  03,B03
0596A:  MOVFF  03,B22
0596E:  MOVFF  02,B21
05972:  MOVFF  01,B20
05976:  MOVFF  00,B1F
0597A:  MOVLB  B
0597C:  CLRF   x26
0597E:  CLRF   x25
05980:  MOVLW  48
05982:  MOVWF  x24
05984:  MOVLW  83
05986:  MOVWF  x23
05988:  MOVLB  0
0598A:  CALL   13A2
0598E:  MOVFF  00,B00
05992:  MOVFF  01,B01
05996:  MOVFF  02,B02
0599A:  MOVFF  03,B03
0599E:  BSF    FD8.1
059A0:  MOVFF  03,B26
059A4:  MOVFF  02,B25
059A8:  MOVFF  01,B24
059AC:  MOVFF  00,B23
059B0:  MOVLB  B
059B2:  CLRF   x2A
059B4:  CLRF   x29
059B6:  MOVLW  48
059B8:  MOVWF  x28
059BA:  MOVLW  86
059BC:  MOVWF  x27
059BE:  MOVLB  0
059C0:  CALL   1500
059C4:  MOVFF  03,B03
059C8:  MOVFF  02,B02
059CC:  MOVFF  01,B01
059D0:  MOVFF  00,B00
059D4:  CALL   513E
059D8:  MOVFF  01,B00
059DC:  MOVLW  AE
059DE:  MOVWF  FF6
059E0:  MOVLW  01
059E2:  MOVWF  FF7
059E4:  MOVLW  00
059E6:  MOVWF  FF8
059E8:  MOVLW  07
059EA:  MOVLB  B
059EC:  MOVWF  x02
059EE:  MOVLB  0
059F0:  CALL   5198
059F4:  MOVFF  B00,B01
059F8:  MOVLW  1B
059FA:  MOVLB  B
059FC:  MOVWF  x02
059FE:  MOVLB  0
05A00:  CALL   51F6
....................          SendDataDisplay(); 
05A04:  CALL   1336
....................          printf("j0.val=100"); 
05A08:  MOVLW  B8
05A0A:  MOVWF  FF6
05A0C:  MOVLW  01
05A0E:  MOVWF  FF7
05A10:  MOVLW  00
05A12:  MOVWF  FF8
05A14:  CALL   1304
....................          SendDataDisplay(); 
05A18:  CALL   1336
....................          printf("j1.val=100"); 
05A1C:  MOVLW  C4
05A1E:  MOVWF  FF6
05A20:  MOVLW  01
05A22:  MOVWF  FF7
05A24:  MOVLW  00
05A26:  MOVWF  FF8
05A28:  CALL   1304
....................          SendDataDisplay(); 
05A2C:  CALL   1336
....................          printf("j3.val=0"); 
05A30:  MOVLW  D0
05A32:  MOVWF  FF6
05A34:  MOVLW  01
05A36:  MOVWF  FF7
05A38:  MOVLW  00
05A3A:  MOVWF  FF8
05A3C:  CALL   1304
....................          SendDataDisplay(); 
05A40:  CALL   1336
....................       }else if(barra>75 && barra<=100){ 
05A44:  BRA    5BA6
05A46:  MOVLB  B
05A48:  CLRF   x22
05A4A:  CLRF   x21
05A4C:  MOVLW  16
05A4E:  MOVWF  x20
05A50:  MOVLW  85
05A52:  MOVWF  x1F
05A54:  MOVFF  110,B26
05A58:  MOVFF  10F,B25
05A5C:  MOVFF  10E,B24
05A60:  MOVFF  10D,B23
05A64:  MOVLB  0
05A66:  CALL   241C
05A6A:  BTFSS  FD8.0
05A6C:  BRA    5BA6
05A6E:  MOVFF  110,B22
05A72:  MOVFF  10F,B21
05A76:  MOVFF  10E,B20
05A7A:  MOVFF  10D,B1F
05A7E:  MOVLB  B
05A80:  CLRF   x26
05A82:  CLRF   x25
05A84:  MOVLW  48
05A86:  MOVWF  x24
05A88:  MOVLW  85
05A8A:  MOVWF  x23
05A8C:  MOVLB  0
05A8E:  CALL   241C
05A92:  BC    5A98
05A94:  BTFSS  FD8.2
05A96:  BRA    5BA6
....................          printf("j3.val=%u",(int8)(((barra*100)/25)-300)); 
05A98:  MOVFF  110,B26
05A9C:  MOVFF  10F,B25
05AA0:  MOVFF  10E,B24
05AA4:  MOVFF  10D,B23
05AA8:  MOVLB  B
05AAA:  CLRF   x2A
05AAC:  CLRF   x29
05AAE:  MOVLW  48
05AB0:  MOVWF  x28
05AB2:  MOVLW  85
05AB4:  MOVWF  x27
05AB6:  MOVLB  0
05AB8:  CALL   3908
05ABC:  MOVFF  00,B00
05AC0:  MOVFF  01,B01
05AC4:  MOVFF  02,B02
05AC8:  MOVFF  03,B03
05ACC:  MOVFF  03,B22
05AD0:  MOVFF  02,B21
05AD4:  MOVFF  01,B20
05AD8:  MOVFF  00,B1F
05ADC:  MOVLB  B
05ADE:  CLRF   x26
05AE0:  CLRF   x25
05AE2:  MOVLW  48
05AE4:  MOVWF  x24
05AE6:  MOVLW  83
05AE8:  MOVWF  x23
05AEA:  MOVLB  0
05AEC:  CALL   13A2
05AF0:  MOVFF  00,B00
05AF4:  MOVFF  01,B01
05AF8:  MOVFF  02,B02
05AFC:  MOVFF  03,B03
05B00:  BSF    FD8.1
05B02:  MOVFF  03,B26
05B06:  MOVFF  02,B25
05B0A:  MOVFF  01,B24
05B0E:  MOVFF  00,B23
05B12:  MOVLB  B
05B14:  CLRF   x2A
05B16:  CLRF   x29
05B18:  MOVLW  16
05B1A:  MOVWF  x28
05B1C:  MOVLW  87
05B1E:  MOVWF  x27
05B20:  MOVLB  0
05B22:  CALL   1500
05B26:  MOVFF  03,B03
05B2A:  MOVFF  02,B02
05B2E:  MOVFF  01,B01
05B32:  MOVFF  00,B00
05B36:  CALL   513E
05B3A:  MOVFF  01,B00
05B3E:  MOVLW  DA
05B40:  MOVWF  FF6
05B42:  MOVLW  01
05B44:  MOVWF  FF7
05B46:  MOVLW  00
05B48:  MOVWF  FF8
05B4A:  MOVLW  07
05B4C:  MOVLB  B
05B4E:  MOVWF  x02
05B50:  MOVLB  0
05B52:  CALL   5198
05B56:  MOVFF  B00,B01
05B5A:  MOVLW  1B
05B5C:  MOVLB  B
05B5E:  MOVWF  x02
05B60:  MOVLB  0
05B62:  CALL   51F6
....................          SendDataDisplay(); 
05B66:  CALL   1336
....................          printf("j0.val=100"); 
05B6A:  MOVLW  E4
05B6C:  MOVWF  FF6
05B6E:  MOVLW  01
05B70:  MOVWF  FF7
05B72:  MOVLW  00
05B74:  MOVWF  FF8
05B76:  CALL   1304
....................          SendDataDisplay(); 
05B7A:  CALL   1336
....................          printf("j1.val=100"); 
05B7E:  MOVLW  F0
05B80:  MOVWF  FF6
05B82:  MOVLW  01
05B84:  MOVWF  FF7
05B86:  MOVLW  00
05B88:  MOVWF  FF8
05B8A:  CALL   1304
....................          SendDataDisplay(); 
05B8E:  CALL   1336
....................          printf("j2.val=100"); 
05B92:  MOVLW  FC
05B94:  MOVWF  FF6
05B96:  MOVLW  01
05B98:  MOVWF  FF7
05B9A:  MOVLW  00
05B9C:  MOVWF  FF8
05B9E:  CALL   1304
....................          SendDataDisplay(); 
05BA2:  CALL   1336
....................       } 
.................... } 
05BA6:  GOTO   83A2 (RETURN)
....................  
.................... void dibujaBarraIn(){ 
....................    if(barra>=0 && barra<=25){ 
....................          printf("j4.val=%u",(int8)((barra*100)/25)); 
....................          SendDataDisplay(); 
....................          printf("j5.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>25 && barra<=50){ 
....................          printf("j5.val=%u",(int8)(((barra*100)/25)-100)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=0"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>50 && barra<=75){ 
....................          printf("j6.val=%u",(int8)(((barra*100)/25)-200)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j5.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j7.val=0"); 
....................          SendDataDisplay(); 
....................       }else if(barra>75 && barra<=100){ 
....................          printf("j7.val=%u",(int8)(((barra*100)/25)-100)); 
....................          SendDataDisplay(); 
....................          printf("j4.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j5.val=100"); 
....................          SendDataDisplay(); 
....................          printf("j6.val=100"); 
....................          SendDataDisplay(); 
....................       } 
.................... }   
....................  
.................... void cambiaColor(int16 col){ 
....................    printf("Principal.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fecha.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("estado.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fex.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("fdown.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("t3.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("t2.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("pdown.bco=%Lu",col); 
....................    SendDataDisplay();  
....................    printf("pex.bco=%Lu",col); 
....................    SendDataDisplay();  
.................... } 
....................  
.................... void bajarVidrio(){ 
....................    pulsoSubir=OFF; 
*
03430:  BCF    x7D.7
....................    if(VIDRIOUUP || !VIDRIODN){ 
03432:  BSF    F96.2
03434:  BTFSS  F84.2
03436:  BRA    343E
03438:  BSF    F96.0
0343A:  BTFSS  F84.0
0343C:  BRA    3448
....................       O1_on;O2_off; 
0343E:  BSF    F8C.7
03440:  BCF    F95.7
03442:  BCF    F8C.6
03444:  BCF    F95.6
....................    }else{ 
03446:  BRA    3452
....................       O1_off;O2_off; 
03448:  BCF    F8C.7
0344A:  BCF    F95.7
0344C:  BCF    F8C.6
0344E:  BCF    F95.6
....................       pulsoBajar=OFF; 
03450:  BCF    x7E.0
....................    } 
.................... } 
03452:  RETLW  00
....................  
.................... void subirVidrio(){ 
....................    pulsoBajar=OFF; 
03454:  BCF    x7E.0
....................    if(!VIDRIOUUP || VIDRIODN){ 
03456:  BSF    F96.2
03458:  BTFSC  F84.2
0345A:  BRA    3462
0345C:  BSF    F96.0
0345E:  BTFSC  F84.0
03460:  BRA    346C
....................       O1_off;O2_on; 
03462:  BCF    F8C.7
03464:  BCF    F95.7
03466:  BSF    F8C.6
03468:  BCF    F95.6
....................    }else{ 
0346A:  BRA    3476
....................       O1_off;O2_off; 
0346C:  BCF    F8C.7
0346E:  BCF    F95.7
03470:  BCF    F8C.6
03472:  BCF    F95.6
....................       pulsoSubir=OFF; 
03474:  BCF    x7D.7
....................    } 
.................... } 
03476:  RETLW  00
....................  
.................... void detenerVidrio(){ 
....................    O1_off;O2_off; 
*
05274:  BCF    F8C.7
05276:  BCF    F95.7
05278:  BCF    F8C.6
0527A:  BCF    F95.6
.................... } 
0527C:  RETLW  00
....................  
.................... void leeControlRemoto(){ 
....................    if(NUEVO_DATO==1){ 
*
03478:  BTFSS  x80.6
0347A:  BRA    36D4
....................       NUEVO_DATO=0; 
0347C:  BCF    x80.6
....................       BYTE_IR[0]=BIT_BYTE(BITS[0],BITS[1],BITS[2],BITS[3],BITS[4],BITS[5],BITS[6],BITS[7]); 
0347E:  MOVLW  00
03480:  MOVLB  2
03482:  BTFSC  xD5.0
03484:  MOVLW  01
03486:  MOVLB  B
03488:  MOVWF  x00
0348A:  MOVLW  00
0348C:  MOVLB  2
0348E:  BTFSC  xD5.1
03490:  MOVLW  01
03492:  MOVLB  B
03494:  MOVWF  x01
03496:  MOVLW  00
03498:  MOVLB  2
0349A:  BTFSC  xD5.2
0349C:  MOVLW  01
0349E:  MOVLB  B
034A0:  MOVWF  x02
034A2:  MOVLW  00
034A4:  MOVLB  2
034A6:  BTFSC  xD5.3
034A8:  MOVLW  01
034AA:  MOVLB  B
034AC:  MOVWF  x03
034AE:  MOVLW  00
034B0:  MOVLB  2
034B2:  BTFSC  xD5.4
034B4:  MOVLW  01
034B6:  MOVLB  B
034B8:  MOVWF  x04
034BA:  MOVLW  00
034BC:  MOVLB  2
034BE:  BTFSC  xD5.5
034C0:  MOVLW  01
034C2:  MOVLB  B
034C4:  MOVWF  x05
034C6:  MOVLW  00
034C8:  MOVLB  2
034CA:  BTFSC  xD5.6
034CC:  MOVLW  01
034CE:  MOVLB  B
034D0:  MOVWF  x06
034D2:  MOVLW  00
034D4:  MOVLB  2
034D6:  BTFSC  xD5.7
034D8:  MOVLW  01
034DA:  MOVLB  B
034DC:  MOVWF  x07
034DE:  MOVFF  B00,B08
034E2:  MOVFF  B01,B09
034E6:  MOVFF  B02,B0A
034EA:  MOVFF  B03,B0B
034EE:  MOVFF  B04,B0C
034F2:  MOVFF  B05,B0D
034F6:  MOVFF  B06,B0E
034FA:  MOVWF  x0F
034FC:  MOVLB  0
034FE:  RCALL  33EC
03500:  MOVFF  01,2DF
....................       BYTE_IR[1]=BIT_BYTE(BITS[8],BITS[9],BITS[10],BITS[11],BITS[12],BITS[13],BITS[14],BITS[15]); 
03504:  MOVLW  00
03506:  MOVLB  2
03508:  BTFSC  xD6.0
0350A:  MOVLW  01
0350C:  MOVLB  B
0350E:  MOVWF  x00
03510:  MOVLW  00
03512:  MOVLB  2
03514:  BTFSC  xD6.1
03516:  MOVLW  01
03518:  MOVLB  B
0351A:  MOVWF  x01
0351C:  MOVLW  00
0351E:  MOVLB  2
03520:  BTFSC  xD6.2
03522:  MOVLW  01
03524:  MOVLB  B
03526:  MOVWF  x02
03528:  MOVLW  00
0352A:  MOVLB  2
0352C:  BTFSC  xD6.3
0352E:  MOVLW  01
03530:  MOVLB  B
03532:  MOVWF  x03
03534:  MOVLW  00
03536:  MOVLB  2
03538:  BTFSC  xD6.4
0353A:  MOVLW  01
0353C:  MOVLB  B
0353E:  MOVWF  x04
03540:  MOVLW  00
03542:  MOVLB  2
03544:  BTFSC  xD6.5
03546:  MOVLW  01
03548:  MOVLB  B
0354A:  MOVWF  x05
0354C:  MOVLW  00
0354E:  MOVLB  2
03550:  BTFSC  xD6.6
03552:  MOVLW  01
03554:  MOVLB  B
03556:  MOVWF  x06
03558:  MOVLW  00
0355A:  MOVLB  2
0355C:  BTFSC  xD6.7
0355E:  MOVLW  01
03560:  MOVLB  B
03562:  MOVWF  x07
03564:  MOVFF  B00,B08
03568:  MOVFF  B01,B09
0356C:  MOVFF  B02,B0A
03570:  MOVFF  B03,B0B
03574:  MOVFF  B04,B0C
03578:  MOVFF  B05,B0D
0357C:  MOVFF  B06,B0E
03580:  MOVWF  x0F
03582:  MOVLB  0
03584:  RCALL  33EC
03586:  MOVFF  01,2E0
....................       BYTE_IR[2]=BIT_BYTE(BITS[16],BITS[17],BITS[18],BITS[19],BITS[20],BITS[21],BITS[22],BITS[23]); 
0358A:  MOVLW  00
0358C:  MOVLB  2
0358E:  BTFSC  xD7.0
03590:  MOVLW  01
03592:  MOVLB  B
03594:  MOVWF  x00
03596:  MOVLW  00
03598:  MOVLB  2
0359A:  BTFSC  xD7.1
0359C:  MOVLW  01
0359E:  MOVLB  B
035A0:  MOVWF  x01
035A2:  MOVLW  00
035A4:  MOVLB  2
035A6:  BTFSC  xD7.2
035A8:  MOVLW  01
035AA:  MOVLB  B
035AC:  MOVWF  x02
035AE:  MOVLW  00
035B0:  MOVLB  2
035B2:  BTFSC  xD7.3
035B4:  MOVLW  01
035B6:  MOVLB  B
035B8:  MOVWF  x03
035BA:  MOVLW  00
035BC:  MOVLB  2
035BE:  BTFSC  xD7.4
035C0:  MOVLW  01
035C2:  MOVLB  B
035C4:  MOVWF  x04
035C6:  MOVLW  00
035C8:  MOVLB  2
035CA:  BTFSC  xD7.5
035CC:  MOVLW  01
035CE:  MOVLB  B
035D0:  MOVWF  x05
035D2:  MOVLW  00
035D4:  MOVLB  2
035D6:  BTFSC  xD7.6
035D8:  MOVLW  01
035DA:  MOVLB  B
035DC:  MOVWF  x06
035DE:  MOVLW  00
035E0:  MOVLB  2
035E2:  BTFSC  xD7.7
035E4:  MOVLW  01
035E6:  MOVLB  B
035E8:  MOVWF  x07
035EA:  MOVFF  B00,B08
035EE:  MOVFF  B01,B09
035F2:  MOVFF  B02,B0A
035F6:  MOVFF  B03,B0B
035FA:  MOVFF  B04,B0C
035FE:  MOVFF  B05,B0D
03602:  MOVFF  B06,B0E
03606:  MOVWF  x0F
03608:  MOVLB  0
0360A:  RCALL  33EC
0360C:  MOVFF  01,2E1
....................       BYTE_IR[3]=BIT_BYTE(BITS[24],BITS[25],BITS[26],BITS[27],BITS[28],BITS[29],BITS[30],BITS[31]); 
03610:  MOVLW  00
03612:  MOVLB  2
03614:  BTFSC  xD8.0
03616:  MOVLW  01
03618:  MOVLB  B
0361A:  MOVWF  x00
0361C:  MOVLW  00
0361E:  MOVLB  2
03620:  BTFSC  xD8.1
03622:  MOVLW  01
03624:  MOVLB  B
03626:  MOVWF  x01
03628:  MOVLW  00
0362A:  MOVLB  2
0362C:  BTFSC  xD8.2
0362E:  MOVLW  01
03630:  MOVLB  B
03632:  MOVWF  x02
03634:  MOVLW  00
03636:  MOVLB  2
03638:  BTFSC  xD8.3
0363A:  MOVLW  01
0363C:  MOVLB  B
0363E:  MOVWF  x03
03640:  MOVLW  00
03642:  MOVLB  2
03644:  BTFSC  xD8.4
03646:  MOVLW  01
03648:  MOVLB  B
0364A:  MOVWF  x04
0364C:  MOVLW  00
0364E:  MOVLB  2
03650:  BTFSC  xD8.5
03652:  MOVLW  01
03654:  MOVLB  B
03656:  MOVWF  x05
03658:  MOVLW  00
0365A:  MOVLB  2
0365C:  BTFSC  xD8.6
0365E:  MOVLW  01
03660:  MOVLB  B
03662:  MOVWF  x06
03664:  MOVLW  00
03666:  MOVLB  2
03668:  BTFSC  xD8.7
0366A:  MOVLW  01
0366C:  MOVLB  B
0366E:  MOVWF  x07
03670:  MOVFF  B00,B08
03674:  MOVFF  B01,B09
03678:  MOVFF  B02,B0A
0367C:  MOVFF  B03,B0B
03680:  MOVFF  B04,B0C
03684:  MOVFF  B05,B0D
03688:  MOVFF  B06,B0E
0368C:  MOVWF  x0F
0368E:  MOVLB  0
03690:  RCALL  33EC
03692:  MOVFF  01,2E2
....................     
....................       if(BYTE_IR[3]==codigoBajar){ //Bajar Vidrio  //AD 
03696:  MOVF   x88,W
03698:  MOVLB  2
0369A:  SUBWF  xE2,W
0369C:  BNZ   36A6
....................          pulsoBajar=ON; 
0369E:  MOVLB  0
036A0:  BSF    x7E.0
....................          RX_Buffer[4]=0x00; 
036A2:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036A4:  CLRF   40
....................       } 
....................        
....................       if(BYTE_IR[3]==codigoSubir){ // Subir Vidrio //E7 
036A6:  MOVLB  0
036A8:  MOVF   x87,W
036AA:  MOVLB  2
036AC:  SUBWF  xE2,W
036AE:  BNZ   36B8
....................          pulsoSubir=ON; 
036B0:  MOVLB  0
036B2:  BSF    x7D.7
....................          RX_Buffer[4]=0x00; 
036B4:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036B6:  CLRF   40
....................       } 
....................       
....................       if(BYTE_IR[3]==codigoDetener){ //F7 E3 A5 
036B8:  MOVLB  0
036BA:  MOVF   x89,W
036BC:  MOVLB  2
036BE:  SUBWF  xE2,W
036C0:  BNZ   36D6
....................          O1_off;O2_off; 
036C2:  BCF    F8C.7
036C4:  BCF    F95.7
036C6:  BCF    F8C.6
036C8:  BCF    F95.6
....................          pulsoSubir=OFF; 
036CA:  MOVLB  0
036CC:  BCF    x7D.7
....................          pulsoBajar=OFF; 
036CE:  BCF    x7E.0
....................          RX_Buffer[4]=0x00; 
036D0:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
036D2:  CLRF   40
036D4:  MOVLB  2
....................       } 
....................    } 
....................     
....................    if(pulsoBajar) 
036D6:  MOVLB  0
036D8:  BTFSS  x7E.0
036DA:  BRA    36DE
....................       bajarVidrio(); 
036DC:  RCALL  3430
....................        
....................    if(pulsoSubir) 
036DE:  BTFSS  x7D.7
036E0:  BRA    36E4
....................       subirVidrio();     
036E2:  RCALL  3454
....................       
.................... } 
036E4:  GOTO   651C (RETURN)
....................  
.................... void ubicaVidrio20cm(){   
....................       if(VIDRIOUUP){ 
*
0527E:  BSF    F96.2
05280:  BTFSC  F84.2
05282:  BRA    528A
....................           flag_arriba=ON; 
05284:  BSF    x7E.1
....................           bajarVidrio(); // Baja Vidrio          
05286:  CALL   3430
....................       } 
....................          
....................       if(flag_arriba){ 
0528A:  BTFSS  x7E.1
0528C:  BRA    52CC
....................          bajarVidrio(); // Baja Vidrio          
0528E:  CALL   3430
....................           
....................          if(VIDRIOUP || VIDRIODN) 
05292:  BSF    F96.1
05294:  BTFSS  F84.1
05296:  BRA    529E
05298:  BSF    F96.0
0529A:  BTFSC  F84.0
0529C:  BRA    52A0
....................             flag_arriba=OFF; 
0529E:  BCF    x7E.1
....................          
....................          if(VIDRIOUP && !VIDRIODN)    
052A0:  BSF    F96.1
052A2:  BTFSC  F84.1
052A4:  BRA    52AE
052A6:  BSF    F96.0
052A8:  BTFSS  F84.0
052AA:  BRA    52AE
....................             flag_arriba=OFF; 
052AC:  BCF    x7E.1
....................              
....................          if(VIDRIOUP && VIDRIODN) 
052AE:  BSF    F96.1
052B0:  BTFSC  F84.1
052B2:  BRA    52BC
052B4:  BSF    F96.0
052B6:  BTFSC  F84.0
052B8:  BRA    52BC
....................             flag_arriba=OFF; 
052BA:  BCF    x7E.1
....................              
....................          if(!VIDRIOUP && VIDRIODN) 
052BC:  BSF    F96.1
052BE:  BTFSS  F84.1
052C0:  BRA    52CA
052C2:  BSF    F96.0
052C4:  BTFSC  F84.0
052C6:  BRA    52CA
....................             flag_arriba=OFF; 
052C8:  BCF    x7E.1
....................       }else{ 
052CA:  BRA    5308
....................          if(!VIDRIOUP && !VIDRIODN){ 
052CC:  BSF    F96.1
052CE:  BTFSS  F84.1
052D0:  BRA    52DC
052D2:  BSF    F96.0
052D4:  BTFSS  F84.0
052D6:  BRA    52DC
....................             subirVidrio(); 
052D8:  CALL   3454
....................          } // Sube Vidrio 
....................          
....................          if(VIDRIOUP && !VIDRIODN){ 
052DC:  BSF    F96.1
052DE:  BTFSC  F84.1
052E0:  BRA    52EA
052E2:  BSF    F96.0
052E4:  BTFSS  F84.0
052E6:  BRA    52EA
....................             detenerVidrio(); 
052E8:  RCALL  5274
....................          } 
....................          
....................          if(VIDRIOUP && VIDRIODN){ 
052EA:  BSF    F96.1
052EC:  BTFSC  F84.1
052EE:  BRA    52F8
052F0:  BSF    F96.0
052F2:  BTFSC  F84.0
052F4:  BRA    52F8
....................             detenerVidrio(); 
052F6:  RCALL  5274
....................          } // Vidrio quieto 
....................              
....................          if(!VIDRIOUP && VIDRIODN){ 
052F8:  BSF    F96.1
052FA:  BTFSS  F84.1
052FC:  BRA    5308
052FE:  BSF    F96.0
05300:  BTFSC  F84.0
05302:  BRA    5308
....................              subirVidrio(); 
05304:  CALL   3454
....................          } // Baja Vidrio 
....................       } 
.................... } 
05308:  GOTO   7E8A (RETURN)
....................  
....................  
.................... #int_EXT1 HIGH 
.................... void RB1(){ 
....................    Ta=get_timer1(); 
*
00372:  MOVF   FCE,W
00374:  MOVLB  2
00376:  MOVWF  xD9
00378:  MOVFF  FCF,2DA
....................    TICK = Ta-tb; 
0037C:  MOVF   xDB,W
0037E:  SUBWF  xD9,W
00380:  MOVWF  xDD
00382:  MOVF   xDC,W
00384:  SUBWFB xDA,W
00386:  MOVWF  xDE
....................    Tb = Ta; 
00388:  MOVFF  2DA,2DC
0038C:  MOVFF  2D9,2DB
....................     
....................    Entro=1; 
00390:  MOVLB  0
00392:  BSF    x7E.5
....................     
....................    if(BIT_START==1){ 
00394:  BTFSS  x80.5
00396:  BRA    0412
....................        //BIT 1 
....................        if(TICK>1200 && TICK < 1600)  // 700 con Pres 4 y 20MHz  
00398:  MOVLB  2
0039A:  MOVF   xDE,W
0039C:  SUBLW  03
0039E:  BC    03D2
003A0:  XORLW  FF
003A2:  BNZ   03AA
003A4:  MOVF   xDD,W
003A6:  SUBLW  B0
003A8:  BC    03D2
003AA:  MOVF   xDE,W
003AC:  SUBLW  06
003AE:  BNC   03D2
003B0:  BNZ   03B8
003B2:  MOVF   xDD,W
003B4:  SUBLW  3F
003B6:  BNC   03D2
....................       { 
....................          BITS[n]=1; n++; 
003B8:  MOVFF  AB,B35
003BC:  MOVLW  01
003BE:  MOVLB  B
003C0:  MOVWF  x36
003C2:  MOVLW  02
003C4:  MOVWF  x38
003C6:  MOVLW  D5
003C8:  MOVWF  x37
003CA:  MOVLB  0
003CC:  RCALL  0330
003CE:  INCF   xAB,F
003D0:  MOVLB  2
....................       } 
....................       //BIT 0 
....................        if(TICK>500 && TICK < 900)  // 350 con Pres 4 y 20MHz  
003D2:  MOVF   xDE,W
003D4:  SUBLW  00
003D6:  BC    0406
003D8:  XORLW  FF
003DA:  BNZ   03E2
003DC:  MOVF   xDD,W
003DE:  SUBLW  F4
003E0:  BC    0406
003E2:  MOVF   xDE,W
003E4:  SUBLW  03
003E6:  BNC   0406
003E8:  BNZ   03F0
003EA:  MOVF   xDD,W
003EC:  SUBLW  83
003EE:  BNC   0406
....................       { 
....................          BITS[n]=0; n++; 
003F0:  MOVFF  AB,B35
003F4:  MOVLB  B
003F6:  CLRF   x36
003F8:  MOVLW  02
003FA:  MOVWF  x38
003FC:  MOVLW  D5
003FE:  MOVWF  x37
00400:  MOVLB  0
00402:  RCALL  0330
00404:  INCF   xAB,F
....................       } 
....................       if(n>=32){ 
00406:  MOVLB  0
00408:  MOVF   xAB,W
0040A:  SUBLW  1F
0040C:  BC    0412
....................          NUEVO_DATO=1; 
0040E:  BSF    x80.6
....................          BIT_START=0; 
00410:  BCF    x80.5
....................       } 
....................     
....................    } 
....................    //BIT START 
....................    if(TICK>3500 && TICK < 7500 && BIT_START==0)  //3500 con Pres 4 y 20MHz  
00412:  MOVLB  2
00414:  MOVF   xDE,W
00416:  SUBLW  0C
00418:  BC    0442
0041A:  XORLW  FF
0041C:  BNZ   0424
0041E:  MOVF   xDD,W
00420:  SUBLW  AC
00422:  BC    0442
00424:  MOVF   xDE,W
00426:  SUBLW  1D
00428:  BNC   0442
0042A:  BNZ   0432
0042C:  MOVF   xDD,W
0042E:  SUBLW  4B
00430:  BNC   0442
00432:  MOVLB  0
00434:  BTFSS  x80.5
00436:  BRA    043C
00438:  MOVLB  2
0043A:  BRA    0442
....................    { 
....................       BIT_START=1; 
0043C:  BSF    x80.5
....................       n=0;  
0043E:  CLRF   xAB
00440:  MOVLB  2
....................    } 
.................... } 
....................  
00442:  BCF    FF0.0
00444:  MOVLB  0
00446:  GOTO   0116
.................... #int_EXT HIGH 
.................... void ext0() {   
....................    Cruce=ON; 
0044A:  BSF    x80.3
....................    Cruce2=ON; 
0044C:  BSF    x7F.4
....................     
....................    if(VelMotor==5){ 
0044E:  MOVLB  2
00450:  MOVF   xD3,W
00452:  SUBLW  05
00454:  BNZ   0466
....................       set_timer0(228); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us 
00456:  CLRF   FD7
00458:  MOVLW  E4
0045A:  MOVWF  FD6
....................       Motor_off;  
0045C:  BCF    F8B.3
0045E:  BCF    F94.3
....................       Motor2_off;  
00460:  BCF    F8B.2
00462:  BCF    F94.2
....................    }else if(VelMotor==4){ 
00464:  BRA    04BA
00466:  MOVF   xD3,W
00468:  SUBLW  04
0046A:  BNZ   047C
....................       set_timer0(201);       
0046C:  CLRF   FD7
0046E:  MOVLW  C9
00470:  MOVWF  FD6
....................       Motor_off;  
00472:  BCF    F8B.3
00474:  BCF    F94.3
....................       Motor2_off;  
00476:  BCF    F8B.2
00478:  BCF    F94.2
....................    }else if(VelMotor==3){ 
0047A:  BRA    04BA
0047C:  MOVF   xD3,W
0047E:  SUBLW  03
00480:  BNZ   0492
....................       set_timer0(180); 
00482:  CLRF   FD7
00484:  MOVLW  B4
00486:  MOVWF  FD6
....................       Motor_off;  
00488:  BCF    F8B.3
0048A:  BCF    F94.3
....................       Motor2_off;  
0048C:  BCF    F8B.2
0048E:  BCF    F94.2
....................    }else if(VelMotor==2){ 
00490:  BRA    04BA
00492:  MOVF   xD3,W
00494:  SUBLW  02
00496:  BNZ   04A8
....................       set_timer0(165); 
00498:  CLRF   FD7
0049A:  MOVLW  A5
0049C:  MOVWF  FD6
....................       Motor_off;  
0049E:  BCF    F8B.3
004A0:  BCF    F94.3
....................       Motor2_off;  
004A2:  BCF    F8B.2
004A4:  BCF    F94.2
....................    }else if(VelMotor==1){ 
004A6:  BRA    04BA
004A8:  DECFSZ xD3,W
004AA:  BRA    04BA
....................       set_timer0(150); 
004AC:  CLRF   FD7
004AE:  MOVLW  96
004B0:  MOVWF  FD6
....................       Motor_off;  
004B2:  BCF    F8B.3
004B4:  BCF    F94.3
....................       Motor2_off;  
004B6:  BCF    F8B.2
004B8:  BCF    F94.2
....................    } 
....................    /* 
....................    if(VelMotor2==5){ 
....................       set_timer1(64668); // Cada cuenta del timer0 es 51.2us y timer1 es 1.59us       
....................       Motor2_off;       
....................    }else if(VelMotor2==4){ 
....................       set_timer1(63801);       
....................       Motor2_off;  
....................    }else if(VelMotor2==3){ 
....................       set_timer1(62934); 
....................       Motor2_off;  
....................    }else if(VelMotor2==2){ 
....................       set_timer1(62067);       
....................       Motor2_off;  
....................    }else if(VelMotor2==1){ 
....................       set_timer1(61200);       
....................       Motor2_off;  
....................    } 
....................    */ 
....................    pulsos++;    
004BA:  INCF   xCD,F
004BC:  BTFSC  FD8.2
004BE:  INCF   xCE,F
.................... } 
....................  
004C0:  BCF    FF2.1
004C2:  MOVLB  0
004C4:  GOTO   0116
.................... #int_TIMER0 HIGH 
.................... void temp0s(void){ 
....................    if(VelMotor>0 && VelMotor<6){ 
004C8:  MOVLB  2
004CA:  MOVF   xD3,F
004CC:  BZ    04FA
004CE:  MOVF   xD3,W
004D0:  SUBLW  05
004D2:  BNC   04FA
....................    if(Cruce){         //If the triac pin is low we change the state and prepare the timer 
004D4:  MOVLB  0
004D6:  BTFSS  x80.3
004D8:  BRA    04EC
....................       Motor_on; 
004DA:  BSF    F8B.3
004DC:  BCF    F94.3
....................       Motor2_on;  
004DE:  BSF    F8B.2
004E0:  BCF    F94.2
....................       set_timer0(253);         // Next timer overflow will clear the triac pin 
004E2:  CLRF   FD7
004E4:  MOVLW  FD
004E6:  MOVWF  FD6
....................       Cruce=OFF;         // Flag now signals that we need to turn off the triac output pin 
004E8:  BCF    x80.3
....................    } else {            //The triac has been triggered, cut the pulse 
004EA:  BRA    04F8
....................       Motor_off; 
004EC:  BCF    F8B.3
004EE:  BCF    F94.3
....................       Motor2_off;  
004F0:  BCF    F8B.2
004F2:  BCF    F94.2
....................       set_timer0(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
004F4:  CLRF   FD7
004F6:  CLRF   FD6
004F8:  MOVLB  2
....................    } 
....................    } 
.................... } 
.................... /* 
.................... #int_TIMER1 HIGH 
.................... void temp1s(void){ 
....................    if(VelMotor2>0 && VelMotor2<6){ 
....................    if(Cruce2){         //If the triac pin is low we change the state and prepare the timer 
....................       Motor2_on; 
....................       set_timer1(65435);         // Next timer overflow will clear the triac pin 
....................       Cruce2=OFF;         // Flag now signals that we need to turn off the triac output pin 
....................    } else {            //The triac has been triggered, cut the pulse 
....................       Motor2_off; 
....................       set_timer1(0);         //Set timer period to maximum, timer should not overflow untill next zero cross interrupt 
....................    } 
....................    } 
.................... } 
.................... */ 
004FA:  BCF    FF2.2
004FC:  MOVLB  0
004FE:  GOTO   0116
.................... #int_rda  
.................... void serial_rx_isr(){ 
....................    Dato2=fgetc(); 
*
0051A:  BRA    0502
0051C:  MOVFF  01,A6
....................    if(Dato2==0x65){//Inicio Comunicacion 
00520:  MOVF   xA6,W
00522:  SUBLW  65
00524:  BNZ   052C
....................       Inicio=1; 
00526:  MOVLW  01
00528:  MOVWF  xA7
....................       RX_Wr_Index=0; 
0052A:  CLRF   47
....................    } 
....................    if(Inicio==1){ 
0052C:  DECFSZ xA7,W
0052E:  BRA    0544
....................       Rx_Buffer2[RX_Wr_Index] = Dato2; 
00530:  CLRF   03
00532:  MOVF   47,W
00534:  ADDLW  3C
00536:  MOVWF  FE9
00538:  MOVLW  00
0053A:  ADDWFC 03,W
0053C:  MOVWF  FEA
0053E:  MOVFF  A6,FEF
....................       RX_Wr_Index++; 
00542:  INCF   47,F
....................    } 
....................    if(RX_Wr_Index >= RX_BUFFER_SIZE){ 
00544:  MOVF   47,W
00546:  SUBLW  09
00548:  BC    054E
....................       RX_Wr_Index =0; 
0054A:  CLRF   47
....................       Inicio=0; 
0054C:  CLRF   xA7
....................    } 
....................    if(RX_Wr_Index==0){ 
0054E:  MOVF   47,F
00550:  BNZ   0572
....................       if(Rx_Buffer2[0]==0x65 && Rx_Buffer2[1]==0xff && Rx_Buffer2[2]==0xff && Rx_Buffer2[8]==0x00 && Rx_Buffer2[9]==0xff ) 
00552:  MOVF   3C,W
00554:  SUBLW  65
00556:  BNZ   056E
00558:  INCFSZ 3D,W
0055A:  BRA    056E
0055C:  INCFSZ 3E,W
0055E:  BRA    056E
00560:  MOVF   44,F
00562:  BNZ   056E
00564:  INCFSZ 45,W
00566:  BRA    056E
....................          Dato_Exitoso=5; 
00568:  MOVLW  05
0056A:  MOVWF  x9D
....................       else 
0056C:  BRA    0572
....................          Dato_Exitoso=10; 
0056E:  MOVLW  0A
00570:  MOVWF  x9D
....................    } 
....................    //if(Menu==20) 
....................    //  Alarma_on; 
....................       
....................    //output_toggle(PIN_C0);   
.................... } 
....................  
00572:  BCF    F9E.5
00574:  GOTO   0068
.................... void main(){ 
*
05EAC:  CLRF   FF8
05EAE:  BSF    FF1.2
05EB0:  BSF    FF0.6
05EB2:  BCF    F9F.5
05EB4:  BSF    FD0.7
05EB6:  BSF    07.7
05EB8:  CLRF   FEA
05EBA:  CLRF   FE9
05EBC:  BSF    FB8.3
05EBE:  MOVLW  08
05EC0:  MOVWF  FAF
05EC2:  MOVLW  02
05EC4:  MOVWF  FB0
05EC6:  MOVLW  A6
05EC8:  MOVWF  FAC
05ECA:  MOVLW  90
05ECC:  MOVWF  FAB
05ECE:  CLRF   47
05ED0:  CLRF   48
05ED2:  CLRF   49
05ED4:  CLRF   x63
05ED6:  CLRF   x64
05ED8:  BCF    x7D.0
05EDA:  BCF    x7D.1
05EDC:  BCF    x7D.2
05EDE:  BCF    x7D.3
05EE0:  BCF    x7D.4
05EE2:  BCF    x7D.5
05EE4:  BCF    x7D.6
05EE6:  BCF    x7D.7
05EE8:  BCF    x7E.0
05EEA:  BCF    x7E.1
05EEC:  BCF    x7E.2
05EEE:  BCF    x7E.3
05EF0:  BCF    x7E.4
05EF2:  BCF    x7E.5
05EF4:  BCF    x7E.6
05EF6:  BCF    x7E.7
05EF8:  BCF    x7F.0
05EFA:  BCF    x7F.1
05EFC:  BCF    x7F.2
05EFE:  BCF    x7F.3
05F00:  BCF    x7F.4
05F02:  BCF    x7F.5
05F04:  BCF    x7F.6
05F06:  BCF    x7F.7
05F08:  BCF    x80.0
05F0A:  BCF    x80.1
05F0C:  BCF    x80.2
05F0E:  MOVLW  F0
05F10:  MOVWF  x81
05F12:  MOVLW  01
05F14:  MOVWF  x82
05F16:  MOVLW  0A
05F18:  MOVWF  x83
05F1A:  CLRF   x84
05F1C:  CLRF   x85
05F1E:  CLRF   x86
05F20:  CLRF   x87
05F22:  CLRF   x88
05F24:  CLRF   x89
05F26:  CLRF   x8A
05F28:  CLRF   x8B
05F2A:  CLRF   x8C
05F2C:  CLRF   x8D
05F2E:  CLRF   x8E
05F30:  CLRF   x8F
05F32:  MOVWF  x90
05F34:  MOVWF  x91
05F36:  CLRF   x92
05F38:  CLRF   x93
05F3A:  CLRF   x94
05F3C:  CLRF   x95
05F3E:  MOVLW  12
05F40:  MOVWF  x96
05F42:  MOVLW  09
05F44:  MOVWF  x97
05F46:  MOVLW  0D
05F48:  MOVWF  x98
05F4A:  CLRF   x99
05F4C:  CLRF   x9A
05F4E:  CLRF   x9B
05F50:  CLRF   x9C
05F52:  CLRF   x9D
05F54:  MOVLW  08
05F56:  MOVWF  x9E
05F58:  CLRF   x9F
05F5A:  CLRF   xA0
05F5C:  CLRF   xA1
05F5E:  CLRF   xA2
05F60:  CLRF   xA3
05F62:  CLRF   xA4
05F64:  CLRF   xA5
05F66:  CLRF   xA6
05F68:  CLRF   xA7
05F6A:  CLRF   xA8
05F6C:  CLRF   xA9
05F6E:  CLRF   xAA
05F70:  CLRF   xAB
05F72:  CLRF   xAC
05F74:  CLRF   xAD
05F76:  CLRF   xAE
05F78:  CLRF   xAF
05F7A:  CLRF   xB0
05F7C:  CLRF   xB1
05F7E:  CLRF   xB2
05F80:  CLRF   xB3
05F82:  CLRF   xB4
05F84:  CLRF   xB5
05F86:  CLRF   xB6
05F88:  CLRF   xB7
05F8A:  MOVLW  0A
05F8C:  MOVWF  xB8
05F8E:  CLRF   xB9
05F90:  CLRF   xBA
05F92:  CLRF   xBC
05F94:  CLRF   xBB
05F96:  CLRF   xBE
05F98:  CLRF   xBD
05F9A:  CLRF   xC0
05F9C:  CLRF   xBF
05F9E:  CLRF   xC2
05FA0:  CLRF   xC1
05FA2:  CLRF   xC4
05FA4:  CLRF   xC3
05FA6:  CLRF   xC6
05FA8:  CLRF   xC5
05FAA:  CLRF   xC8
05FAC:  CLRF   xC7
05FAE:  CLRF   xDC
05FB0:  CLRF   xDB
05FB2:  CLRF   xDA
05FB4:  CLRF   xD9
05FB6:  CLRF   xE0
05FB8:  CLRF   xDF
05FBA:  CLRF   xDE
05FBC:  CLRF   xDD
05FBE:  CLRF   xE4
05FC0:  CLRF   xE3
05FC2:  CLRF   xE2
05FC4:  CLRF   xE1
05FC6:  CLRF   xE8
05FC8:  CLRF   xE7
05FCA:  CLRF   xE6
05FCC:  CLRF   xE5
05FCE:  CLRF   xEC
05FD0:  CLRF   xEB
05FD2:  CLRF   xEA
05FD4:  CLRF   xE9
05FD6:  CLRF   xF0
05FD8:  CLRF   xEF
05FDA:  CLRF   xEE
05FDC:  CLRF   xED
05FDE:  CLRF   xF4
05FE0:  CLRF   xF3
05FE2:  CLRF   xF2
05FE4:  CLRF   xF1
05FE6:  CLRF   xF8
05FE8:  CLRF   xF7
05FEA:  CLRF   xF6
05FEC:  CLRF   xF5
05FEE:  CLRF   xFC
05FF0:  CLRF   xFB
05FF2:  CLRF   xFA
05FF4:  CLRF   xF9
05FF6:  MOVLB  1
05FF8:  CLRF   x00
05FFA:  MOVLB  0
05FFC:  CLRF   xFF
05FFE:  CLRF   xFE
06000:  CLRF   xFD
06002:  MOVLB  1
06004:  CLRF   x04
06006:  CLRF   x03
06008:  CLRF   x02
0600A:  CLRF   x01
0600C:  CLRF   x08
0600E:  CLRF   x07
06010:  CLRF   x06
06012:  CLRF   x05
06014:  CLRF   x0C
06016:  CLRF   x0B
06018:  CLRF   x0A
0601A:  CLRF   x09
0601C:  CLRF   x10
0601E:  CLRF   x0F
06020:  CLRF   x0E
06022:  CLRF   x0D
06024:  CLRF   x14
06026:  CLRF   x13
06028:  CLRF   x12
0602A:  CLRF   x11
0602C:  CLRF   x18
0602E:  CLRF   x17
06030:  CLRF   x16
06032:  CLRF   x15
06034:  MOVLW  19
06036:  MOVWF  x1C
06038:  MOVLW  53
0603A:  MOVWF  x1B
0603C:  MOVLW  18
0603E:  MOVWF  x1A
06040:  MOVLW  68
06042:  MOVWF  x19
06044:  MOVLW  E9
06046:  MOVWF  x20
06048:  MOVLW  BD
0604A:  MOVWF  x1F
0604C:  MOVLW  C6
0604E:  MOVWF  x1E
06050:  MOVLW  71
06052:  MOVWF  x1D
06054:  MOVLW  BE
06056:  MOVWF  x24
06058:  MOVLW  96
0605A:  MOVWF  x23
0605C:  MOVLW  24
0605E:  MOVWF  x22
06060:  MOVLW  7A
06062:  MOVWF  x21
06064:  MOVLW  F3
06066:  MOVWF  x28
06068:  MOVLW  5A
0606A:  MOVWF  x27
0606C:  MOVLW  AB
0606E:  MOVWF  x26
06070:  MOVLW  81
06072:  MOVWF  x25
06074:  MOVLB  2
06076:  CLRF   xBC
06078:  CLRF   xBB
0607A:  MOVLW  4B
0607C:  MOVWF  xBA
0607E:  MOVLW  86
06080:  MOVWF  xB9
06082:  CLRF   xC0
06084:  CLRF   xBF
06086:  CLRF   xBE
06088:  CLRF   xBD
0608A:  MOVLW  85
0608C:  MOVWF  xC4
0608E:  MOVLW  EB
06090:  MOVWF  xC3
06092:  MOVLW  11
06094:  MOVWF  xC2
06096:  MOVLW  7E
06098:  MOVWF  xC1
0609A:  CLRF   xC8
0609C:  CLRF   xC7
0609E:  CLRF   xC6
060A0:  CLRF   xC5
060A2:  CLRF   xCC
060A4:  CLRF   xCB
060A6:  CLRF   xCA
060A8:  MOVLW  80
060AA:  MOVWF  xC9
060AC:  CLRF   xCE
060AE:  CLRF   xCD
060B0:  CLRF   xCF
060B2:  CLRF   xD0
060B4:  CLRF   xD1
060B6:  CLRF   xD2
060B8:  MOVLB  0
060BA:  BCF    x80.3
060BC:  BCF    x80.4
060BE:  MOVLB  2
060C0:  CLRF   xD3
060C2:  CLRF   xD4
060C4:  CLRF   xDE
060C6:  CLRF   xDD
060C8:  MOVLW  1B
060CA:  MOVLB  A
060CC:  MOVWF  xF7
060CE:  MOVLW  10
060D0:  MOVWF  xF6
060D2:  MOVLW  E1
060D4:  MOVWF  xF5
060D6:  MOVLW  7A
060D8:  MOVWF  xF4
060DA:  MOVLW  88
060DC:  MOVWF  xFB
060DE:  MOVLW  2E
060E0:  MOVWF  xFA
060E2:  MOVLW  10
060E4:  MOVWF  xF9
060E6:  MOVLW  7E
060E8:  MOVWF  xF8
060EA:  MOVLW  62
060EC:  MOVWF  xFF
060EE:  MOVLW  F8
060F0:  MOVWF  xFE
060F2:  MOVLW  E8
060F4:  MOVWF  xFD
060F6:  MOVLW  7D
060F8:  MOVWF  xFC
060FA:  MOVF   FC1,W
060FC:  ANDLW  C0
060FE:  IORLW  0F
06100:  MOVWF  FC1
06102:  MOVLW  07
06104:  MOVWF  FB4
06106:  CLRF   2A
06108:  CLRF   2B
0610A:  CLRF   2C
0610C:  MOVLB  0
0610E:  CLRF   x65
06110:  MOVLW  03
06112:  MOVWF  x66
06114:  MOVWF  x67
06116:  MOVLW  06
06118:  MOVWF  x68
0611A:  MOVLW  01
0611C:  MOVWF  x69
0611E:  MOVLW  04
06120:  MOVWF  x6A
06122:  MOVLW  06
06124:  MOVWF  x6B
06126:  MOVLW  02
06128:  MOVWF  x6C
0612A:  MOVLW  05
0612C:  MOVWF  x6D
0612E:  CLRF   x6E
06130:  MOVLW  03
06132:  MOVWF  x6F
06134:  MOVLW  05
06136:  MOVWF  x70
06138:  CLRF   x71
0613A:  MOVLW  03
0613C:  MOVWF  x72
0613E:  MOVLW  04
06140:  MOVWF  x73
06142:  CLRF   x74
06144:  MOVLW  02
06146:  MOVWF  x75
06148:  MOVLW  05
0614A:  MOVWF  x76
0614C:  CLRF   x77
0614E:  MOVLW  03
06150:  MOVWF  x78
06152:  MOVLW  06
06154:  MOVWF  x79
06156:  MOVLW  01
06158:  MOVWF  x7A
0615A:  MOVLW  04
0615C:  MOVWF  x7B
0615E:  MOVLW  06
06160:  MOVWF  x7C
06162:  CLRF   xC9
06164:  CLRF   xCA
06166:  CLRF   xCB
06168:  CLRF   xCC
0616A:  CLRF   xCD
0616C:  CLRF   xCE
0616E:  CLRF   xCF
06170:  CLRF   xD0
06172:  CLRF   xD1
06174:  CLRF   xD2
06176:  CLRF   xD3
06178:  CLRF   xD4
0617A:  CLRF   xD5
0617C:  CLRF   xD6
0617E:  CLRF   xD7
06180:  CLRF   xD8
06182:  MOVLB  1
06184:  CLRF   x29
06186:  CLRF   x2A
06188:  CLRF   x2B
0618A:  CLRF   x2C
0618C:  CLRF   x2D
0618E:  CLRF   x2E
06190:  CLRF   x2F
06192:  CLRF   x30
06194:  CLRF   x31
06196:  CLRF   x32
06198:  CLRF   x33
0619A:  CLRF   x34
0619C:  CLRF   x35
0619E:  CLRF   x36
061A0:  CLRF   x37
061A2:  CLRF   x38
061A4:  CLRF   x39
061A6:  CLRF   x3A
061A8:  CLRF   x3B
061AA:  CLRF   x3C
061AC:  CLRF   x3D
061AE:  CLRF   x3E
061B0:  CLRF   x3F
061B2:  CLRF   x40
061B4:  CLRF   x41
061B6:  CLRF   x42
061B8:  CLRF   x43
061BA:  CLRF   x44
061BC:  CLRF   x45
061BE:  CLRF   x46
061C0:  CLRF   x47
061C2:  CLRF   x48
061C4:  CLRF   x49
061C6:  CLRF   x4A
061C8:  CLRF   x4B
061CA:  CLRF   x4C
061CC:  CLRF   x4D
061CE:  CLRF   x4E
061D0:  CLRF   x4F
061D2:  CLRF   x50
061D4:  CLRF   x51
061D6:  CLRF   x52
061D8:  CLRF   x53
061DA:  CLRF   x54
061DC:  CLRF   x55
061DE:  CLRF   x56
061E0:  CLRF   x57
061E2:  CLRF   x58
061E4:  CLRF   x59
061E6:  CLRF   x5A
061E8:  CLRF   x5B
061EA:  CLRF   x5C
061EC:  CLRF   x5D
061EE:  CLRF   x5E
061F0:  CLRF   x5F
061F2:  CLRF   x60
061F4:  CLRF   x61
061F6:  CLRF   x62
061F8:  CLRF   x63
061FA:  CLRF   x64
061FC:  CLRF   x65
061FE:  CLRF   x66
06200:  CLRF   x67
06202:  CLRF   x68
06204:  CLRF   x69
06206:  CLRF   x6A
06208:  CLRF   x6B
0620A:  CLRF   x6C
0620C:  CLRF   x6D
0620E:  CLRF   x6E
06210:  CLRF   x6F
06212:  CLRF   x70
06214:  CLRF   x71
06216:  CLRF   x72
06218:  CLRF   x73
0621A:  CLRF   x74
0621C:  CLRF   x75
0621E:  CLRF   x76
06220:  CLRF   x77
06222:  CLRF   x78
06224:  CLRF   x79
06226:  CLRF   x7A
06228:  CLRF   x7B
0622A:  CLRF   x7C
0622C:  CLRF   x7D
0622E:  CLRF   x7E
06230:  CLRF   x7F
06232:  CLRF   x80
06234:  CLRF   x81
06236:  CLRF   x82
06238:  CLRF   x83
0623A:  CLRF   x84
0623C:  CLRF   x85
0623E:  CLRF   x86
06240:  CLRF   x87
06242:  CLRF   x88
06244:  CLRF   x89
06246:  CLRF   x8A
06248:  CLRF   x8B
0624A:  CLRF   x8C
0624C:  CLRF   x8D
0624E:  CLRF   x8E
06250:  CLRF   x8F
06252:  CLRF   x90
06254:  CLRF   x91
06256:  CLRF   x92
06258:  CLRF   x93
0625A:  CLRF   x94
0625C:  CLRF   x95
0625E:  CLRF   x96
06260:  CLRF   x97
06262:  CLRF   x98
06264:  CLRF   x99
06266:  CLRF   x9A
06268:  CLRF   x9B
0626A:  CLRF   x9C
0626C:  CLRF   x9D
0626E:  CLRF   x9E
06270:  CLRF   x9F
06272:  CLRF   xA0
06274:  CLRF   xA1
06276:  CLRF   xA2
06278:  CLRF   xA3
0627A:  CLRF   xA4
0627C:  CLRF   xA5
0627E:  CLRF   xA6
06280:  CLRF   xA7
06282:  CLRF   xA8
06284:  CLRF   xA9
06286:  CLRF   xAA
06288:  CLRF   xAB
0628A:  CLRF   xAC
0628C:  CLRF   xAD
0628E:  CLRF   xAE
06290:  CLRF   xAF
06292:  CLRF   xB0
06294:  CLRF   xB1
06296:  CLRF   xB2
06298:  CLRF   xB3
0629A:  CLRF   xB4
0629C:  CLRF   xB5
0629E:  CLRF   xB6
062A0:  CLRF   xB7
062A2:  CLRF   xB8
062A4:  CLRF   xB9
062A6:  CLRF   xBA
062A8:  CLRF   xBB
062AA:  CLRF   xBC
062AC:  CLRF   xBD
062AE:  CLRF   xBE
062B0:  CLRF   xBF
062B2:  CLRF   xC0
062B4:  CLRF   xC1
062B6:  CLRF   xC2
062B8:  CLRF   xC3
062BA:  CLRF   xC4
062BC:  CLRF   xC5
062BE:  CLRF   xC6
062C0:  CLRF   xC7
062C2:  CLRF   xC8
062C4:  CLRF   xC9
062C6:  CLRF   xCA
062C8:  CLRF   xCB
062CA:  CLRF   xCC
062CC:  CLRF   xCD
062CE:  CLRF   xCE
062D0:  CLRF   xCF
062D2:  CLRF   xD0
062D4:  CLRF   xD1
062D6:  CLRF   xD2
062D8:  CLRF   xD3
062DA:  CLRF   xD4
062DC:  CLRF   xD5
062DE:  CLRF   xD6
062E0:  CLRF   xD7
062E2:  CLRF   xD8
062E4:  CLRF   xD9
062E6:  CLRF   xDA
062E8:  CLRF   xDB
062EA:  CLRF   xDC
062EC:  CLRF   xDD
062EE:  CLRF   xDE
062F0:  CLRF   xDF
062F2:  CLRF   xE0
062F4:  CLRF   xE1
062F6:  CLRF   xE2
062F8:  CLRF   xE3
062FA:  CLRF   xE4
062FC:  CLRF   xE5
062FE:  CLRF   xE6
06300:  CLRF   xE7
06302:  CLRF   xE8
06304:  CLRF   xE9
06306:  CLRF   xEA
06308:  CLRF   xEB
0630A:  CLRF   xEC
0630C:  CLRF   xED
0630E:  CLRF   xEE
06310:  CLRF   xEF
06312:  CLRF   xF0
06314:  CLRF   xF1
06316:  CLRF   xF2
06318:  CLRF   xF3
0631A:  CLRF   xF4
0631C:  CLRF   xF5
0631E:  CLRF   xF6
06320:  CLRF   xF7
06322:  CLRF   xF8
06324:  CLRF   xF9
06326:  CLRF   xFA
06328:  CLRF   xFB
0632A:  CLRF   xFC
0632C:  CLRF   xFD
0632E:  CLRF   xFE
06330:  CLRF   xFF
06332:  MOVLB  2
06334:  CLRF   x00
06336:  CLRF   x01
06338:  CLRF   x02
0633A:  CLRF   x03
0633C:  CLRF   x04
0633E:  CLRF   x05
06340:  CLRF   x06
06342:  CLRF   x07
06344:  CLRF   x08
06346:  CLRF   x09
06348:  CLRF   x0A
0634A:  CLRF   x0B
0634C:  CLRF   x0C
0634E:  CLRF   x0D
06350:  CLRF   x0E
06352:  CLRF   x0F
06354:  CLRF   x10
06356:  CLRF   x11
06358:  CLRF   x12
0635A:  CLRF   x13
0635C:  CLRF   x14
0635E:  CLRF   x15
06360:  CLRF   x16
06362:  CLRF   x17
06364:  CLRF   x18
06366:  CLRF   x19
06368:  CLRF   x1A
0636A:  CLRF   x1B
0636C:  CLRF   x1C
0636E:  CLRF   x1D
06370:  CLRF   x1E
06372:  CLRF   x1F
06374:  CLRF   x20
06376:  CLRF   x21
06378:  CLRF   x22
0637A:  CLRF   x23
0637C:  CLRF   x24
0637E:  CLRF   x25
06380:  CLRF   x26
06382:  CLRF   x27
06384:  CLRF   x28
06386:  CLRF   x29
06388:  CLRF   x2A
0638A:  CLRF   x2B
0638C:  CLRF   x2C
0638E:  CLRF   x2D
06390:  CLRF   x2E
06392:  CLRF   x2F
06394:  CLRF   x30
06396:  CLRF   x31
06398:  CLRF   x32
0639A:  CLRF   x33
0639C:  CLRF   x34
0639E:  CLRF   x35
063A0:  CLRF   x36
063A2:  CLRF   x37
063A4:  CLRF   x38
063A6:  CLRF   x39
063A8:  CLRF   x3A
063AA:  CLRF   x3B
063AC:  CLRF   x3C
063AE:  CLRF   x3D
063B0:  CLRF   x3E
063B2:  CLRF   x3F
063B4:  CLRF   x40
063B6:  CLRF   x41
063B8:  CLRF   x42
063BA:  CLRF   x43
063BC:  CLRF   x44
063BE:  CLRF   x45
063C0:  CLRF   x46
063C2:  CLRF   x47
063C4:  CLRF   x48
063C6:  CLRF   x49
063C8:  CLRF   x4A
063CA:  CLRF   x4B
063CC:  CLRF   x4C
063CE:  CLRF   x4D
063D0:  CLRF   x4E
063D2:  CLRF   x4F
063D4:  CLRF   x50
063D6:  CLRF   x51
063D8:  CLRF   x52
063DA:  CLRF   x53
063DC:  CLRF   x54
063DE:  CLRF   x55
063E0:  CLRF   x56
063E2:  CLRF   x57
063E4:  CLRF   x58
063E6:  CLRF   x59
063E8:  CLRF   x5A
063EA:  CLRF   x5B
063EC:  CLRF   x5C
063EE:  CLRF   x5D
063F0:  CLRF   x5E
063F2:  CLRF   x5F
063F4:  CLRF   x60
063F6:  CLRF   x61
063F8:  CLRF   x62
063FA:  CLRF   x63
063FC:  CLRF   x64
063FE:  CLRF   x65
06400:  CLRF   x66
06402:  CLRF   x67
06404:  CLRF   x68
06406:  CLRF   x69
06408:  CLRF   x6A
0640A:  CLRF   x6B
0640C:  CLRF   x6C
0640E:  CLRF   x6D
06410:  CLRF   x6E
06412:  CLRF   x6F
06414:  CLRF   x70
06416:  CLRF   x71
06418:  CLRF   x72
0641A:  CLRF   x73
0641C:  CLRF   x74
0641E:  CLRF   x75
06420:  CLRF   x76
06422:  CLRF   x77
06424:  CLRF   x78
06426:  CLRF   x79
06428:  CLRF   x7A
0642A:  CLRF   x7B
0642C:  CLRF   x7C
0642E:  CLRF   x7D
06430:  CLRF   x7E
06432:  CLRF   x7F
06434:  CLRF   x80
06436:  CLRF   x81
06438:  CLRF   x82
0643A:  CLRF   x83
0643C:  CLRF   x84
0643E:  CLRF   x85
06440:  CLRF   x86
06442:  CLRF   x87
06444:  CLRF   x88
06446:  CLRF   x89
06448:  CLRF   x8A
0644A:  CLRF   x8B
0644C:  CLRF   x8C
0644E:  CLRF   x8D
06450:  CLRF   x8E
06452:  CLRF   x8F
06454:  CLRF   x90
....................    //delay_ms(1000); 
....................    enable_interrupts(int_rda); 
06456:  BSF    F9D.5
....................    enable_interrupts(global); 
06458:  MOVLW  C0
0645A:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT_L2H); 
0645C:  BSF    FF2.4
0645E:  BSF    FF1.6
....................    enable_interrupts(INT_EXT1_H2L); 
06460:  BSF    FF0.3
06462:  BCF    FF1.5
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_256); 
06464:  MOVLW  C7
06466:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0); 
06468:  BSF    FF2.5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
0646A:  MOVLW  B5
0646C:  MOVWF  FCD
....................    //enable_interrupts(INT_TIMER1); 
....................    setup_wdt(WDT_ON); 
0646E:  BSF    FD1.0
....................    setup_adc_ports(AN0_TO_AN4); 
06470:  MOVF   FC1,W
06472:  ANDLW  C0
06474:  IORLW  0A
06476:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32); 
06478:  MOVF   FC0,W
0647A:  ANDLW  C0
0647C:  IORLW  02
0647E:  MOVWF  FC0
06480:  BSF    FC0.7
06482:  BSF    FC2.0
....................    //port_b_pullups(true); 
....................    setup_wdt(WDT_ON); 
06484:  BSF    FD1.0
....................    Display_on; 
06486:  BSF    F8C.5
06488:  BCF    F95.5
....................    Cruce=OFF; 
0648A:  MOVLB  0
0648C:  BCF    x80.3
....................    Cruce2=OFF; 
0648E:  BCF    x7F.4
....................    VelMotor=0; 
06490:  MOVLB  2
06492:  CLRF   xD3
....................    VelMotor2=0; 
06494:  CLRF   xD4
....................    Motor_off;   
06496:  BCF    F8B.3
06498:  BCF    F94.3
....................    delay_ms(1); 
0649A:  MOVLW  01
0649C:  MOVLB  B
0649E:  MOVWF  x22
064A0:  MOVLB  0
064A2:  CALL   11F6
....................    rtc_init();   
064A6:  GOTO   12B2
....................    delay_ms(1000); 
064AA:  MOVLW  04
064AC:  MOVLB  B
064AE:  MOVWF  x00
064B0:  MOVLW  FA
064B2:  MOVWF  x22
064B4:  MOVLB  0
064B6:  CALL   11F6
064BA:  MOVLB  B
064BC:  DECFSZ x00,F
064BE:  BRA    64B0
....................    for(i=0;i<10;i++){ 
064C0:  MOVLB  2
064C2:  CLRF   xCF
064C4:  MOVF   xCF,W
064C6:  SUBLW  09
064C8:  BNC   64E6
....................       printf("page Bienvenida"); 
064CA:  MOVLW  78
064CC:  MOVWF  FF6
064CE:  MOVLW  05
064D0:  MOVWF  FF7
064D2:  MOVLW  00
064D4:  MOVWF  FF8
064D6:  MOVLB  0
064D8:  CALL   1304
....................       SendDataDisplay();    
064DC:  CALL   1336
....................    } 
064E0:  MOVLB  2
064E2:  INCF   xCF,F
064E4:  BRA    64C4
....................    Motor_off; 
064E6:  BCF    F8B.3
064E8:  BCF    F94.3
....................    LuzBlanca_off;Alarma_off; 
064EA:  BSF    F8C.0
064EC:  BCF    F95.0
064EE:  BCF    F8B.0
064F0:  BCF    F94.0
.................... //-------Inicio de Cabina-------------------------------------------------------------------------//    
....................    Motor2_off; 
064F2:  BCF    F8B.2
064F4:  BCF    F94.2
....................    LeeEEPROM(); // Lectura de variables almacenadas en la EEPROM  
064F6:  MOVLB  0
064F8:  GOTO   1778
....................    LimitaValores(); 
064FC:  GOTO   2496
....................    delay_ms(1000); 
06500:  MOVLW  04
06502:  MOVLB  B
06504:  MOVWF  x00
06506:  MOVLW  FA
06508:  MOVWF  x22
0650A:  MOVLB  0
0650C:  CALL   11F6
06510:  MOVLB  B
06512:  DECFSZ x00,F
06514:  BRA    6506
....................    while(true){  
....................     
....................       leeControlRemoto(); 
06516:  MOVLB  0
06518:  GOTO   3478
....................       if(pulsos>=120){  
0651C:  MOVLB  2
0651E:  MOVF   xCE,F
06520:  BNZ   6528
06522:  MOVF   xCD,W
06524:  SUBLW  77
06526:  BC    6578
....................       //enable_interrupts(INT_RDA); 
....................       //enable_interrupts(global);  
....................       pulsos=0; 
06528:  CLRF   xCE
0652A:  CLRF   xCD
....................       imprimir=1;Lectura=1; 
0652C:  MOVLB  0
0652E:  BSF    x7D.0
06530:  BSF    x80.0
....................        
....................       if(flag_blower==1) 
06532:  BTFSS  x7D.1
06534:  BRA    653C
....................          minutos_trabajo++;  
06536:  INCF   xC3,F
06538:  BTFSC  FD8.2
0653A:  INCF   xC4,F
....................    
....................       if(tiempo_purga==1 || Purga){                   
0653C:  BTFSC  x7E.2
0653E:  BRA    6544
06540:  BTFSS  x80.4
06542:  BRA    6550
....................          sPurga++; 
06544:  INCF   xAC,F
....................          if(sPurga>59){ 
06546:  MOVF   xAC,W
06548:  SUBLW  3B
0654A:  BC    6550
....................             sPurga=0; 
0654C:  CLRF   xAC
....................             mPurga++; 
0654E:  INCF   xAE,F
....................          } 
....................       } 
....................        
....................       if(tiempo_postpurga){ 
06550:  BTFSS  x80.1
06552:  BRA    6560
....................          sPPurga++; 
06554:  INCF   xB0,F
....................          if(sPPurga>59){ 
06556:  MOVF   xB0,W
06558:  SUBLW  3B
0655A:  BC    6560
....................             sPPurga=0; 
0655C:  CLRF   xB0
....................             mPPurga++; 
0655E:  INCF   xB2,F
....................          } 
....................       } 
....................     
....................       if(tiempo_uv==1){ 
06560:  BTFSS  x7F.2
06562:  BRA    6576
....................          segundos_uv++; 
06564:  INCF   xBD,F
06566:  BTFSC  FD8.2
06568:  INCF   xBE,F
....................          sUV++; 
0656A:  INCF   xB4,F
....................          if(sUV>59){ 
0656C:  MOVF   xB4,W
0656E:  SUBLW  3B
06570:  BC    6576
....................             sUV=0; 
06572:  CLRF   xB4
....................             mUV++; 
06574:  INCF   xB5,F
06576:  MOVLB  2
....................          } 
....................       } 
....................    } 
....................     
....................       if(VelMotor==6){ 
06578:  MOVF   xD3,W
0657A:  SUBLW  06
0657C:  BNZ   658A
....................          Motor_on; 
0657E:  BSF    F8B.3
06580:  BCF    F94.3
....................          Motor2_on;  
06582:  BSF    F8B.2
06584:  BCF    F94.2
....................          set_timer0(0); 
06586:  CLRF   FD7
06588:  CLRF   FD6
....................       } 
....................       /* 
....................       if(VelMotor2==6){ 
....................          Motor2_on; 
....................          //set_timer1(0); 
....................       } 
....................       */ 
....................       if(VelMotor==0){ 
0658A:  MOVF   xD3,F
0658C:  BNZ   659A
....................          Motor_off; 
0658E:  BCF    F8B.3
06590:  BCF    F94.3
....................          Motor2_off;  
06592:  BCF    F8B.2
06594:  BCF    F94.2
....................          set_timer0(0); 
06596:  CLRF   FD7
06598:  CLRF   FD6
....................       } 
....................       /* 
....................       if(VelMotor2==0){ 
....................          Motor2_off; 
....................          //set_timer1(0); 
....................       } 
....................       */ 
....................       restart_wdt(); 
0659A:  CLRWDT
....................       LeeDisplay(); 
0659C:  MOVLB  0
0659E:  GOTO   36E8
....................     
.................... //**Actualizacin de Lectura de Sensores**//    
....................    if(Lectura==1){ 
065A2:  BTFSS  x80.0
065A4:  BRA    6754
....................       Lectura=0; 
065A6:  BCF    x80.0
....................       rtc_get_date(Dia,Mes,Year,dow); 
....................       rtc_get_time(Hora,Minuto,Segundo); 
....................       InFlow=LeerFlujo(mediaMovil,1); 
*
0666C:  MOVFF  95,B00
06670:  MOVLW  01
06672:  MOVLB  B
06674:  MOVWF  x01
06676:  MOVLB  0
06678:  GOTO   39FE
0667C:  MOVFF  03,DC
06680:  MOVFF  02,DB
06684:  MOVFF  01,DA
06688:  MOVFF  00,D9
....................       //DownFlow=InFlow*Relacion; 
....................       DownFlow=D6FW101(8,2);//LeerFlujo(8,2); 
0668C:  MOVLW  08
0668E:  MOVLB  B
06690:  MOVWF  x00
06692:  MOVLW  02
06694:  MOVWF  x01
06696:  MOVLB  0
06698:  GOTO   4428
0669C:  MOVFF  03,E0
066A0:  MOVFF  02,DF
066A4:  MOVFF  01,DE
066A8:  MOVFF  00,DD
....................       Filtro_InFlow=Leer_Sensor_Presion(8,3); 
066AC:  MOVLW  08
066AE:  MOVLB  B
066B0:  MOVWF  x00
066B2:  MOVLW  03
066B4:  MOVWF  x01
066B6:  MOVLB  0
066B8:  CALL   4840
066BC:  MOVFF  03,E8
066C0:  MOVFF  02,E7
066C4:  MOVFF  01,E6
066C8:  MOVFF  00,E5
....................       //Filtro_InFlow=0; 
....................       Filtro_DownFlow=Leer_Sensor_Presion(8,4); 
066CC:  MOVLW  08
066CE:  MOVLB  B
066D0:  MOVWF  x00
066D2:  MOVLW  04
066D4:  MOVWF  x01
066D6:  MOVLB  0
066D8:  CALL   4840
066DC:  MOVFF  03,E4
066E0:  MOVFF  02,E3
066E4:  MOVFF  01,E2
066E8:  MOVFF  00,E1
....................       Temperatura=leeTemperatura(10); 
066EC:  MOVLW  0A
066EE:  MOVLB  B
066F0:  MOVWF  x00
066F2:  MOVLB  0
066F4:  GOTO   4F60
066F8:  MOVFF  03,B03
066FC:  MOVFF  02,B02
06700:  MOVFF  01,B01
06704:  MOVFF  00,B00
06708:  CALL   513E
0670C:  MOVFF  01,2D2
....................       if(Alarma==5 || Alarma2==5){ 
06710:  MOVF   x90,W
06712:  SUBLW  05
06714:  BZ    671C
06716:  MOVF   x91,W
06718:  SUBLW  05
0671A:  BNZ   672E
....................          if(flag_alarma2==0){ 
0671C:  BTFSC  x7D.6
0671E:  BRA    6728
....................             Alarma_on; 
06720:  BSF    F8B.0
06722:  BCF    F94.0
....................             flag_alarma2=1; 
06724:  BSF    x7D.6
....................          }else{ 
06726:  BRA    672E
....................             Alarma_off; 
06728:  BCF    F8B.0
0672A:  BCF    F94.0
....................             flag_alarma2=0; 
0672C:  BCF    x7D.6
....................          } 
....................       } 
....................        
....................       if(Alarma==10 && Alarma2==10){ 
0672E:  MOVF   x90,W
06730:  SUBLW  0A
06732:  BNZ   673E
06734:  MOVF   x91,W
06736:  SUBLW  0A
06738:  BNZ   673E
....................          Alarma_off; 
0673A:  BCF    F8B.0
0673C:  BCF    F94.0
....................       } 
....................        
....................       if(flag_latencia==1)    
0673E:  BTFSS  x7E.4
06740:  BRA    6748
....................          t_latencia++;          
06742:  INCF   xBF,F
06744:  BTFSC  FD8.2
06746:  INCF   xC0,F
....................     
....................       if(t_latencia>=15) 
06748:  MOVF   xC0,F
0674A:  BNZ   6752
0674C:  MOVF   xBF,W
0674E:  SUBLW  0E
06750:  BC    6754
....................          Latencia=1; 
06752:  BSF    x7F.1
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo del filtro**// 
....................    if(minutos_trabajo>=3600){ // Tiempo de Trabajo 
06754:  MOVF   xC4,W
06756:  SUBLW  0D
06758:  BTFSC  FD8.0
0675A:  BRA    690A
0675C:  XORLW  FF
0675E:  BNZ   6768
06760:  MOVF   xC3,W
06762:  SUBLW  0F
06764:  BTFSC  FD8.0
06766:  BRA    690A
....................       minutos_trabajo=0; //Minutos Trabajo realmente son segundos. 
06768:  CLRF   xC4
0676A:  CLRF   xC3
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
0676C:  MOVFF  C3,B00
06770:  CLRF   FAA
06772:  MOVLW  25
06774:  MOVWF  FA9
06776:  MOVFF  B00,FA8
0677A:  BCF    FA6.6
0677C:  BCF    FA6.7
0677E:  BSF    FA6.2
06780:  MOVF   FF2,W
06782:  MOVWF  00
06784:  BCF    FF2.6
06786:  BCF    FF2.7
06788:  MOVLB  F
0678A:  MOVLW  55
0678C:  MOVWF  FA7
0678E:  MOVLW  AA
06790:  MOVWF  FA7
06792:  BSF    FA6.1
06794:  BTFSC  FA6.1
06796:  BRA    6794
06798:  BCF    FA6.2
0679A:  MOVF   00,W
0679C:  IORWF  FF2,F
....................       delay_ms(20); 
0679E:  MOVLW  14
067A0:  MOVLB  B
067A2:  MOVWF  x22
067A4:  MOVLB  0
067A6:  CALL   11F6
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
067AA:  MOVFF  C4,B00
067AE:  CLRF   FAA
067B0:  MOVLW  26
067B2:  MOVWF  FA9
067B4:  MOVFF  B00,FA8
067B8:  BCF    FA6.6
067BA:  BCF    FA6.7
067BC:  BSF    FA6.2
067BE:  MOVF   FF2,W
067C0:  MOVWF  00
067C2:  BCF    FF2.6
067C4:  BCF    FF2.7
067C6:  MOVLB  F
067C8:  MOVLW  55
067CA:  MOVWF  FA7
067CC:  MOVLW  AA
067CE:  MOVWF  FA7
067D0:  BSF    FA6.1
067D2:  BTFSC  FA6.1
067D4:  BRA    67D2
067D6:  BCF    FA6.2
067D8:  MOVF   00,W
067DA:  IORWF  FF2,F
....................       delay_ms(20); 
067DC:  MOVLW  14
067DE:  MOVLB  B
067E0:  MOVWF  x22
067E2:  MOVLB  0
067E4:  CALL   11F6
....................       Ttrabajo[0]++; 
067E8:  INCF   xCD,F
....................       if(Ttrabajo[0]>9){ 
067EA:  BTFSC  xCD.7
067EC:  BRA    67F8
067EE:  MOVF   xCD,W
067F0:  SUBLW  09
067F2:  BC    67F8
....................          Ttrabajo[0]=0; 
067F4:  CLRF   xCD
....................          Ttrabajo[1]++; 
067F6:  INCF   xCE,F
....................       } 
....................       if(Ttrabajo[1]>9){ 
067F8:  BTFSC  xCE.7
067FA:  BRA    6806
067FC:  MOVF   xCE,W
067FE:  SUBLW  09
06800:  BC    6806
....................          Ttrabajo[1]=0; 
06802:  CLRF   xCE
....................          Ttrabajo[2]++; 
06804:  INCF   xCF,F
....................       } 
....................       if(Ttrabajo[2]>9){ 
06806:  BTFSC  xCF.7
06808:  BRA    6814
0680A:  MOVF   xCF,W
0680C:  SUBLW  09
0680E:  BC    6814
....................          Ttrabajo[2]=0; 
06810:  CLRF   xCF
....................          Ttrabajo[3]++; 
06812:  INCF   xD0,F
....................       } 
....................       if(Ttrabajo[3]>9){ 
06814:  BTFSC  xD0.7
06816:  BRA    6820
06818:  MOVF   xD0,W
0681A:  SUBLW  09
0681C:  BC    6820
....................          Ttrabajo[3]=0; 
0681E:  CLRF   xD0
....................       } 
....................       write_eeprom(16,Ttrabajo[0]); 
06820:  CLRF   FAA
06822:  MOVLW  10
06824:  MOVWF  FA9
06826:  MOVFF  CD,FA8
0682A:  BCF    FA6.6
0682C:  BCF    FA6.7
0682E:  BSF    FA6.2
06830:  MOVF   FF2,W
06832:  MOVWF  00
06834:  BCF    FF2.6
06836:  BCF    FF2.7
06838:  MOVLB  F
0683A:  MOVLW  55
0683C:  MOVWF  FA7
0683E:  MOVLW  AA
06840:  MOVWF  FA7
06842:  BSF    FA6.1
06844:  BTFSC  FA6.1
06846:  BRA    6844
06848:  BCF    FA6.2
0684A:  MOVF   00,W
0684C:  IORWF  FF2,F
....................       delay_ms(20); 
0684E:  MOVLW  14
06850:  MOVLB  B
06852:  MOVWF  x22
06854:  MOVLB  0
06856:  CALL   11F6
....................       write_eeprom(17,Ttrabajo[1]); 
0685A:  CLRF   FAA
0685C:  MOVLW  11
0685E:  MOVWF  FA9
06860:  MOVFF  CE,FA8
06864:  BCF    FA6.6
06866:  BCF    FA6.7
06868:  BSF    FA6.2
0686A:  MOVF   FF2,W
0686C:  MOVWF  00
0686E:  BCF    FF2.6
06870:  BCF    FF2.7
06872:  MOVLB  F
06874:  MOVLW  55
06876:  MOVWF  FA7
06878:  MOVLW  AA
0687A:  MOVWF  FA7
0687C:  BSF    FA6.1
0687E:  BTFSC  FA6.1
06880:  BRA    687E
06882:  BCF    FA6.2
06884:  MOVF   00,W
06886:  IORWF  FF2,F
....................       delay_ms(20); 
06888:  MOVLW  14
0688A:  MOVLB  B
0688C:  MOVWF  x22
0688E:  MOVLB  0
06890:  CALL   11F6
....................       write_eeprom(18,Ttrabajo[2]); 
06894:  CLRF   FAA
06896:  MOVLW  12
06898:  MOVWF  FA9
0689A:  MOVFF  CF,FA8
0689E:  BCF    FA6.6
068A0:  BCF    FA6.7
068A2:  BSF    FA6.2
068A4:  MOVF   FF2,W
068A6:  MOVWF  00
068A8:  BCF    FF2.6
068AA:  BCF    FF2.7
068AC:  MOVLB  F
068AE:  MOVLW  55
068B0:  MOVWF  FA7
068B2:  MOVLW  AA
068B4:  MOVWF  FA7
068B6:  BSF    FA6.1
068B8:  BTFSC  FA6.1
068BA:  BRA    68B8
068BC:  BCF    FA6.2
068BE:  MOVF   00,W
068C0:  IORWF  FF2,F
....................       delay_ms(20); 
068C2:  MOVLW  14
068C4:  MOVLB  B
068C6:  MOVWF  x22
068C8:  MOVLB  0
068CA:  CALL   11F6
....................       write_eeprom(19,Ttrabajo[3]); 
068CE:  CLRF   FAA
068D0:  MOVLW  13
068D2:  MOVWF  FA9
068D4:  MOVFF  D0,FA8
068D8:  BCF    FA6.6
068DA:  BCF    FA6.7
068DC:  BSF    FA6.2
068DE:  MOVF   FF2,W
068E0:  MOVWF  00
068E2:  BCF    FF2.6
068E4:  BCF    FF2.7
068E6:  MOVLB  F
068E8:  MOVLW  55
068EA:  MOVWF  FA7
068EC:  MOVLW  AA
068EE:  MOVWF  FA7
068F0:  BSF    FA6.1
068F2:  BTFSC  FA6.1
068F4:  BRA    68F2
068F6:  BCF    FA6.2
068F8:  MOVF   00,W
068FA:  IORWF  FF2,F
....................       delay_ms(20); 
068FC:  MOVLW  14
068FE:  MOVLB  B
06900:  MOVWF  x22
06902:  MOVLB  0
06904:  CALL   11F6
....................    }else if(minutos_trabajo==900 || minutos_trabajo==1800 || minutos_trabajo==2700 ){ 
06908:  BRA    69AA
0690A:  MOVF   xC3,W
0690C:  SUBLW  84
0690E:  BNZ   6916
06910:  MOVF   xC4,W
06912:  SUBLW  03
06914:  BZ    692E
06916:  MOVF   xC3,W
06918:  SUBLW  08
0691A:  BNZ   6922
0691C:  MOVF   xC4,W
0691E:  SUBLW  07
06920:  BZ    692E
06922:  MOVF   xC3,W
06924:  SUBLW  8C
06926:  BNZ   69AA
06928:  MOVF   xC4,W
0692A:  SUBLW  0A
0692C:  BNZ   69AA
....................       write_eeprom(37,make8(minutos_trabajo,0)); 
0692E:  MOVFF  C3,B00
06932:  CLRF   FAA
06934:  MOVLW  25
06936:  MOVWF  FA9
06938:  MOVFF  B00,FA8
0693C:  BCF    FA6.6
0693E:  BCF    FA6.7
06940:  BSF    FA6.2
06942:  MOVF   FF2,W
06944:  MOVWF  00
06946:  BCF    FF2.6
06948:  BCF    FF2.7
0694A:  MOVLB  F
0694C:  MOVLW  55
0694E:  MOVWF  FA7
06950:  MOVLW  AA
06952:  MOVWF  FA7
06954:  BSF    FA6.1
06956:  BTFSC  FA6.1
06958:  BRA    6956
0695A:  BCF    FA6.2
0695C:  MOVF   00,W
0695E:  IORWF  FF2,F
....................       delay_ms(20); 
06960:  MOVLW  14
06962:  MOVLB  B
06964:  MOVWF  x22
06966:  MOVLB  0
06968:  CALL   11F6
....................       write_eeprom(38,make8(minutos_trabajo,1)); 
0696C:  MOVFF  C4,B00
06970:  CLRF   FAA
06972:  MOVLW  26
06974:  MOVWF  FA9
06976:  MOVFF  B00,FA8
0697A:  BCF    FA6.6
0697C:  BCF    FA6.7
0697E:  BSF    FA6.2
06980:  MOVF   FF2,W
06982:  MOVWF  00
06984:  BCF    FF2.6
06986:  BCF    FF2.7
06988:  MOVLB  F
0698A:  MOVLW  55
0698C:  MOVWF  FA7
0698E:  MOVLW  AA
06990:  MOVWF  FA7
06992:  BSF    FA6.1
06994:  BTFSC  FA6.1
06996:  BRA    6994
06998:  BCF    FA6.2
0699A:  MOVF   00,W
0699C:  IORWF  FF2,F
....................       delay_ms(20); 
0699E:  MOVLW  14
069A0:  MOVLB  B
069A2:  MOVWF  x22
069A4:  MOVLB  0
069A6:  CALL   11F6
....................    } 
.................... //----------------------------------------// 
....................  
.................... //**Contador de Tiempo de Trabajo de UV**// 
....................          if(segundos_uv>=60){ 
069AA:  MOVF   xBE,F
069AC:  BNZ   69B4
069AE:  MOVF   xBD,W
069B0:  SUBLW  3B
069B2:  BC    69BE
....................             segundos_uv=0; 
069B4:  CLRF   xBE
069B6:  CLRF   xBD
....................             minutos_uv++; 
069B8:  INCF   xC1,F
069BA:  BTFSC  FD8.2
069BC:  INCF   xC2,F
....................          } 
....................           
....................          if(minutos_uv>=60){ 
069BE:  MOVF   xC2,F
069C0:  BNZ   69CA
069C2:  MOVF   xC1,W
069C4:  SUBLW  3B
069C6:  BTFSC  FD8.0
069C8:  BRA    6B2A
....................             minutos_uv=0; 
069CA:  CLRF   xC2
069CC:  CLRF   xC1
....................             Tuv[0]++; 
069CE:  INCF   xC9,F
....................             if(Tuv[0]>9){ 
069D0:  BTFSC  xC9.7
069D2:  BRA    69DE
069D4:  MOVF   xC9,W
069D6:  SUBLW  09
069D8:  BC    69DE
....................                Tuv[0]=0; 
069DA:  CLRF   xC9
....................                Tuv[1]++; 
069DC:  INCF   xCA,F
....................             } 
....................             if(Tuv[1]>9){ 
069DE:  BTFSC  xCA.7
069E0:  BRA    69EC
069E2:  MOVF   xCA,W
069E4:  SUBLW  09
069E6:  BC    69EC
....................                Tuv[1]=0; 
069E8:  CLRF   xCA
....................                Tuv[2]++; 
069EA:  INCF   xCB,F
....................             } 
....................             if(Tuv[2]>9){ 
069EC:  BTFSC  xCB.7
069EE:  BRA    69FA
069F0:  MOVF   xCB,W
069F2:  SUBLW  09
069F4:  BC    69FA
....................                Tuv[2]=0; 
069F6:  CLRF   xCB
....................                Tuv[3]++; 
069F8:  INCF   xCC,F
....................             } 
....................             if(Tuv[3]>9){ 
069FA:  BTFSC  xCC.7
069FC:  BRA    6A06
069FE:  MOVF   xCC,W
06A00:  SUBLW  09
06A02:  BC    6A06
....................                Tuv[3]=0; 
06A04:  CLRF   xCC
....................             } 
....................             write_eeprom(39,minutos_uv); 
06A06:  CLRF   FAA
06A08:  MOVLW  27
06A0A:  MOVWF  FA9
06A0C:  MOVFF  C1,FA8
06A10:  BCF    FA6.6
06A12:  BCF    FA6.7
06A14:  BSF    FA6.2
06A16:  MOVF   FF2,W
06A18:  MOVWF  00
06A1A:  BCF    FF2.6
06A1C:  BCF    FF2.7
06A1E:  MOVLB  F
06A20:  MOVLW  55
06A22:  MOVWF  FA7
06A24:  MOVLW  AA
06A26:  MOVWF  FA7
06A28:  BSF    FA6.1
06A2A:  BTFSC  FA6.1
06A2C:  BRA    6A2A
06A2E:  BCF    FA6.2
06A30:  MOVF   00,W
06A32:  IORWF  FF2,F
....................             delay_ms(20); 
06A34:  MOVLW  14
06A36:  MOVLB  B
06A38:  MOVWF  x22
06A3A:  MOVLB  0
06A3C:  CALL   11F6
....................             write_eeprom(12,Tuv[0]); 
06A40:  CLRF   FAA
06A42:  MOVLW  0C
06A44:  MOVWF  FA9
06A46:  MOVFF  C9,FA8
06A4A:  BCF    FA6.6
06A4C:  BCF    FA6.7
06A4E:  BSF    FA6.2
06A50:  MOVF   FF2,W
06A52:  MOVWF  00
06A54:  BCF    FF2.6
06A56:  BCF    FF2.7
06A58:  MOVLB  F
06A5A:  MOVLW  55
06A5C:  MOVWF  FA7
06A5E:  MOVLW  AA
06A60:  MOVWF  FA7
06A62:  BSF    FA6.1
06A64:  BTFSC  FA6.1
06A66:  BRA    6A64
06A68:  BCF    FA6.2
06A6A:  MOVF   00,W
06A6C:  IORWF  FF2,F
....................             delay_ms(20); 
06A6E:  MOVLW  14
06A70:  MOVLB  B
06A72:  MOVWF  x22
06A74:  MOVLB  0
06A76:  CALL   11F6
....................             write_eeprom(13,Tuv[1]); 
06A7A:  CLRF   FAA
06A7C:  MOVLW  0D
06A7E:  MOVWF  FA9
06A80:  MOVFF  CA,FA8
06A84:  BCF    FA6.6
06A86:  BCF    FA6.7
06A88:  BSF    FA6.2
06A8A:  MOVF   FF2,W
06A8C:  MOVWF  00
06A8E:  BCF    FF2.6
06A90:  BCF    FF2.7
06A92:  MOVLB  F
06A94:  MOVLW  55
06A96:  MOVWF  FA7
06A98:  MOVLW  AA
06A9A:  MOVWF  FA7
06A9C:  BSF    FA6.1
06A9E:  BTFSC  FA6.1
06AA0:  BRA    6A9E
06AA2:  BCF    FA6.2
06AA4:  MOVF   00,W
06AA6:  IORWF  FF2,F
....................             delay_ms(20); 
06AA8:  MOVLW  14
06AAA:  MOVLB  B
06AAC:  MOVWF  x22
06AAE:  MOVLB  0
06AB0:  CALL   11F6
....................             write_eeprom(14,Tuv[2]); 
06AB4:  CLRF   FAA
06AB6:  MOVLW  0E
06AB8:  MOVWF  FA9
06ABA:  MOVFF  CB,FA8
06ABE:  BCF    FA6.6
06AC0:  BCF    FA6.7
06AC2:  BSF    FA6.2
06AC4:  MOVF   FF2,W
06AC6:  MOVWF  00
06AC8:  BCF    FF2.6
06ACA:  BCF    FF2.7
06ACC:  MOVLB  F
06ACE:  MOVLW  55
06AD0:  MOVWF  FA7
06AD2:  MOVLW  AA
06AD4:  MOVWF  FA7
06AD6:  BSF    FA6.1
06AD8:  BTFSC  FA6.1
06ADA:  BRA    6AD8
06ADC:  BCF    FA6.2
06ADE:  MOVF   00,W
06AE0:  IORWF  FF2,F
....................             delay_ms(20); 
06AE2:  MOVLW  14
06AE4:  MOVLB  B
06AE6:  MOVWF  x22
06AE8:  MOVLB  0
06AEA:  CALL   11F6
....................             write_eeprom(15,Tuv[3]); 
06AEE:  CLRF   FAA
06AF0:  MOVLW  0F
06AF2:  MOVWF  FA9
06AF4:  MOVFF  CC,FA8
06AF8:  BCF    FA6.6
06AFA:  BCF    FA6.7
06AFC:  BSF    FA6.2
06AFE:  MOVF   FF2,W
06B00:  MOVWF  00
06B02:  BCF    FF2.6
06B04:  BCF    FF2.7
06B06:  MOVLB  F
06B08:  MOVLW  55
06B0A:  MOVWF  FA7
06B0C:  MOVLW  AA
06B0E:  MOVWF  FA7
06B10:  BSF    FA6.1
06B12:  BTFSC  FA6.1
06B14:  BRA    6B12
06B16:  BCF    FA6.2
06B18:  MOVF   00,W
06B1A:  IORWF  FF2,F
....................             delay_ms(20); 
06B1C:  MOVLW  14
06B1E:  MOVLB  B
06B20:  MOVWF  x22
06B22:  MOVLB  0
06B24:  CALL   11F6
....................          }else if(minutos_uv==15 || minutos_uv==30 || minutos_uv==45){ 
06B28:  BRA    6B82
06B2A:  MOVF   xC1,W
06B2C:  SUBLW  0F
06B2E:  BNZ   6B34
06B30:  MOVF   xC2,F
06B32:  BZ    6B48
06B34:  MOVF   xC1,W
06B36:  SUBLW  1E
06B38:  BNZ   6B3E
06B3A:  MOVF   xC2,F
06B3C:  BZ    6B48
06B3E:  MOVF   xC1,W
06B40:  SUBLW  2D
06B42:  BNZ   6B82
06B44:  MOVF   xC2,F
06B46:  BNZ   6B82
....................             write_eeprom(39,minutos_uv); 
06B48:  CLRF   FAA
06B4A:  MOVLW  27
06B4C:  MOVWF  FA9
06B4E:  MOVFF  C1,FA8
06B52:  BCF    FA6.6
06B54:  BCF    FA6.7
06B56:  BSF    FA6.2
06B58:  MOVF   FF2,W
06B5A:  MOVWF  00
06B5C:  BCF    FF2.6
06B5E:  BCF    FF2.7
06B60:  MOVLB  F
06B62:  MOVLW  55
06B64:  MOVWF  FA7
06B66:  MOVLW  AA
06B68:  MOVWF  FA7
06B6A:  BSF    FA6.1
06B6C:  BTFSC  FA6.1
06B6E:  BRA    6B6C
06B70:  BCF    FA6.2
06B72:  MOVF   00,W
06B74:  IORWF  FF2,F
....................             delay_ms(20); 
06B76:  MOVLW  14
06B78:  MOVLB  B
06B7A:  MOVWF  x22
06B7C:  MOVLB  0
06B7E:  CALL   11F6
....................          } 
.................... //----------------------------------------//    
....................    if(Menu!=5){// Si no esta en el menu de estados apaga la alarma 
06B82:  MOVF   x81,W
06B84:  SUBLW  05
06B86:  BZ    6B92
....................       Alarma_off; 
06B88:  BCF    F8B.0
06B8A:  BCF    F94.0
....................       Alarma=10; 
06B8C:  MOVLW  0A
06B8E:  MOVWF  x90
....................       Alarma2=10; 
06B90:  MOVWF  x91
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................    if(Menu==240){ //Menu de Bienvenida. 
06B92:  MOVF   x81,W
06B94:  SUBLW  F0
06B96:  BNZ   6BC8
....................       delay_ms(1500); 
06B98:  MOVLW  06
06B9A:  MOVLB  B
06B9C:  MOVWF  x00
06B9E:  MOVLW  FA
06BA0:  MOVWF  x22
06BA2:  MOVLB  0
06BA4:  CALL   11F6
06BA8:  MOVLB  B
06BAA:  DECFSZ x00,F
06BAC:  BRA    6B9E
....................       printf("page Clave"); 
06BAE:  MOVLW  88
06BB0:  MOVWF  FF6
06BB2:  MOVLW  05
06BB4:  MOVWF  FF7
06BB6:  MOVLW  00
06BB8:  MOVWF  FF8
06BBA:  MOVLB  0
06BBC:  CALL   1304
....................       SendDataDisplay(); 
06BC0:  CALL   1336
....................       ApagaSalidas(); 
06BC4:  CALL   517A
....................    } 
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................     if(Menu==0){ //Menu de Contrasea de acceso.       
06BC8:  MOVF   x81,F
06BCA:  BTFSS  FD8.2
06BCC:  GOTO   764A
....................       entro=OFF; 
06BD0:  BCF    x7E.5
....................        
....................       if(RX_Buffer[4]==0x11){//11 
06BD2:  MOVF   35,W
06BD4:  SUBLW  11
06BD6:  BNZ   6BF2
....................          if(TipoClave!=0){ 
06BD8:  MOVF   xA8,F
06BDA:  BZ    6BF2
....................             printf("page Ajustes"); 
06BDC:  MOVLW  94
06BDE:  MOVWF  FF6
06BE0:  MOVLW  05
06BE2:  MOVWF  FF7
06BE4:  MOVLW  00
06BE6:  MOVWF  FF8
06BE8:  CALL   1304
....................             SendDataDisplay(); 
06BEC:  CALL   1336
....................             PantallaPrincipal=0; 
06BF0:  CLRF   xA9
....................          } 
....................       } 
....................        
....................       if(Digito==1){ 
06BF2:  DECFSZ xAA,W
06BF4:  BRA    6C40
....................          printf("t0.txt=\"%u\"",Contrasena[0]); 
06BF6:  MOVLW  A2
06BF8:  MOVWF  FF6
06BFA:  MOVLW  05
06BFC:  MOVWF  FF7
06BFE:  MOVLW  00
06C00:  MOVWF  FF8
06C02:  MOVLW  08
06C04:  MOVLB  B
06C06:  MOVWF  x02
06C08:  MOVLB  0
06C0A:  CALL   5198
06C0E:  MOVFF  D5,B01
06C12:  MOVLW  1B
06C14:  MOVLB  B
06C16:  MOVWF  x02
06C18:  MOVLB  0
06C1A:  CALL   51F6
06C1E:  MOVLW  22
06C20:  BTFSS  F9E.4
06C22:  BRA    6C20
06C24:  MOVWF  FAD
....................          SendDataDisplay(); 
06C26:  CALL   1336
....................          printf("va0.val=1"); 
06C2A:  MOVLW  AE
06C2C:  MOVWF  FF6
06C2E:  MOVLW  05
06C30:  MOVWF  FF7
06C32:  MOVLW  00
06C34:  MOVWF  FF8
06C36:  CALL   1304
....................          SendDataDisplay(); 
06C3A:  CALL   1336
....................       }else if(Digito==2){ 
06C3E:  BRA    6D8E
06C40:  MOVF   xAA,W
06C42:  SUBLW  02
06C44:  BNZ   6CA0
....................          printf("t0.txt=\"%u%u\"",Contrasena[0],Contrasena[1]); 
06C46:  MOVLW  B8
06C48:  MOVWF  FF6
06C4A:  MOVLW  05
06C4C:  MOVWF  FF7
06C4E:  MOVLW  00
06C50:  MOVWF  FF8
06C52:  MOVLW  08
06C54:  MOVLB  B
06C56:  MOVWF  x02
06C58:  MOVLB  0
06C5A:  CALL   5198
06C5E:  MOVFF  D5,B01
06C62:  MOVLW  1B
06C64:  MOVLB  B
06C66:  MOVWF  x02
06C68:  MOVLB  0
06C6A:  CALL   51F6
06C6E:  MOVFF  D6,B01
06C72:  MOVLW  1B
06C74:  MOVLB  B
06C76:  MOVWF  x02
06C78:  MOVLB  0
06C7A:  CALL   51F6
06C7E:  MOVLW  22
06C80:  BTFSS  F9E.4
06C82:  BRA    6C80
06C84:  MOVWF  FAD
....................          SendDataDisplay(); 
06C86:  CALL   1336
....................          printf("va0.val=2"); 
06C8A:  MOVLW  C6
06C8C:  MOVWF  FF6
06C8E:  MOVLW  05
06C90:  MOVWF  FF7
06C92:  MOVLW  00
06C94:  MOVWF  FF8
06C96:  CALL   1304
....................          SendDataDisplay(); 
06C9A:  CALL   1336
....................       }else if(Digito==3){ 
06C9E:  BRA    6D8E
06CA0:  MOVF   xAA,W
06CA2:  SUBLW  03
06CA4:  BNZ   6D10
....................          printf("t0.txt=\"%u%u%u\"",Contrasena[0],Contrasena[1],Contrasena[2]); 
06CA6:  MOVLW  D0
06CA8:  MOVWF  FF6
06CAA:  MOVLW  05
06CAC:  MOVWF  FF7
06CAE:  MOVLW  00
06CB0:  MOVWF  FF8
06CB2:  MOVLW  08
06CB4:  MOVLB  B
06CB6:  MOVWF  x02
06CB8:  MOVLB  0
06CBA:  CALL   5198
06CBE:  MOVFF  D5,B01
06CC2:  MOVLW  1B
06CC4:  MOVLB  B
06CC6:  MOVWF  x02
06CC8:  MOVLB  0
06CCA:  CALL   51F6
06CCE:  MOVFF  D6,B01
06CD2:  MOVLW  1B
06CD4:  MOVLB  B
06CD6:  MOVWF  x02
06CD8:  MOVLB  0
06CDA:  CALL   51F6
06CDE:  MOVFF  D7,B01
06CE2:  MOVLW  1B
06CE4:  MOVLB  B
06CE6:  MOVWF  x02
06CE8:  MOVLB  0
06CEA:  CALL   51F6
06CEE:  MOVLW  22
06CF0:  BTFSS  F9E.4
06CF2:  BRA    6CF0
06CF4:  MOVWF  FAD
....................          SendDataDisplay(); 
06CF6:  CALL   1336
....................          printf("va0.val=3"); 
06CFA:  MOVLW  E0
06CFC:  MOVWF  FF6
06CFE:  MOVLW  05
06D00:  MOVWF  FF7
06D02:  MOVLW  00
06D04:  MOVWF  FF8
06D06:  CALL   1304
....................          SendDataDisplay(); 
06D0A:  CALL   1336
....................       }else if(Digito==4){ 
06D0E:  BRA    6D8E
06D10:  MOVF   xAA,W
06D12:  SUBLW  04
06D14:  BNZ   6D8E
....................          printf("t0.txt=\"%u%u%u%u\"",Contrasena[0],Contrasena[1],Contrasena[2],Contrasena[3]); 
06D16:  MOVLW  EA
06D18:  MOVWF  FF6
06D1A:  MOVLW  05
06D1C:  MOVWF  FF7
06D1E:  MOVLW  00
06D20:  MOVWF  FF8
06D22:  MOVLW  08
06D24:  MOVLB  B
06D26:  MOVWF  x02
06D28:  MOVLB  0
06D2A:  CALL   5198
06D2E:  MOVFF  D5,B01
06D32:  MOVLW  1B
06D34:  MOVLB  B
06D36:  MOVWF  x02
06D38:  MOVLB  0
06D3A:  CALL   51F6
06D3E:  MOVFF  D6,B01
06D42:  MOVLW  1B
06D44:  MOVLB  B
06D46:  MOVWF  x02
06D48:  MOVLB  0
06D4A:  CALL   51F6
06D4E:  MOVFF  D7,B01
06D52:  MOVLW  1B
06D54:  MOVLB  B
06D56:  MOVWF  x02
06D58:  MOVLB  0
06D5A:  CALL   51F6
06D5E:  MOVFF  D8,B01
06D62:  MOVLW  1B
06D64:  MOVLB  B
06D66:  MOVWF  x02
06D68:  MOVLB  0
06D6A:  CALL   51F6
06D6E:  MOVLW  22
06D70:  BTFSS  F9E.4
06D72:  BRA    6D70
06D74:  MOVWF  FAD
....................          SendDataDisplay(); 
06D76:  CALL   1336
....................          printf("va0.val=4"); 
06D7A:  MOVLW  FC
06D7C:  MOVWF  FF6
06D7E:  MOVLW  05
06D80:  MOVWF  FF7
06D82:  MOVLW  00
06D84:  MOVWF  FF8
06D86:  CALL   1304
....................          SendDataDisplay(); 
06D8A:  CALL   1336
....................       } 
....................        
....................       if(UP){ 
06D8E:  BSF    F93.4
06D90:  BTFSC  F81.4
06D92:  BRA    6DDA
....................          delay_ms(200); 
06D94:  MOVLW  C8
06D96:  MOVLB  B
06D98:  MOVWF  x22
06D9A:  MOVLB  0
06D9C:  CALL   11F6
....................          if(UP){ 
06DA0:  BSF    F93.4
06DA2:  BTFSC  F81.4
06DA4:  BRA    6DDA
....................          if(Digito==0) 
06DA6:  MOVF   xAA,F
06DA8:  BNZ   6DAE
....................             Digito=1; 
06DAA:  MOVLW  01
06DAC:  MOVWF  xAA
....................             if(Contrasena[Digito-1]<9) 
06DAE:  MOVLW  01
06DB0:  SUBWF  xAA,W
06DB2:  CLRF   03
06DB4:  ADDLW  D5
06DB6:  MOVWF  FE9
06DB8:  MOVLW  00
06DBA:  ADDWFC 03,W
06DBC:  MOVWF  FEA
06DBE:  BTFSC  FEF.7
06DC0:  BRA    6DC8
06DC2:  MOVF   FEF,W
06DC4:  SUBLW  08
06DC6:  BNC   6DDA
....................                Contrasena[Digito-1]++; 
06DC8:  MOVLW  01
06DCA:  SUBWF  xAA,W
06DCC:  CLRF   03
06DCE:  ADDLW  D5
06DD0:  MOVWF  FE9
06DD2:  MOVLW  00
06DD4:  ADDWFC 03,W
06DD6:  MOVWF  FEA
06DD8:  INCF   FEF,F
....................          } 
....................       } 
....................        
....................       if(DOWN){ 
06DDA:  BSF    F93.5
06DDC:  BTFSC  F81.5
06DDE:  BRA    6E26
....................          delay_ms(200); 
06DE0:  MOVLW  C8
06DE2:  MOVLB  B
06DE4:  MOVWF  x22
06DE6:  MOVLB  0
06DE8:  CALL   11F6
....................          if(Digito==0) 
06DEC:  MOVF   xAA,F
06DEE:  BNZ   6DF4
....................             Digito=1; 
06DF0:  MOVLW  01
06DF2:  MOVWF  xAA
....................          if(DOWN){ 
06DF4:  BSF    F93.5
06DF6:  BTFSC  F81.5
06DF8:  BRA    6E26
....................             if(Contrasena[Digito-1]>0) 
06DFA:  MOVLW  01
06DFC:  SUBWF  xAA,W
06DFE:  CLRF   03
06E00:  ADDLW  D5
06E02:  MOVWF  FE9
06E04:  MOVLW  00
06E06:  ADDWFC 03,W
06E08:  MOVWF  FEA
06E0A:  BTFSC  FEF.7
06E0C:  BRA    6E26
06E0E:  MOVF   FEF,W
06E10:  SUBLW  00
06E12:  BC    6E26
....................                Contrasena[Digito-1]--; 
06E14:  MOVLW  01
06E16:  SUBWF  xAA,W
06E18:  CLRF   03
06E1A:  ADDLW  D5
06E1C:  MOVWF  FE9
06E1E:  MOVLW  00
06E20:  ADDWFC 03,W
06E22:  MOVWF  FEA
06E24:  DECF   FEF,F
....................          } 
....................       } 
....................        
....................       if(RIGHT){ 
06E26:  BSF    F93.6
06E28:  BTFSC  F81.6
06E2A:  BRA    6E40
....................          delay_ms(200); 
06E2C:  MOVLW  C8
06E2E:  MOVLB  B
06E30:  MOVWF  x22
06E32:  MOVLB  0
06E34:  CALL   11F6
....................          if(RIGHT){ 
06E38:  BSF    F93.6
06E3A:  BTFSC  F81.6
06E3C:  BRA    6E40
....................             Digito++; 
06E3E:  INCF   xAA,F
....................          } 
....................       } 
....................        
....................       if(Digito>4){ 
06E40:  MOVF   xAA,W
06E42:  SUBLW  04
06E44:  BTFSC  FD8.0
06E46:  BRA    71C2
....................       Digito=0; 
06E48:  CLRF   xAA
....................       printf("t0.txt=\"\""); 
06E4A:  MOVLW  06
06E4C:  MOVWF  FF6
06E4E:  MOVLW  06
06E50:  MOVWF  FF7
06E52:  MOVLW  00
06E54:  MOVWF  FF8
06E56:  CALL   1304
....................       SendDataDisplay(); 
06E5A:  CALL   1336
....................          if(TipoClave==0){ 
06E5E:  MOVF   xA8,F
06E60:  BTFSS  FD8.2
06E62:  BRA    6FA4
....................             if(Contrasena[0]==3&&Contrasena[1]==8&&Contrasena[2]==9&&Contrasena[3]==2){ // Si Ingresa clave para reset general del sistema. 
06E64:  MOVF   xD5,W
06E66:  SUBLW  03
06E68:  BTFSS  FD8.2
06E6A:  BRA    6F60
06E6C:  MOVF   xD6,W
06E6E:  SUBLW  08
06E70:  BTFSS  FD8.2
06E72:  BRA    6F60
06E74:  MOVF   xD7,W
06E76:  SUBLW  09
06E78:  BNZ   6F60
06E7A:  MOVF   xD8,W
06E7C:  SUBLW  02
06E7E:  BNZ   6F60
....................                write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contrasea de Fabrica y reinicia Programa. 
06E80:  CLRF   FAA
06E82:  CLRF   FA9
06E84:  CLRF   FA8
06E86:  BCF    FA6.6
06E88:  BCF    FA6.7
06E8A:  BSF    FA6.2
06E8C:  MOVF   FF2,W
06E8E:  MOVWF  00
06E90:  BCF    FF2.6
06E92:  BCF    FF2.7
06E94:  MOVLB  F
06E96:  MOVLW  55
06E98:  MOVWF  FA7
06E9A:  MOVLW  AA
06E9C:  MOVWF  FA7
06E9E:  BSF    FA6.1
06EA0:  BTFSC  FA6.1
06EA2:  BRA    6EA0
06EA4:  BCF    FA6.2
06EA6:  MOVF   00,W
06EA8:  IORWF  FF2,F
06EAA:  MOVLW  14
06EAC:  MOVLB  B
06EAE:  MOVWF  x22
06EB0:  MOVLB  0
06EB2:  CALL   11F6
06EB6:  CLRF   FAA
06EB8:  MOVLW  01
06EBA:  MOVWF  FA9
06EBC:  CLRF   FA8
06EBE:  BCF    FA6.6
06EC0:  BCF    FA6.7
06EC2:  BSF    FA6.2
06EC4:  MOVF   FF2,W
06EC6:  MOVWF  00
06EC8:  BCF    FF2.6
06ECA:  BCF    FF2.7
06ECC:  MOVLB  F
06ECE:  MOVLW  55
06ED0:  MOVWF  FA7
06ED2:  MOVLW  AA
06ED4:  MOVWF  FA7
06ED6:  BSF    FA6.1
06ED8:  BTFSC  FA6.1
06EDA:  BRA    6ED8
06EDC:  BCF    FA6.2
06EDE:  MOVF   00,W
06EE0:  IORWF  FF2,F
06EE2:  MOVLW  14
06EE4:  MOVLB  B
06EE6:  MOVWF  x22
06EE8:  MOVLB  0
06EEA:  CALL   11F6
....................                write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
06EEE:  CLRF   FAA
06EF0:  MOVLW  02
06EF2:  MOVWF  FA9
06EF4:  CLRF   FA8
06EF6:  BCF    FA6.6
06EF8:  BCF    FA6.7
06EFA:  BSF    FA6.2
06EFC:  MOVF   FF2,W
06EFE:  MOVWF  00
06F00:  BCF    FF2.6
06F02:  BCF    FF2.7
06F04:  MOVLB  F
06F06:  MOVLW  55
06F08:  MOVWF  FA7
06F0A:  MOVLW  AA
06F0C:  MOVWF  FA7
06F0E:  BSF    FA6.1
06F10:  BTFSC  FA6.1
06F12:  BRA    6F10
06F14:  BCF    FA6.2
06F16:  MOVF   00,W
06F18:  IORWF  FF2,F
06F1A:  MOVLW  14
06F1C:  MOVLB  B
06F1E:  MOVWF  x22
06F20:  MOVLB  0
06F22:  CALL   11F6
06F26:  CLRF   FAA
06F28:  MOVLW  03
06F2A:  MOVWF  FA9
06F2C:  CLRF   FA8
06F2E:  BCF    FA6.6
06F30:  BCF    FA6.7
06F32:  BSF    FA6.2
06F34:  MOVF   FF2,W
06F36:  MOVWF  00
06F38:  BCF    FF2.6
06F3A:  BCF    FF2.7
06F3C:  MOVLB  F
06F3E:  MOVLW  55
06F40:  MOVWF  FA7
06F42:  MOVLW  AA
06F44:  MOVWF  FA7
06F46:  BSF    FA6.1
06F48:  BTFSC  FA6.1
06F4A:  BRA    6F48
06F4C:  BCF    FA6.2
06F4E:  MOVF   00,W
06F50:  IORWF  FF2,F
06F52:  MOVLW  14
06F54:  MOVLB  B
06F56:  MOVWF  x22
06F58:  MOVLB  0
06F5A:  CALL   11F6
....................                reset_cpu(); 
06F5E:  RESET
....................             } 
....................             if((Contrasena[0]==Password[0])&&(Contrasena[1]==Password[1])&&(Contrasena[2]==Password[2])&&(Contrasena[3]==Password[3])){ 
06F60:  MOVF   xD1,W
06F62:  SUBWF  xD5,W
06F64:  BNZ   6F8E
06F66:  MOVF   xD2,W
06F68:  SUBWF  xD6,W
06F6A:  BNZ   6F8E
06F6C:  MOVF   xD3,W
06F6E:  SUBWF  xD7,W
06F70:  BNZ   6F8E
06F72:  MOVF   xD4,W
06F74:  SUBWF  xD8,W
06F76:  BNZ   6F8E
....................                printf("page ClaveCorrecta"); 
06F78:  MOVLW  10
06F7A:  MOVWF  FF6
06F7C:  MOVLW  06
06F7E:  MOVWF  FF7
06F80:  MOVLW  00
06F82:  MOVWF  FF8
06F84:  CALL   1304
....................                SendDataDisplay(); 
06F88:  CALL   1336
....................             }else{ 
06F8C:  BRA    6FA2
....................                printf("page ClaveBad"); 
06F8E:  MOVLW  24
06F90:  MOVWF  FF6
06F92:  MOVLW  06
06F94:  MOVWF  FF7
06F96:  MOVLW  00
06F98:  MOVWF  FF8
06F9A:  CALL   1304
....................                SendDataDisplay(); 
06F9E:  CALL   1336
....................             }  
....................          }else if(TipoClave==1){ 
06FA2:  BRA    71C2
06FA4:  DECFSZ xA8,W
06FA6:  BRA    6FEC
....................             if(Contrasena[0]==4&&Contrasena[1]==4&&Contrasena[2]==4&&Contrasena[3]==4){ // Si Ingresa clave de Servicio Tecnico 
06FA8:  MOVF   xD5,W
06FAA:  SUBLW  04
06FAC:  BNZ   6FD6
06FAE:  MOVF   xD6,W
06FB0:  SUBLW  04
06FB2:  BNZ   6FD6
06FB4:  MOVF   xD7,W
06FB6:  SUBLW  04
06FB8:  BNZ   6FD6
06FBA:  MOVF   xD8,W
06FBC:  SUBLW  04
06FBE:  BNZ   6FD6
....................                printf("page Config"); 
06FC0:  MOVLW  32
06FC2:  MOVWF  FF6
06FC4:  MOVLW  06
06FC6:  MOVWF  FF7
06FC8:  MOVLW  00
06FCA:  MOVWF  FF8
06FCC:  CALL   1304
....................                SendDataDisplay(); 
06FD0:  CALL   1336
....................             }else{ 
06FD4:  BRA    6FEA
....................                printf("page Ajustes"); 
06FD6:  MOVLW  3E
06FD8:  MOVWF  FF6
06FDA:  MOVLW  06
06FDC:  MOVWF  FF7
06FDE:  MOVLW  00
06FE0:  MOVWF  FF8
06FE2:  CALL   1304
....................                SendDataDisplay(); 
06FE6:  CALL   1336
....................             } 
....................          }else if(TipoClave==2){ 
06FEA:  BRA    71C2
06FEC:  MOVF   xA8,W
06FEE:  SUBLW  02
06FF0:  BNZ   704E
....................             if((Contrasena[0]==Password[0])&&(Contrasena[1]==Password[1])&&(Contrasena[2]==Password[2])&&(Contrasena[3]==Password[3])){ 
06FF2:  MOVF   xD1,W
06FF4:  SUBWF  xD5,W
06FF6:  BNZ   7038
06FF8:  MOVF   xD2,W
06FFA:  SUBWF  xD6,W
06FFC:  BNZ   7038
06FFE:  MOVF   xD3,W
07000:  SUBWF  xD7,W
07002:  BNZ   7038
07004:  MOVF   xD4,W
07006:  SUBWF  xD8,W
07008:  BNZ   7038
....................                printf("page Clave"); 
0700A:  MOVLW  4C
0700C:  MOVWF  FF6
0700E:  MOVLW  06
07010:  MOVWF  FF7
07012:  MOVLW  00
07014:  MOVWF  FF8
07016:  CALL   1304
....................                SendDataDisplay(); 
0701A:  CALL   1336
....................                printf("titulo.txt=\"Clave Nueva\""); 
0701E:  MOVLW  58
07020:  MOVWF  FF6
07022:  MOVLW  06
07024:  MOVWF  FF7
07026:  MOVLW  00
07028:  MOVWF  FF8
0702A:  CALL   1304
....................                SendDataDisplay(); 
0702E:  CALL   1336
....................                TipoClave=3; 
07032:  MOVLW  03
07034:  MOVWF  xA8
....................             }else{ 
07036:  BRA    704C
....................                printf("page Ajustes"); 
07038:  MOVLW  72
0703A:  MOVWF  FF6
0703C:  MOVLW  06
0703E:  MOVWF  FF7
07040:  MOVLW  00
07042:  MOVWF  FF8
07044:  CALL   1304
....................                SendDataDisplay(); 
07048:  CALL   1336
....................             }  
....................          }else if(TipoClave==3){ 
0704C:  BRA    71C2
0704E:  MOVF   xA8,W
07050:  SUBLW  03
07052:  BTFSS  FD8.2
07054:  BRA    71C2
....................             printf("titulo.txt=\"Clave Nueva\""); 
07056:  MOVLW  80
07058:  MOVWF  FF6
0705A:  MOVLW  06
0705C:  MOVWF  FF7
0705E:  MOVLW  00
07060:  MOVWF  FF8
07062:  CALL   1304
....................             SendDataDisplay(); 
07066:  CALL   1336
....................             printf("page Ajustes"); 
0706A:  MOVLW  9A
0706C:  MOVWF  FF6
0706E:  MOVLW  06
07070:  MOVWF  FF7
07072:  MOVLW  00
07074:  MOVWF  FF8
07076:  CALL   1304
....................             SendDataDisplay(); 
0707A:  CALL   1336
....................             if(!GuardaEEPROM){ 
0707E:  BTFSC  x7E.6
07080:  BRA    71C2
....................                write_eeprom(0,RX_Buffer[4]-0x30);delay_ms(20);write_eeprom(1,RX_Buffer[5]-0x30);delay_ms(20); 
07082:  MOVLW  30
07084:  SUBWF  35,W
07086:  MOVLB  B
07088:  MOVWF  x00
0708A:  CLRF   FAA
0708C:  CLRF   FA9
0708E:  MOVFF  B00,FA8
07092:  BCF    FA6.6
07094:  BCF    FA6.7
07096:  BSF    FA6.2
07098:  MOVF   FF2,W
0709A:  MOVWF  00
0709C:  BCF    FF2.6
0709E:  BCF    FF2.7
070A0:  MOVLB  F
070A2:  MOVLW  55
070A4:  MOVWF  FA7
070A6:  MOVLW  AA
070A8:  MOVWF  FA7
070AA:  BSF    FA6.1
070AC:  BTFSC  FA6.1
070AE:  BRA    70AC
070B0:  BCF    FA6.2
070B2:  MOVF   00,W
070B4:  IORWF  FF2,F
070B6:  MOVLW  14
070B8:  MOVLB  B
070BA:  MOVWF  x22
070BC:  MOVLB  0
070BE:  CALL   11F6
070C2:  MOVLW  30
070C4:  SUBWF  36,W
070C6:  MOVLB  B
070C8:  MOVWF  x00
070CA:  CLRF   FAA
070CC:  MOVLW  01
070CE:  MOVWF  FA9
070D0:  MOVFF  B00,FA8
070D4:  BCF    FA6.6
070D6:  BCF    FA6.7
070D8:  BSF    FA6.2
070DA:  MOVF   FF2,W
070DC:  MOVWF  00
070DE:  BCF    FF2.6
070E0:  BCF    FF2.7
070E2:  MOVLB  F
070E4:  MOVLW  55
070E6:  MOVWF  FA7
070E8:  MOVLW  AA
070EA:  MOVWF  FA7
070EC:  BSF    FA6.1
070EE:  BTFSC  FA6.1
070F0:  BRA    70EE
070F2:  BCF    FA6.2
070F4:  MOVF   00,W
070F6:  IORWF  FF2,F
070F8:  MOVLW  14
070FA:  MOVLB  B
070FC:  MOVWF  x22
070FE:  MOVLB  0
07100:  CALL   11F6
....................                write_eeprom(2,RX_Buffer[6]-0x30);delay_ms(20);write_eeprom(3,RX_Buffer[7]-0x30);delay_ms(20); 
07104:  MOVLW  30
07106:  SUBWF  37,W
07108:  MOVLB  B
0710A:  MOVWF  x00
0710C:  CLRF   FAA
0710E:  MOVLW  02
07110:  MOVWF  FA9
07112:  MOVFF  B00,FA8
07116:  BCF    FA6.6
07118:  BCF    FA6.7
0711A:  BSF    FA6.2
0711C:  MOVF   FF2,W
0711E:  MOVWF  00
07120:  BCF    FF2.6
07122:  BCF    FF2.7
07124:  MOVLB  F
07126:  MOVLW  55
07128:  MOVWF  FA7
0712A:  MOVLW  AA
0712C:  MOVWF  FA7
0712E:  BSF    FA6.1
07130:  BTFSC  FA6.1
07132:  BRA    7130
07134:  BCF    FA6.2
07136:  MOVF   00,W
07138:  IORWF  FF2,F
0713A:  MOVLW  14
0713C:  MOVLB  B
0713E:  MOVWF  x22
07140:  MOVLB  0
07142:  CALL   11F6
07146:  MOVLW  30
07148:  SUBWF  38,W
0714A:  MOVLB  B
0714C:  MOVWF  x00
0714E:  CLRF   FAA
07150:  MOVLW  03
07152:  MOVWF  FA9
07154:  MOVFF  B00,FA8
07158:  BCF    FA6.6
0715A:  BCF    FA6.7
0715C:  BSF    FA6.2
0715E:  MOVF   FF2,W
07160:  MOVWF  00
07162:  BCF    FF2.6
07164:  BCF    FF2.7
07166:  MOVLB  F
07168:  MOVLW  55
0716A:  MOVWF  FA7
0716C:  MOVLW  AA
0716E:  MOVWF  FA7
07170:  BSF    FA6.1
07172:  BTFSC  FA6.1
07174:  BRA    7172
07176:  BCF    FA6.2
07178:  MOVF   00,W
0717A:  IORWF  FF2,F
0717C:  MOVLW  14
0717E:  MOVLB  B
07180:  MOVWF  x22
07182:  MOVLB  0
07184:  CALL   11F6
....................                Password[0]=RX_Buffer[4]-0x30; 
07188:  MOVLW  30
0718A:  SUBWF  35,W
0718C:  MOVWF  xD1
....................                Password[1]=RX_Buffer[5]-0x30; 
0718E:  MOVLW  30
07190:  SUBWF  36,W
07192:  MOVWF  xD2
....................                Password[2]=RX_Buffer[6]-0x30; 
07194:  MOVLW  30
07196:  SUBWF  37,W
07198:  MOVWF  xD3
....................                Password[3]=RX_Buffer[7]-0x30; 
0719A:  MOVLW  30
0719C:  SUBWF  38,W
0719E:  MOVWF  xD4
....................                GuardaEEPROM=ON; 
071A0:  BSF    x7E.6
....................                Alarma_on;delay_ms(1000);Alarma_off; 
071A2:  BSF    F8B.0
071A4:  BCF    F94.0
071A6:  MOVLW  04
071A8:  MOVLB  B
071AA:  MOVWF  x00
071AC:  MOVLW  FA
071AE:  MOVWF  x22
071B0:  MOVLB  0
071B2:  CALL   11F6
071B6:  MOVLB  B
071B8:  DECFSZ x00,F
071BA:  BRA    71AC
071BC:  BCF    F8B.0
071BE:  BCF    F94.0
071C0:  MOVLB  0
....................             } 
....................          } 
....................       } 
....................        
....................       if(TipoClave==3){ 
071C2:  MOVF   xA8,W
071C4:  SUBLW  03
071C6:  BNZ   71F2
....................          printf("titulo.txt=\"Clave Nueva\""); 
071C8:  MOVLW  A8
071CA:  MOVWF  FF6
071CC:  MOVLW  06
071CE:  MOVWF  FF7
071D0:  MOVLW  00
071D2:  MOVWF  FF8
071D4:  CALL   1304
....................          SendDataDisplay(); 
071D8:  CALL   1336
....................          printf("doevents"); 
071DC:  MOVLW  C2
071DE:  MOVWF  FF6
071E0:  MOVLW  06
071E2:  MOVWF  FF7
071E4:  MOVLW  00
071E6:  MOVWF  FF8
071E8:  CALL   1304
....................          SendDataDisplay(); 
071EC:  CALL   1336
....................       }else if(TipoClave==2){ 
071F0:  BRA    7268
071F2:  MOVF   xA8,W
071F4:  SUBLW  02
071F6:  BNZ   7222
....................          printf("titulo.txt=\"Clave Actual\""); 
071F8:  MOVLW  CC
071FA:  MOVWF  FF6
071FC:  MOVLW  06
071FE:  MOVWF  FF7
07200:  MOVLW  00
07202:  MOVWF  FF8
07204:  CALL   1304
....................          SendDataDisplay(); 
07208:  CALL   1336
....................          printf("doevents"); 
0720C:  MOVLW  E6
0720E:  MOVWF  FF6
07210:  MOVLW  06
07212:  MOVWF  FF7
07214:  MOVLW  00
07216:  MOVWF  FF8
07218:  CALL   1304
....................          SendDataDisplay(); 
0721C:  CALL   1336
....................       }else if(TipoClave==1){ 
07220:  BRA    7268
07222:  DECFSZ xA8,W
07224:  BRA    7250
....................          printf("titulo.txt=\"Clave Tecnico\""); 
07226:  MOVLW  F0
07228:  MOVWF  FF6
0722A:  MOVLW  06
0722C:  MOVWF  FF7
0722E:  MOVLW  00
07230:  MOVWF  FF8
07232:  CALL   1304
....................          SendDataDisplay(); 
07236:  CALL   1336
....................          printf("doevents"); 
0723A:  MOVLW  0C
0723C:  MOVWF  FF6
0723E:  MOVLW  07
07240:  MOVWF  FF7
07242:  MOVLW  00
07244:  MOVWF  FF8
07246:  CALL   1304
....................          SendDataDisplay(); 
0724A:  CALL   1336
....................       }else if(TipoClave==0){ 
0724E:  BRA    7268
07250:  MOVF   xA8,F
07252:  BNZ   7268
....................          printf("titulo.txt=\"Ingrese Contrasea\""); 
07254:  MOVLW  16
07256:  MOVWF  FF6
07258:  MOVLW  07
0725A:  MOVWF  FF7
0725C:  MOVLW  00
0725E:  MOVWF  FF8
07260:  CALL   1304
....................          SendDataDisplay(); 
07264:  CALL   1336
....................       } 
....................        
....................       if(RX_Buffer[3]==0x0f){//0f, recibe caracteres ingresados desde el Display 
07268:  MOVF   34,W
0726A:  SUBLW  0F
0726C:  BTFSS  FD8.2
0726E:  BRA    764A
....................          if(TipoClave==0){ 
07270:  MOVF   xA8,F
07272:  BTFSS  FD8.2
07274:  BRA    73EE
....................             if(RX_Buffer[4]==0x33&&RX_Buffer[5]==0x38&&RX_Buffer[6]==0x39&&RX_Buffer[7]==0x32){ // Si Ingresa clave para reset general del sistema. 
07276:  MOVF   35,W
07278:  SUBLW  33
0727A:  BTFSS  FD8.2
0727C:  BRA    7372
0727E:  MOVF   36,W
07280:  SUBLW  38
07282:  BTFSS  FD8.2
07284:  BRA    7372
07286:  MOVF   37,W
07288:  SUBLW  39
0728A:  BNZ   7372
0728C:  MOVF   38,W
0728E:  SUBLW  32
07290:  BNZ   7372
....................                write_eeprom(0,0);delay_ms(20);write_eeprom(1,0);delay_ms(20);// Reestablece a contrasea de Fabrica y reinicia Programa. 
07292:  CLRF   FAA
07294:  CLRF   FA9
07296:  CLRF   FA8
07298:  BCF    FA6.6
0729A:  BCF    FA6.7
0729C:  BSF    FA6.2
0729E:  MOVF   FF2,W
072A0:  MOVWF  00
072A2:  BCF    FF2.6
072A4:  BCF    FF2.7
072A6:  MOVLB  F
072A8:  MOVLW  55
072AA:  MOVWF  FA7
072AC:  MOVLW  AA
072AE:  MOVWF  FA7
072B0:  BSF    FA6.1
072B2:  BTFSC  FA6.1
072B4:  BRA    72B2
072B6:  BCF    FA6.2
072B8:  MOVF   00,W
072BA:  IORWF  FF2,F
072BC:  MOVLW  14
072BE:  MOVLB  B
072C0:  MOVWF  x22
072C2:  MOVLB  0
072C4:  CALL   11F6
072C8:  CLRF   FAA
072CA:  MOVLW  01
072CC:  MOVWF  FA9
072CE:  CLRF   FA8
072D0:  BCF    FA6.6
072D2:  BCF    FA6.7
072D4:  BSF    FA6.2
072D6:  MOVF   FF2,W
072D8:  MOVWF  00
072DA:  BCF    FF2.6
072DC:  BCF    FF2.7
072DE:  MOVLB  F
072E0:  MOVLW  55
072E2:  MOVWF  FA7
072E4:  MOVLW  AA
072E6:  MOVWF  FA7
072E8:  BSF    FA6.1
072EA:  BTFSC  FA6.1
072EC:  BRA    72EA
072EE:  BCF    FA6.2
072F0:  MOVF   00,W
072F2:  IORWF  FF2,F
072F4:  MOVLW  14
072F6:  MOVLB  B
072F8:  MOVWF  x22
072FA:  MOVLB  0
072FC:  CALL   11F6
....................                write_eeprom(2,0);delay_ms(20);write_eeprom(3,0);delay_ms(20); 
07300:  CLRF   FAA
07302:  MOVLW  02
07304:  MOVWF  FA9
07306:  CLRF   FA8
07308:  BCF    FA6.6
0730A:  BCF    FA6.7
0730C:  BSF    FA6.2
0730E:  MOVF   FF2,W
07310:  MOVWF  00
07312:  BCF    FF2.6
07314:  BCF    FF2.7
07316:  MOVLB  F
07318:  MOVLW  55
0731A:  MOVWF  FA7
0731C:  MOVLW  AA
0731E:  MOVWF  FA7
07320:  BSF    FA6.1
07322:  BTFSC  FA6.1
07324:  BRA    7322
07326:  BCF    FA6.2
07328:  MOVF   00,W
0732A:  IORWF  FF2,F
0732C:  MOVLW  14
0732E:  MOVLB  B
07330:  MOVWF  x22
07332:  MOVLB  0
07334:  CALL   11F6
07338:  CLRF   FAA
0733A:  MOVLW  03
0733C:  MOVWF  FA9
0733E:  CLRF   FA8
07340:  BCF    FA6.6
07342:  BCF    FA6.7
07344:  BSF    FA6.2
07346:  MOVF   FF2,W
07348:  MOVWF  00
0734A:  BCF    FF2.6
0734C:  BCF    FF2.7
0734E:  MOVLB  F
07350:  MOVLW  55
07352:  MOVWF  FA7
07354:  MOVLW  AA
07356:  MOVWF  FA7
07358:  BSF    FA6.1
0735A:  BTFSC  FA6.1
0735C:  BRA    735A
0735E:  BCF    FA6.2
07360:  MOVF   00,W
07362:  IORWF  FF2,F
07364:  MOVLW  14
07366:  MOVLB  B
07368:  MOVWF  x22
0736A:  MOVLB  0
0736C:  CALL   11F6
....................                reset_cpu(); 
07370:  RESET
....................             } 
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
07372:  MOVF   35,W
07374:  SUBLW  2F
07376:  BC    73EC
07378:  MOVF   36,W
0737A:  SUBLW  2F
0737C:  BC    73EC
0737E:  MOVF   37,W
07380:  SUBLW  2F
07382:  BC    73EC
07384:  MOVF   38,W
07386:  SUBLW  2F
07388:  BC    73EC
0738A:  MOVF   35,W
0738C:  SUBLW  39
0738E:  BNC   73EC
07390:  MOVF   36,W
07392:  SUBLW  39
07394:  BNC   73EC
07396:  MOVF   37,W
07398:  SUBLW  39
0739A:  BNC   73EC
0739C:  MOVF   38,W
0739E:  SUBLW  39
073A0:  BNC   73EC
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
073A2:  MOVLW  30
073A4:  ADDWF  xD1,W
073A6:  SUBWF  35,W
073A8:  BNZ   73D8
073AA:  MOVLW  30
073AC:  ADDWF  xD2,W
073AE:  SUBWF  36,W
073B0:  BNZ   73D8
073B2:  MOVLW  30
073B4:  ADDWF  xD3,W
073B6:  SUBWF  37,W
073B8:  BNZ   73D8
073BA:  MOVLW  30
073BC:  ADDWF  xD4,W
073BE:  SUBWF  38,W
073C0:  BNZ   73D8
....................                   printf("page ClaveCorrecta"); 
073C2:  MOVLW  36
073C4:  MOVWF  FF6
073C6:  MOVLW  07
073C8:  MOVWF  FF7
073CA:  MOVLW  00
073CC:  MOVWF  FF8
073CE:  CALL   1304
....................                   SendDataDisplay(); 
073D2:  CALL   1336
....................                }else{ 
073D6:  BRA    73EC
....................                   printf("page ClaveBad"); 
073D8:  MOVLW  4A
073DA:  MOVWF  FF6
073DC:  MOVLW  07
073DE:  MOVWF  FF7
073E0:  MOVLW  00
073E2:  MOVWF  FF8
073E4:  CALL   1304
....................                   SendDataDisplay(); 
073E8:  CALL   1336
....................                }  
....................             } 
....................          }else if(TipoClave==1){ 
073EC:  BRA    764A
073EE:  DECFSZ xA8,W
073F0:  BRA    7436
....................             if(RX_Buffer[4]==0x34&&RX_Buffer[5]==0x34&&RX_Buffer[6]==0x34&&RX_Buffer[7]==0x34){ // Si Ingresa clave de Servicio Tecnico 
073F2:  MOVF   35,W
073F4:  SUBLW  34
073F6:  BNZ   7420
073F8:  MOVF   36,W
073FA:  SUBLW  34
073FC:  BNZ   7420
073FE:  MOVF   37,W
07400:  SUBLW  34
07402:  BNZ   7420
07404:  MOVF   38,W
07406:  SUBLW  34
07408:  BNZ   7420
....................                printf("page Config"); 
0740A:  MOVLW  58
0740C:  MOVWF  FF6
0740E:  MOVLW  07
07410:  MOVWF  FF7
07412:  MOVLW  00
07414:  MOVWF  FF8
07416:  CALL   1304
....................                SendDataDisplay(); 
0741A:  CALL   1336
....................             }else{ 
0741E:  BRA    7434
....................                printf("page Ajustes"); 
07420:  MOVLW  64
07422:  MOVWF  FF6
07424:  MOVLW  07
07426:  MOVWF  FF7
07428:  MOVLW  00
0742A:  MOVWF  FF8
0742C:  CALL   1304
....................                SendDataDisplay(); 
07430:  CALL   1336
....................             } 
....................          }else if(TipoClave==2){ 
07434:  BRA    764A
07436:  MOVF   xA8,W
07438:  SUBLW  02
0743A:  BNZ   74D6
....................             if(RX_Buffer[4]>=0x30 && RX_Buffer[5]>=0x30 && RX_Buffer[6]>=0x30 && RX_Buffer[7]>=0x30 
....................             && RX_Buffer[4]<=0x39 && RX_Buffer[5]<=0x39 && RX_Buffer[6]<=0x39 && RX_Buffer[7]<=0x39){ 
0743C:  MOVF   35,W
0743E:  SUBLW  2F
07440:  BC    74D4
07442:  MOVF   36,W
07444:  SUBLW  2F
07446:  BC    74D4
07448:  MOVF   37,W
0744A:  SUBLW  2F
0744C:  BC    74D4
0744E:  MOVF   38,W
07450:  SUBLW  2F
07452:  BC    74D4
07454:  MOVF   35,W
07456:  SUBLW  39
07458:  BNC   74D4
0745A:  MOVF   36,W
0745C:  SUBLW  39
0745E:  BNC   74D4
07460:  MOVF   37,W
07462:  SUBLW  39
07464:  BNC   74D4
07466:  MOVF   38,W
07468:  SUBLW  39
0746A:  BNC   74D4
....................             if((RX_Buffer[4]==Password[0]+0x30)&&(RX_Buffer[5]==Password[1]+0x30)&&(RX_Buffer[6]==Password[2]+0x30)&&(RX_Buffer[7]==Password[3]+0x30)){ 
0746C:  MOVLW  30
0746E:  ADDWF  xD1,W
07470:  SUBWF  35,W
07472:  BNZ   74C0
07474:  MOVLW  30
07476:  ADDWF  xD2,W
07478:  SUBWF  36,W
0747A:  BNZ   74C0
0747C:  MOVLW  30
0747E:  ADDWF  xD3,W
07480:  SUBWF  37,W
07482:  BNZ   74C0
07484:  MOVLW  30
07486:  ADDWF  xD4,W
07488:  SUBWF  38,W
0748A:  BNZ   74C0
....................                printf("page Clave"); 
0748C:  MOVLW  72
0748E:  MOVWF  FF6
07490:  MOVLW  07
07492:  MOVWF  FF7
07494:  MOVLW  00
07496:  MOVWF  FF8
07498:  CALL   1304
....................                SendDataDisplay();                
0749C:  CALL   1336
....................                printf("titulo.txt=\"Clave Nueva\""); 
074A0:  MOVLW  7E
074A2:  MOVWF  FF6
074A4:  MOVLW  07
074A6:  MOVWF  FF7
074A8:  MOVLW  00
074AA:  MOVWF  FF8
074AC:  CALL   1304
....................                SendDataDisplay(); 
074B0:  CALL   1336
....................                TipoClave=3;                
074B4:  MOVLW  03
074B6:  MOVWF  xA8
....................                GuardaEEPROM=0; 
074B8:  BCF    x7E.6
....................                RX_Buffer[3]=0x00;RX_Buffer2[3]=0x00;   
074BA:  CLRF   34
074BC:  CLRF   3F
....................             }else{ 
074BE:  BRA    74D4
....................                printf("page Ajustes"); 
074C0:  MOVLW  98
074C2:  MOVWF  FF6
074C4:  MOVLW  07
074C6:  MOVWF  FF7
074C8:  MOVLW  00
074CA:  MOVWF  FF8
074CC:  CALL   1304
....................                SendDataDisplay();                
074D0:  CALL   1336
....................                //RX_Buffer[3]=0x00;RX_Buffer2[3]=0x00;   
....................             }  
....................             } 
....................          }else if(TipoClave==3){ 
074D4:  BRA    764A
074D6:  MOVF   xA8,W
074D8:  SUBLW  03
074DA:  BTFSS  FD8.2
074DC:  BRA    764A
....................             printf("titulo.txt=\"Clave Nueva\""); 
074DE:  MOVLW  A6
074E0:  MOVWF  FF6
074E2:  MOVLW  07
074E4:  MOVWF  FF7
074E6:  MOVLW  00
074E8:  MOVWF  FF8
074EA:  CALL   1304
....................             SendDataDisplay(); 
074EE:  CALL   1336
....................             printf("page Ajustes"); 
074F2:  MOVLW  C0
074F4:  MOVWF  FF6
074F6:  MOVLW  07
074F8:  MOVWF  FF7
074FA:  MOVLW  00
074FC:  MOVWF  FF8
074FE:  CALL   1304
....................             SendDataDisplay(); 
07502:  CALL   1336
....................             if(!GuardaEEPROM){ 
07506:  BTFSC  x7E.6
07508:  BRA    764A
....................                write_eeprom(0,RX_Buffer[4]-0x30);delay_ms(20);write_eeprom(1,RX_Buffer[5]-0x30);delay_ms(20); 
0750A:  MOVLW  30
0750C:  SUBWF  35,W
0750E:  MOVLB  B
07510:  MOVWF  x00
07512:  CLRF   FAA
07514:  CLRF   FA9
07516:  MOVFF  B00,FA8
0751A:  BCF    FA6.6
0751C:  BCF    FA6.7
0751E:  BSF    FA6.2
07520:  MOVF   FF2,W
07522:  MOVWF  00
07524:  BCF    FF2.6
07526:  BCF    FF2.7
07528:  MOVLB  F
0752A:  MOVLW  55
0752C:  MOVWF  FA7
0752E:  MOVLW  AA
07530:  MOVWF  FA7
07532:  BSF    FA6.1
07534:  BTFSC  FA6.1
07536:  BRA    7534
07538:  BCF    FA6.2
0753A:  MOVF   00,W
0753C:  IORWF  FF2,F
0753E:  MOVLW  14
07540:  MOVLB  B
07542:  MOVWF  x22
07544:  MOVLB  0
07546:  CALL   11F6
0754A:  MOVLW  30
0754C:  SUBWF  36,W
0754E:  MOVLB  B
07550:  MOVWF  x00
07552:  CLRF   FAA
07554:  MOVLW  01
07556:  MOVWF  FA9
07558:  MOVFF  B00,FA8
0755C:  BCF    FA6.6
0755E:  BCF    FA6.7
07560:  BSF    FA6.2
07562:  MOVF   FF2,W
07564:  MOVWF  00
07566:  BCF    FF2.6
07568:  BCF    FF2.7
0756A:  MOVLB  F
0756C:  MOVLW  55
0756E:  MOVWF  FA7
07570:  MOVLW  AA
07572:  MOVWF  FA7
07574:  BSF    FA6.1
07576:  BTFSC  FA6.1
07578:  BRA    7576
0757A:  BCF    FA6.2
0757C:  MOVF   00,W
0757E:  IORWF  FF2,F
07580:  MOVLW  14
07582:  MOVLB  B
07584:  MOVWF  x22
07586:  MOVLB  0
07588:  CALL   11F6
....................                write_eeprom(2,RX_Buffer[6]-0x30);delay_ms(20);write_eeprom(3,RX_Buffer[7]-0x30);delay_ms(20); 
0758C:  MOVLW  30
0758E:  SUBWF  37,W
07590:  MOVLB  B
07592:  MOVWF  x00
07594:  CLRF   FAA
07596:  MOVLW  02
07598:  MOVWF  FA9
0759A:  MOVFF  B00,FA8
0759E:  BCF    FA6.6
075A0:  BCF    FA6.7
075A2:  BSF    FA6.2
075A4:  MOVF   FF2,W
075A6:  MOVWF  00
075A8:  BCF    FF2.6
075AA:  BCF    FF2.7
075AC:  MOVLB  F
075AE:  MOVLW  55
075B0:  MOVWF  FA7
075B2:  MOVLW  AA
075B4:  MOVWF  FA7
075B6:  BSF    FA6.1
075B8:  BTFSC  FA6.1
075BA:  BRA    75B8
075BC:  BCF    FA6.2
075BE:  MOVF   00,W
075C0:  IORWF  FF2,F
075C2:  MOVLW  14
075C4:  MOVLB  B
075C6:  MOVWF  x22
075C8:  MOVLB  0
075CA:  CALL   11F6
075CE:  MOVLW  30
075D0:  SUBWF  38,W
075D2:  MOVLB  B
075D4:  MOVWF  x00
075D6:  CLRF   FAA
075D8:  MOVLW  03
075DA:  MOVWF  FA9
075DC:  MOVFF  B00,FA8
075E0:  BCF    FA6.6
075E2:  BCF    FA6.7
075E4:  BSF    FA6.2
075E6:  MOVF   FF2,W
075E8:  MOVWF  00
075EA:  BCF    FF2.6
075EC:  BCF    FF2.7
075EE:  MOVLB  F
075F0:  MOVLW  55
075F2:  MOVWF  FA7
075F4:  MOVLW  AA
075F6:  MOVWF  FA7
075F8:  BSF    FA6.1
075FA:  BTFSC  FA6.1
075FC:  BRA    75FA
075FE:  BCF    FA6.2
07600:  MOVF   00,W
07602:  IORWF  FF2,F
07604:  MOVLW  14
07606:  MOVLB  B
07608:  MOVWF  x22
0760A:  MOVLB  0
0760C:  CALL   11F6
....................                Password[0]=RX_Buffer[4]-0x30; 
07610:  MOVLW  30
07612:  SUBWF  35,W
07614:  MOVWF  xD1
....................                Password[1]=RX_Buffer[5]-0x30; 
07616:  MOVLW  30
07618:  SUBWF  36,W
0761A:  MOVWF  xD2
....................                Password[2]=RX_Buffer[6]-0x30; 
0761C:  MOVLW  30
0761E:  SUBWF  37,W
07620:  MOVWF  xD3
....................                Password[3]=RX_Buffer[7]-0x30; 
07622:  MOVLW  30
07624:  SUBWF  38,W
07626:  MOVWF  xD4
....................                GuardaEEPROM=ON; 
07628:  BSF    x7E.6
....................                Alarma_on;delay_ms(1000);Alarma_off; 
0762A:  BSF    F8B.0
0762C:  BCF    F94.0
0762E:  MOVLW  04
07630:  MOVLB  B
07632:  MOVWF  x00
07634:  MOVLW  FA
07636:  MOVWF  x22
07638:  MOVLB  0
0763A:  CALL   11F6
0763E:  MOVLB  B
07640:  DECFSZ x00,F
07642:  BRA    7634
07644:  BCF    F8B.0
07646:  BCF    F94.0
07648:  MOVLB  0
....................             } 
....................          } 
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==1){ //Menu Principal 
0764A:  DECFSZ x81,W
0764C:  BRA    7822
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
0764E:  MOVLW  CE
07650:  MOVWF  FF6
07652:  MOVLW  07
07654:  MOVWF  FF7
07656:  MOVLW  00
07658:  MOVWF  FF8
0765A:  MOVLW  11
0765C:  MOVLB  B
0765E:  MOVWF  x02
07660:  MOVLB  0
07662:  CALL   5198
07666:  MOVFF  98,B01
0766A:  MOVLW  01
0766C:  MOVLB  B
0766E:  MOVWF  x02
07670:  MOVLB  0
07672:  CALL   51F6
07676:  MOVLW  2F
07678:  BTFSS  F9E.4
0767A:  BRA    7678
0767C:  MOVWF  FAD
0767E:  MOVFF  97,B01
07682:  MOVLW  01
07684:  MOVLB  B
07686:  MOVWF  x02
07688:  MOVLB  0
0768A:  CALL   51F6
0768E:  MOVLW  2F
07690:  BTFSS  F9E.4
07692:  BRA    7690
07694:  MOVWF  FAD
07696:  MOVLW  32
07698:  BTFSS  F9E.4
0769A:  BRA    7698
0769C:  MOVWF  FAD
0769E:  MOVLW  30
076A0:  BTFSS  F9E.4
076A2:  BRA    76A0
076A4:  MOVWF  FAD
076A6:  MOVFF  96,B01
076AA:  MOVLW  01
076AC:  MOVLB  B
076AE:  MOVWF  x02
076B0:  MOVLB  0
076B2:  CALL   51F6
076B6:  MOVLW  EF
076B8:  MOVWF  FF6
076BA:  MOVLW  07
076BC:  MOVWF  FF7
076BE:  MOVLW  00
076C0:  MOVWF  FF8
076C2:  MOVLW  0A
076C4:  MOVLB  B
076C6:  MOVWF  x02
076C8:  MOVLB  0
076CA:  CALL   5198
076CE:  MOVFF  99,B01
076D2:  MOVLW  01
076D4:  MOVLB  B
076D6:  MOVWF  x02
076D8:  MOVLB  0
076DA:  CALL   51F6
076DE:  MOVLW  3A
076E0:  BTFSS  F9E.4
076E2:  BRA    76E0
076E4:  MOVWF  FAD
076E6:  MOVFF  9A,B01
076EA:  MOVLW  01
076EC:  MOVLB  B
076EE:  MOVWF  x02
076F0:  MOVLB  0
076F2:  CALL   51F6
076F6:  MOVLW  3A
076F8:  BTFSS  F9E.4
076FA:  BRA    76F8
076FC:  MOVWF  FAD
076FE:  MOVFF  9B,B01
07702:  MOVLW  01
07704:  MOVLB  B
07706:  MOVWF  x02
07708:  MOVLB  0
0770A:  CALL   51F6
0770E:  MOVLW  20
07710:  BTFSS  F9E.4
07712:  BRA    7710
07714:  MOVWF  FAD
07716:  MOVLW  20
07718:  BTFSS  F9E.4
0771A:  BRA    7718
0771C:  MOVWF  FAD
0771E:  MOVLW  22
07720:  BTFSS  F9E.4
07722:  BRA    7720
07724:  MOVWF  FAD
....................          SendDataDisplay(); 
07726:  CALL   1336
....................          SendDataDisplay(); 
0772A:  CALL   1336
....................          GuardaEEPROM=OFF; 
0772E:  BCF    x7E.6
....................          LuzBlanca_off;LuzUV_off; 
07730:  BSF    F8C.0
07732:  BCF    F95.0
07734:  BSF    F8C.1
07736:  BCF    F95.1
....................           
....................          if(RX_Buffer[4]==0x01){//Selecciono Tiempo Purga 
07738:  DECFSZ 35,W
0773A:  BRA    7750
....................             printf("page TiempoPurga"); 
0773C:  MOVLW  0C
0773E:  MOVWF  FF6
07740:  MOVLW  08
07742:  MOVWF  FF7
07744:  MOVLW  00
07746:  MOVWF  FF8
07748:  CALL   1304
....................             SendDataDisplay(); 
0774C:  CALL   1336
....................          } 
....................           
....................          if(RX_Buffer[4]==0x02){//Selecciono Tiempo UV 
07750:  MOVF   35,W
07752:  SUBLW  02
07754:  BNZ   776A
....................             printf("page TiempoUV"); 
07756:  MOVLW  1E
07758:  MOVWF  FF6
0775A:  MOVLW  08
0775C:  MOVWF  FF7
0775E:  MOVLW  00
07760:  MOVWF  FF8
07762:  CALL   1304
....................             SendDataDisplay();             
07766:  CALL   1336
....................          } 
....................           
....................          if(RX_Buffer[4]==0x03){//Selecciono Tiempo Post Purga 
0776A:  MOVF   35,W
0776C:  SUBLW  03
0776E:  BNZ   7784
....................             printf("page TimePostP"); 
07770:  MOVLW  2C
07772:  MOVWF  FF6
07774:  MOVLW  08
07776:  MOVWF  FF7
07778:  MOVLW  00
0777A:  MOVWF  FF8
0777C:  CALL   1304
....................             SendDataDisplay();             
07780:  CALL   1336
....................          } 
....................           
....................          if(RX_Buffer[4]==0x04){//Selecciono Mantenimiento 
07784:  MOVF   35,W
07786:  SUBLW  04
07788:  BNZ   779E
....................             printf("page Mto"); 
0778A:  MOVLW  3C
0778C:  MOVWF  FF6
0778E:  MOVLW  08
07790:  MOVWF  FF7
07792:  MOVLW  00
07794:  MOVWF  FF8
07796:  CALL   1304
....................             SendDataDisplay();             
0779A:  CALL   1336
....................          } 
....................           
....................          if(RX_Buffer[4]==0x05){//Selecciono Hora y Fecha 
0779E:  MOVF   35,W
077A0:  SUBLW  05
077A2:  BNZ   77CC
....................             printf("page Fecha"); 
077A4:  MOVLW  46
077A6:  MOVWF  FF6
077A8:  MOVLW  08
077AA:  MOVWF  FF7
077AC:  MOVLW  00
077AE:  MOVWF  FF8
077B0:  CALL   1304
....................             SendDataDisplay(); 
077B4:  CALL   1336
....................             DiaTx=Dia; 
077B8:  MOVFF  98,A1
....................             MesTx=Mes; 
077BC:  MOVFF  97,A0
....................             YearTx=Year; 
077C0:  MOVFF  96,9F
....................             HoraTx=Hora; 
077C4:  MOVFF  99,A2
....................             MinutoTx=Minuto; 
077C8:  MOVFF  9A,A3
....................          } 
....................           
....................          if(RX_Buffer[4]==0x06){//Selecciono Cambio de Clave 
077CC:  MOVF   35,W
077CE:  SUBLW  06
077D0:  BNZ   77EA
....................             printf("page Clave"); 
077D2:  MOVLW  52
077D4:  MOVWF  FF6
077D6:  MOVLW  08
077D8:  MOVWF  FF7
077DA:  MOVLW  00
077DC:  MOVWF  FF8
077DE:  CALL   1304
....................             SendDataDisplay();             
077E2:  CALL   1336
....................             TipoClave=2; 
077E6:  MOVLW  02
077E8:  MOVWF  xA8
....................          } 
....................           
....................          if(RX_Buffer[4]==0xa0){//Selecciono Servicio 
077EA:  MOVF   35,W
077EC:  SUBLW  A0
077EE:  BNZ   7808
....................             printf("page Clave"); 
077F0:  MOVLW  5E
077F2:  MOVWF  FF6
077F4:  MOVLW  08
077F6:  MOVWF  FF7
077F8:  MOVLW  00
077FA:  MOVWF  FF8
077FC:  CALL   1304
....................             SendDataDisplay();             
07800:  CALL   1336
....................             TipoClave=1; 
07804:  MOVLW  01
07806:  MOVWF  xA8
....................          } 
....................           
....................          if(RX_Buffer[4]==0xb0){//Selecciono Regresar 
07808:  MOVF   35,W
0780A:  SUBLW  B0
0780C:  BNZ   7822
....................             printf("page Principal"); 
0780E:  MOVLW  6A
07810:  MOVWF  FF6
07812:  MOVLW  08
07814:  MOVWF  FF7
07816:  MOVLW  00
07818:  MOVWF  FF8
0781A:  CALL   1304
....................             SendDataDisplay();                         
0781E:  CALL   1336
....................          } 
....................       } 
....................  //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==2){ //Menu de Tiempo de Purga 
07822:  MOVF   x81,W
07824:  SUBLW  02
07826:  BTFSS  FD8.2
07828:  BRA    7B50
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
0782A:  MOVLW  7A
0782C:  MOVWF  FF6
0782E:  MOVLW  08
07830:  MOVWF  FF7
07832:  MOVLW  00
07834:  MOVWF  FF8
07836:  MOVLW  11
07838:  MOVLB  B
0783A:  MOVWF  x02
0783C:  MOVLB  0
0783E:  CALL   5198
07842:  MOVFF  98,B01
07846:  MOVLW  01
07848:  MOVLB  B
0784A:  MOVWF  x02
0784C:  MOVLB  0
0784E:  CALL   51F6
07852:  MOVLW  2F
07854:  BTFSS  F9E.4
07856:  BRA    7854
07858:  MOVWF  FAD
0785A:  MOVFF  97,B01
0785E:  MOVLW  01
07860:  MOVLB  B
07862:  MOVWF  x02
07864:  MOVLB  0
07866:  CALL   51F6
0786A:  MOVLW  2F
0786C:  BTFSS  F9E.4
0786E:  BRA    786C
07870:  MOVWF  FAD
07872:  MOVLW  32
07874:  BTFSS  F9E.4
07876:  BRA    7874
07878:  MOVWF  FAD
0787A:  MOVLW  30
0787C:  BTFSS  F9E.4
0787E:  BRA    787C
07880:  MOVWF  FAD
07882:  MOVFF  96,B01
07886:  MOVLW  01
07888:  MOVLB  B
0788A:  MOVWF  x02
0788C:  MOVLB  0
0788E:  CALL   51F6
07892:  MOVLW  9B
07894:  MOVWF  FF6
07896:  MOVLW  08
07898:  MOVWF  FF7
0789A:  MOVLW  00
0789C:  MOVWF  FF8
0789E:  MOVLW  0A
078A0:  MOVLB  B
078A2:  MOVWF  x02
078A4:  MOVLB  0
078A6:  CALL   5198
078AA:  MOVFF  99,B01
078AE:  MOVLW  01
078B0:  MOVLB  B
078B2:  MOVWF  x02
078B4:  MOVLB  0
078B6:  CALL   51F6
078BA:  MOVLW  3A
078BC:  BTFSS  F9E.4
078BE:  BRA    78BC
078C0:  MOVWF  FAD
078C2:  MOVFF  9A,B01
078C6:  MOVLW  01
078C8:  MOVLB  B
078CA:  MOVWF  x02
078CC:  MOVLB  0
078CE:  CALL   51F6
078D2:  MOVLW  3A
078D4:  BTFSS  F9E.4
078D6:  BRA    78D4
078D8:  MOVWF  FAD
078DA:  MOVFF  9B,B01
078DE:  MOVLW  01
078E0:  MOVLB  B
078E2:  MOVWF  x02
078E4:  MOVLB  0
078E6:  CALL   51F6
078EA:  MOVLW  20
078EC:  BTFSS  F9E.4
078EE:  BRA    78EC
078F0:  MOVWF  FAD
078F2:  MOVLW  20
078F4:  BTFSS  F9E.4
078F6:  BRA    78F4
078F8:  MOVWF  FAD
078FA:  MOVLW  22
078FC:  BTFSS  F9E.4
078FE:  BRA    78FC
07900:  MOVWF  FAD
....................          SendDataDisplay(); 
07902:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
07906:  MOVF   35,W
07908:  SUBLW  0A
0790A:  BNZ   7910
....................             Minutos=ON; 
0790C:  BSF    x7E.7
....................             Segundos=OFF; 
0790E:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
07910:  MOVF   35,W
07912:  SUBLW  0B
07914:  BNZ   791A
....................             Segundos=ON; 
07916:  BSF    x7F.0
....................             Minutos=OFF; 
07918:  BCF    x7E.7
....................          }            
....................           
....................          if(RIGHT){ 
0791A:  BSF    F93.6
0791C:  BTFSC  F81.6
0791E:  BRA    7994
....................             delay_ms(200); 
07920:  MOVLW  C8
07922:  MOVLB  B
07924:  MOVWF  x22
07926:  MOVLB  0
07928:  CALL   11F6
....................             if(RIGHT){ 
0792C:  BSF    F93.6
0792E:  BTFSC  F81.6
07930:  BRA    7994
....................                if(!Segundos){ 
07932:  BTFSC  x7F.0
07934:  BRA    7964
....................                   Segundos=ON; 
07936:  BSF    x7F.0
....................                   Minutos=OFF; 
07938:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
0793A:  MOVLW  B8
0793C:  MOVWF  FF6
0793E:  MOVLW  08
07940:  MOVWF  FF7
07942:  MOVLW  00
07944:  MOVWF  FF8
07946:  CALL   1304
....................                   SendDataDisplay();   
0794A:  CALL   1336
....................                   printf("tminest.pco=0"); 
0794E:  MOVLW  CA
07950:  MOVWF  FF6
07952:  MOVLW  08
07954:  MOVWF  FF7
07956:  MOVLW  00
07958:  MOVWF  FF8
0795A:  CALL   1304
....................                   SendDataDisplay();   
0795E:  CALL   1336
....................                }else if(!Minutos){ 
07962:  BRA    7994
07964:  BTFSC  x7E.7
07966:  BRA    7994
....................                   Segundos=OFF; 
07968:  BCF    x7F.0
....................                   Minutos=ON; 
0796A:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
0796C:  MOVLW  D8
0796E:  MOVWF  FF6
07970:  MOVLW  08
07972:  MOVWF  FF7
07974:  MOVLW  00
07976:  MOVWF  FF8
07978:  CALL   1304
....................                   SendDataDisplay();   
0797C:  CALL   1336
....................                   printf("tminest.pco=65535"); 
07980:  MOVLW  E6
07982:  MOVWF  FF6
07984:  MOVLW  08
07986:  MOVWF  FF7
07988:  MOVLW  00
0798A:  MOVWF  FF8
0798C:  CALL   1304
....................                   SendDataDisplay();   
07990:  CALL   1336
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
07994:  MOVF   35,W
07996:  SUBLW  11
07998:  BZ    79A0
0799A:  BSF    F93.7
0799C:  BTFSC  F81.7
0799E:  BRA    7A4A
....................             delay_ms(200); 
079A0:  MOVLW  C8
079A2:  MOVLB  B
079A4:  MOVWF  x22
079A6:  MOVLB  0
079A8:  CALL   11F6
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
079AC:  MOVF   35,W
079AE:  SUBLW  11
079B0:  BZ    79B8
079B2:  BSF    F93.7
079B4:  BTFSC  F81.7
079B6:  BRA    7A4A
....................                Segundos=OFF; 
079B8:  BCF    x7F.0
....................                Minutos=OFF; 
079BA:  BCF    x7E.7
....................                printf("page Ajustes"); 
079BC:  MOVLW  F8
079BE:  MOVWF  FF6
079C0:  MOVLW  08
079C2:  MOVWF  FF7
079C4:  MOVLW  00
079C6:  MOVWF  FF8
079C8:  CALL   1304
....................                SendDataDisplay();   
079CC:  CALL   1336
....................                if(!GuardaEEPROM){ 
079D0:  BTFSC  x7E.6
079D2:  BRA    7A4A
....................                   write_eeprom(4,mPurgap); 
079D4:  CLRF   FAA
079D6:  MOVLW  04
079D8:  MOVWF  FA9
079DA:  MOVFF  AF,FA8
079DE:  BCF    FA6.6
079E0:  BCF    FA6.7
079E2:  BSF    FA6.2
079E4:  MOVF   FF2,W
079E6:  MOVWF  00
079E8:  BCF    FF2.6
079EA:  BCF    FF2.7
079EC:  MOVLB  F
079EE:  MOVLW  55
079F0:  MOVWF  FA7
079F2:  MOVLW  AA
079F4:  MOVWF  FA7
079F6:  BSF    FA6.1
079F8:  BTFSC  FA6.1
079FA:  BRA    79F8
079FC:  BCF    FA6.2
079FE:  MOVF   00,W
07A00:  IORWF  FF2,F
....................                   delay_ms(10); 
07A02:  MOVLW  0A
07A04:  MOVLB  B
07A06:  MOVWF  x22
07A08:  MOVLB  0
07A0A:  CALL   11F6
....................                   write_eeprom(5,sPurgap); 
07A0E:  CLRF   FAA
07A10:  MOVLW  05
07A12:  MOVWF  FA9
07A14:  MOVFF  AD,FA8
07A18:  BCF    FA6.6
07A1A:  BCF    FA6.7
07A1C:  BSF    FA6.2
07A1E:  MOVF   FF2,W
07A20:  MOVWF  00
07A22:  BCF    FF2.6
07A24:  BCF    FF2.7
07A26:  MOVLB  F
07A28:  MOVLW  55
07A2A:  MOVWF  FA7
07A2C:  MOVLW  AA
07A2E:  MOVWF  FA7
07A30:  BSF    FA6.1
07A32:  BTFSC  FA6.1
07A34:  BRA    7A32
07A36:  BCF    FA6.2
07A38:  MOVF   00,W
07A3A:  IORWF  FF2,F
....................                   delay_ms(10); 
07A3C:  MOVLW  0A
07A3E:  MOVLB  B
07A40:  MOVWF  x22
07A42:  MOVLB  0
07A44:  CALL   11F6
....................                   //mPurga=mPurgap; 
....................                   //sPurga=sPurgap; 
....................                   GuardaEEPROM=ON; 
07A48:  BSF    x7E.6
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07A4A:  MOVF   35,W
07A4C:  SUBLW  0C
07A4E:  BZ    7A5C
07A50:  MOVF   35,W
07A52:  SUBLW  0D
07A54:  BZ    7A5C
07A56:  BSF    F93.4
07A58:  BTFSC  F81.4
07A5A:  BRA    7A8A
....................             delay_ms(10); 
07A5C:  MOVLW  0A
07A5E:  MOVLB  B
07A60:  MOVWF  x22
07A62:  MOVLB  0
07A64:  CALL   11F6
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07A68:  MOVF   35,W
07A6A:  SUBLW  0C
07A6C:  BZ    7A7A
07A6E:  MOVF   35,W
07A70:  SUBLW  0D
07A72:  BZ    7A7A
07A74:  BSF    F93.4
07A76:  BTFSC  F81.4
07A78:  BRA    7A8A
....................                if(Segundos){ 
07A7A:  BTFSS  x7F.0
07A7C:  BRA    7A80
....................                   sPurgap++; 
07A7E:  INCF   xAD,F
....................                } 
....................                if(Minutos){ 
07A80:  BTFSS  x7E.7
07A82:  BRA    7A86
....................                   mPurgap++; 
07A84:  INCF   xAF,F
....................                }   
....................                RX_Buffer[4]=0x00;   
07A86:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07A88:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07A8A:  MOVF   35,W
07A8C:  SUBLW  0F
07A8E:  BZ    7A9C
07A90:  MOVF   35,W
07A92:  SUBLW  0E
07A94:  BZ    7A9C
07A96:  BSF    F93.5
07A98:  BTFSC  F81.5
07A9A:  BRA    7ACE
....................             delay_ms(10); 
07A9C:  MOVLW  0A
07A9E:  MOVLB  B
07AA0:  MOVWF  x22
07AA2:  MOVLB  0
07AA4:  CALL   11F6
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07AA8:  MOVF   35,W
07AAA:  SUBLW  0F
07AAC:  BZ    7ABA
07AAE:  MOVF   35,W
07AB0:  SUBLW  0E
07AB2:  BZ    7ABA
07AB4:  BSF    F93.5
07AB6:  BTFSC  F81.5
07AB8:  BRA    7ACE
....................                if(Segundos && sPurgap>0){ 
07ABA:  BTFSS  x7F.0
07ABC:  BRA    7AC4
07ABE:  MOVF   xAD,F
07AC0:  BZ    7AC4
....................                   sPurgap--; 
07AC2:  DECF   xAD,F
....................                } 
....................                if(Minutos){ 
07AC4:  BTFSS  x7E.7
07AC6:  BRA    7ACA
....................                   mPurgap--; 
07AC8:  DECF   xAF,F
....................                } 
....................                RX_Buffer[4]=0x00;   
07ACA:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07ACC:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mPurgap<1)mPurgap=99; 
07ACE:  MOVF   xAF,F
07AD0:  BNZ   7AD6
07AD2:  MOVLW  63
07AD4:  MOVWF  xAF
....................          if(mPurgap>99)mPurgap=1; 
07AD6:  MOVF   xAF,W
07AD8:  SUBLW  63
07ADA:  BC    7AE0
07ADC:  MOVLW  01
07ADE:  MOVWF  xAF
....................          if(sPurgap>59)sPurgap=0; 
07AE0:  MOVF   xAD,W
07AE2:  SUBLW  3B
07AE4:  BTFSS  FD8.0
07AE6:  CLRF   xAD
....................              
....................          printf("tminest.txt=\"%02u\"",mPurgap); 
07AE8:  MOVLW  06
07AEA:  MOVWF  FF6
07AEC:  MOVLW  09
07AEE:  MOVWF  FF7
07AF0:  MOVLW  00
07AF2:  MOVWF  FF8
07AF4:  MOVLW  0D
07AF6:  MOVLB  B
07AF8:  MOVWF  x02
07AFA:  MOVLB  0
07AFC:  CALL   5198
07B00:  MOVFF  AF,B01
07B04:  MOVLW  01
07B06:  MOVLB  B
07B08:  MOVWF  x02
07B0A:  MOVLB  0
07B0C:  CALL   51F6
07B10:  MOVLW  22
07B12:  BTFSS  F9E.4
07B14:  BRA    7B12
07B16:  MOVWF  FAD
....................          SendDataDisplay(); 
07B18:  CALL   1336
....................          printf("tsecest.txt=\"%02u\"",sPurgap); 
07B1C:  MOVLW  1A
07B1E:  MOVWF  FF6
07B20:  MOVLW  09
07B22:  MOVWF  FF7
07B24:  MOVLW  00
07B26:  MOVWF  FF8
07B28:  MOVLW  0D
07B2A:  MOVLB  B
07B2C:  MOVWF  x02
07B2E:  MOVLB  0
07B30:  CALL   5198
07B34:  MOVFF  AD,B01
07B38:  MOVLW  01
07B3A:  MOVLB  B
07B3C:  MOVWF  x02
07B3E:  MOVLB  0
07B40:  CALL   51F6
07B44:  MOVLW  22
07B46:  BTFSS  F9E.4
07B48:  BRA    7B46
07B4A:  MOVWF  FAD
....................          SendDataDisplay(); 
07B4C:  CALL   1336
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==3){ //Menu de Tiempo de Post-Purga 
07B50:  MOVF   x81,W
07B52:  SUBLW  03
07B54:  BTFSS  FD8.2
07B56:  BRA    7E7E
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
07B58:  MOVLW  2E
07B5A:  MOVWF  FF6
07B5C:  MOVLW  09
07B5E:  MOVWF  FF7
07B60:  MOVLW  00
07B62:  MOVWF  FF8
07B64:  MOVLW  11
07B66:  MOVLB  B
07B68:  MOVWF  x02
07B6A:  MOVLB  0
07B6C:  CALL   5198
07B70:  MOVFF  98,B01
07B74:  MOVLW  01
07B76:  MOVLB  B
07B78:  MOVWF  x02
07B7A:  MOVLB  0
07B7C:  CALL   51F6
07B80:  MOVLW  2F
07B82:  BTFSS  F9E.4
07B84:  BRA    7B82
07B86:  MOVWF  FAD
07B88:  MOVFF  97,B01
07B8C:  MOVLW  01
07B8E:  MOVLB  B
07B90:  MOVWF  x02
07B92:  MOVLB  0
07B94:  CALL   51F6
07B98:  MOVLW  2F
07B9A:  BTFSS  F9E.4
07B9C:  BRA    7B9A
07B9E:  MOVWF  FAD
07BA0:  MOVLW  32
07BA2:  BTFSS  F9E.4
07BA4:  BRA    7BA2
07BA6:  MOVWF  FAD
07BA8:  MOVLW  30
07BAA:  BTFSS  F9E.4
07BAC:  BRA    7BAA
07BAE:  MOVWF  FAD
07BB0:  MOVFF  96,B01
07BB4:  MOVLW  01
07BB6:  MOVLB  B
07BB8:  MOVWF  x02
07BBA:  MOVLB  0
07BBC:  CALL   51F6
07BC0:  MOVLW  4F
07BC2:  MOVWF  FF6
07BC4:  MOVLW  09
07BC6:  MOVWF  FF7
07BC8:  MOVLW  00
07BCA:  MOVWF  FF8
07BCC:  MOVLW  0A
07BCE:  MOVLB  B
07BD0:  MOVWF  x02
07BD2:  MOVLB  0
07BD4:  CALL   5198
07BD8:  MOVFF  99,B01
07BDC:  MOVLW  01
07BDE:  MOVLB  B
07BE0:  MOVWF  x02
07BE2:  MOVLB  0
07BE4:  CALL   51F6
07BE8:  MOVLW  3A
07BEA:  BTFSS  F9E.4
07BEC:  BRA    7BEA
07BEE:  MOVWF  FAD
07BF0:  MOVFF  9A,B01
07BF4:  MOVLW  01
07BF6:  MOVLB  B
07BF8:  MOVWF  x02
07BFA:  MOVLB  0
07BFC:  CALL   51F6
07C00:  MOVLW  3A
07C02:  BTFSS  F9E.4
07C04:  BRA    7C02
07C06:  MOVWF  FAD
07C08:  MOVFF  9B,B01
07C0C:  MOVLW  01
07C0E:  MOVLB  B
07C10:  MOVWF  x02
07C12:  MOVLB  0
07C14:  CALL   51F6
07C18:  MOVLW  20
07C1A:  BTFSS  F9E.4
07C1C:  BRA    7C1A
07C1E:  MOVWF  FAD
07C20:  MOVLW  20
07C22:  BTFSS  F9E.4
07C24:  BRA    7C22
07C26:  MOVWF  FAD
07C28:  MOVLW  22
07C2A:  BTFSS  F9E.4
07C2C:  BRA    7C2A
07C2E:  MOVWF  FAD
....................          SendDataDisplay(); 
07C30:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
07C34:  MOVF   35,W
07C36:  SUBLW  0A
07C38:  BNZ   7C3E
....................             Minutos=ON; 
07C3A:  BSF    x7E.7
....................             Segundos=OFF; 
07C3C:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
07C3E:  MOVF   35,W
07C40:  SUBLW  0B
07C42:  BNZ   7C48
....................             Segundos=ON; 
07C44:  BSF    x7F.0
....................             Minutos=OFF; 
07C46:  BCF    x7E.7
....................          }            
....................           
....................          if(RIGHT){ 
07C48:  BSF    F93.6
07C4A:  BTFSC  F81.6
07C4C:  BRA    7CC2
....................             delay_ms(200); 
07C4E:  MOVLW  C8
07C50:  MOVLB  B
07C52:  MOVWF  x22
07C54:  MOVLB  0
07C56:  CALL   11F6
....................             if(RIGHT){ 
07C5A:  BSF    F93.6
07C5C:  BTFSC  F81.6
07C5E:  BRA    7CC2
....................                if(!Segundos){ 
07C60:  BTFSC  x7F.0
07C62:  BRA    7C92
....................                   Segundos=ON; 
07C64:  BSF    x7F.0
....................                   Minutos=OFF; 
07C66:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
07C68:  MOVLW  6C
07C6A:  MOVWF  FF6
07C6C:  MOVLW  09
07C6E:  MOVWF  FF7
07C70:  MOVLW  00
07C72:  MOVWF  FF8
07C74:  CALL   1304
....................                   SendDataDisplay();   
07C78:  CALL   1336
....................                   printf("tminest.pco=0"); 
07C7C:  MOVLW  7E
07C7E:  MOVWF  FF6
07C80:  MOVLW  09
07C82:  MOVWF  FF7
07C84:  MOVLW  00
07C86:  MOVWF  FF8
07C88:  CALL   1304
....................                   SendDataDisplay();   
07C8C:  CALL   1336
....................                }else if(!Minutos){ 
07C90:  BRA    7CC2
07C92:  BTFSC  x7E.7
07C94:  BRA    7CC2
....................                   Segundos=OFF; 
07C96:  BCF    x7F.0
....................                   Minutos=ON; 
07C98:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
07C9A:  MOVLW  8C
07C9C:  MOVWF  FF6
07C9E:  MOVLW  09
07CA0:  MOVWF  FF7
07CA2:  MOVLW  00
07CA4:  MOVWF  FF8
07CA6:  CALL   1304
....................                   SendDataDisplay();   
07CAA:  CALL   1336
....................                   printf("tminest.pco=65535"); 
07CAE:  MOVLW  9A
07CB0:  MOVWF  FF6
07CB2:  MOVLW  09
07CB4:  MOVWF  FF7
07CB6:  MOVLW  00
07CB8:  MOVWF  FF8
07CBA:  CALL   1304
....................                   SendDataDisplay();   
07CBE:  CALL   1336
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
07CC2:  MOVF   35,W
07CC4:  SUBLW  11
07CC6:  BZ    7CCE
07CC8:  BSF    F93.7
07CCA:  BTFSC  F81.7
07CCC:  BRA    7D78
....................             delay_ms(200); 
07CCE:  MOVLW  C8
07CD0:  MOVLB  B
07CD2:  MOVWF  x22
07CD4:  MOVLB  0
07CD6:  CALL   11F6
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
07CDA:  MOVF   35,W
07CDC:  SUBLW  11
07CDE:  BZ    7CE6
07CE0:  BSF    F93.7
07CE2:  BTFSC  F81.7
07CE4:  BRA    7D78
....................                Segundos=OFF; 
07CE6:  BCF    x7F.0
....................                Minutos=OFF; 
07CE8:  BCF    x7E.7
....................                printf("page Ajustes"); 
07CEA:  MOVLW  AC
07CEC:  MOVWF  FF6
07CEE:  MOVLW  09
07CF0:  MOVWF  FF7
07CF2:  MOVLW  00
07CF4:  MOVWF  FF8
07CF6:  CALL   1304
....................                SendDataDisplay();   
07CFA:  CALL   1336
....................                if(!GuardaEEPROM){ 
07CFE:  BTFSC  x7E.6
07D00:  BRA    7D78
....................                   write_eeprom(6,mPPurgap); 
07D02:  CLRF   FAA
07D04:  MOVLW  06
07D06:  MOVWF  FA9
07D08:  MOVFF  B3,FA8
07D0C:  BCF    FA6.6
07D0E:  BCF    FA6.7
07D10:  BSF    FA6.2
07D12:  MOVF   FF2,W
07D14:  MOVWF  00
07D16:  BCF    FF2.6
07D18:  BCF    FF2.7
07D1A:  MOVLB  F
07D1C:  MOVLW  55
07D1E:  MOVWF  FA7
07D20:  MOVLW  AA
07D22:  MOVWF  FA7
07D24:  BSF    FA6.1
07D26:  BTFSC  FA6.1
07D28:  BRA    7D26
07D2A:  BCF    FA6.2
07D2C:  MOVF   00,W
07D2E:  IORWF  FF2,F
....................                   delay_ms(10); 
07D30:  MOVLW  0A
07D32:  MOVLB  B
07D34:  MOVWF  x22
07D36:  MOVLB  0
07D38:  CALL   11F6
....................                   write_eeprom(7,sPPurgap); 
07D3C:  CLRF   FAA
07D3E:  MOVLW  07
07D40:  MOVWF  FA9
07D42:  MOVFF  B1,FA8
07D46:  BCF    FA6.6
07D48:  BCF    FA6.7
07D4A:  BSF    FA6.2
07D4C:  MOVF   FF2,W
07D4E:  MOVWF  00
07D50:  BCF    FF2.6
07D52:  BCF    FF2.7
07D54:  MOVLB  F
07D56:  MOVLW  55
07D58:  MOVWF  FA7
07D5A:  MOVLW  AA
07D5C:  MOVWF  FA7
07D5E:  BSF    FA6.1
07D60:  BTFSC  FA6.1
07D62:  BRA    7D60
07D64:  BCF    FA6.2
07D66:  MOVF   00,W
07D68:  IORWF  FF2,F
....................                   delay_ms(10); 
07D6A:  MOVLW  0A
07D6C:  MOVLB  B
07D6E:  MOVWF  x22
07D70:  MOVLB  0
07D72:  CALL   11F6
....................                   //mPPurga=mPPurgap; 
....................                   //sPPurga=sPPurgap; 
....................                   GuardaEEPROM=ON; 
07D76:  BSF    x7E.6
....................                } 
....................             } 
....................          }         
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07D78:  MOVF   35,W
07D7A:  SUBLW  0C
07D7C:  BZ    7D8A
07D7E:  MOVF   35,W
07D80:  SUBLW  0D
07D82:  BZ    7D8A
07D84:  BSF    F93.4
07D86:  BTFSC  F81.4
07D88:  BRA    7DB8
....................             delay_ms(10); 
07D8A:  MOVLW  0A
07D8C:  MOVLB  B
07D8E:  MOVWF  x22
07D90:  MOVLB  0
07D92:  CALL   11F6
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
07D96:  MOVF   35,W
07D98:  SUBLW  0C
07D9A:  BZ    7DA8
07D9C:  MOVF   35,W
07D9E:  SUBLW  0D
07DA0:  BZ    7DA8
07DA2:  BSF    F93.4
07DA4:  BTFSC  F81.4
07DA6:  BRA    7DB8
....................                if(Segundos){ 
07DA8:  BTFSS  x7F.0
07DAA:  BRA    7DAE
....................                   sPPurgap++; 
07DAC:  INCF   xB1,F
....................                } 
....................                if(Minutos){ 
07DAE:  BTFSS  x7E.7
07DB0:  BRA    7DB4
....................                   mPPurgap++; 
07DB2:  INCF   xB3,F
....................                }   
....................                RX_Buffer[4]=0x00;   
07DB4:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07DB6:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07DB8:  MOVF   35,W
07DBA:  SUBLW  0F
07DBC:  BZ    7DCA
07DBE:  MOVF   35,W
07DC0:  SUBLW  0E
07DC2:  BZ    7DCA
07DC4:  BSF    F93.5
07DC6:  BTFSC  F81.5
07DC8:  BRA    7DFC
....................             delay_ms(10); 
07DCA:  MOVLW  0A
07DCC:  MOVLB  B
07DCE:  MOVWF  x22
07DD0:  MOVLB  0
07DD2:  CALL   11F6
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
07DD6:  MOVF   35,W
07DD8:  SUBLW  0F
07DDA:  BZ    7DE8
07DDC:  MOVF   35,W
07DDE:  SUBLW  0E
07DE0:  BZ    7DE8
07DE2:  BSF    F93.5
07DE4:  BTFSC  F81.5
07DE6:  BRA    7DFC
....................                if(Segundos && sPPurgap>0){ 
07DE8:  BTFSS  x7F.0
07DEA:  BRA    7DF2
07DEC:  MOVF   xB1,F
07DEE:  BZ    7DF2
....................                   sPPurgap--; 
07DF0:  DECF   xB1,F
....................                } 
....................                if(Minutos){ 
07DF2:  BTFSS  x7E.7
07DF4:  BRA    7DF8
....................                   mPPurgap--; 
07DF6:  DECF   xB3,F
....................                } 
....................                RX_Buffer[4]=0x00;   
07DF8:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
07DFA:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mPPurgap<1)mPPurgap=99; 
07DFC:  MOVF   xB3,F
07DFE:  BNZ   7E04
07E00:  MOVLW  63
07E02:  MOVWF  xB3
....................          if(mPPurgap>99)mPPurgap=1; 
07E04:  MOVF   xB3,W
07E06:  SUBLW  63
07E08:  BC    7E0E
07E0A:  MOVLW  01
07E0C:  MOVWF  xB3
....................          if(sPPurgap>59)sPPurgap=0; 
07E0E:  MOVF   xB1,W
07E10:  SUBLW  3B
07E12:  BTFSS  FD8.0
07E14:  CLRF   xB1
....................              
....................          printf("tminest.txt=\"%02u\"",mPPurgap); 
07E16:  MOVLW  BA
07E18:  MOVWF  FF6
07E1A:  MOVLW  09
07E1C:  MOVWF  FF7
07E1E:  MOVLW  00
07E20:  MOVWF  FF8
07E22:  MOVLW  0D
07E24:  MOVLB  B
07E26:  MOVWF  x02
07E28:  MOVLB  0
07E2A:  CALL   5198
07E2E:  MOVFF  B3,B01
07E32:  MOVLW  01
07E34:  MOVLB  B
07E36:  MOVWF  x02
07E38:  MOVLB  0
07E3A:  CALL   51F6
07E3E:  MOVLW  22
07E40:  BTFSS  F9E.4
07E42:  BRA    7E40
07E44:  MOVWF  FAD
....................          SendDataDisplay(); 
07E46:  CALL   1336
....................          printf("tsecest.txt=\"%02u\"",sPPurgap); 
07E4A:  MOVLW  CE
07E4C:  MOVWF  FF6
07E4E:  MOVLW  09
07E50:  MOVWF  FF7
07E52:  MOVLW  00
07E54:  MOVWF  FF8
07E56:  MOVLW  0D
07E58:  MOVLB  B
07E5A:  MOVWF  x02
07E5C:  MOVLB  0
07E5E:  CALL   5198
07E62:  MOVFF  B1,B01
07E66:  MOVLW  01
07E68:  MOVLB  B
07E6A:  MOVWF  x02
07E6C:  MOVLB  0
07E6E:  CALL   51F6
07E72:  MOVLW  22
07E74:  BTFSS  F9E.4
07E76:  BRA    7E74
07E78:  MOVWF  FAD
....................          SendDataDisplay(); 
07E7A:  CALL   1336
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==4){//Menu de Purga. 
07E7E:  MOVF   x81,W
07E80:  SUBLW  04
07E82:  BTFSS  FD8.2
07E84:  BRA    808E
....................          ubicaVidrio20cm(); 
07E86:  GOTO   527E
....................          if(VIDRIOUP){ 
07E8A:  BSF    F96.1
07E8C:  BTFSC  F84.1
07E8E:  BRA    7EAA
....................             Purga=ON; 
07E90:  BSF    x80.4
....................             tiempo_purga=1; 
07E92:  BSF    x7E.2
....................             printf("titulo.txt=\"Purga\""); 
07E94:  MOVLW  E2
07E96:  MOVWF  FF6
07E98:  MOVLW  09
07E9A:  MOVWF  FF7
07E9C:  MOVLW  00
07E9E:  MOVWF  FF8
07EA0:  CALL   1304
....................             SendDataDisplay(); 
07EA4:  CALL   1336
....................          }else{ 
07EA8:  BRA    7EC2
....................             Purga=OFF; 
07EAA:  BCF    x80.4
....................             tiempo_purga=0; 
07EAC:  BCF    x7E.2
....................             printf("titulo.txt=\"!Ubicando el vidrio!\""); 
07EAE:  MOVLW  F6
07EB0:  MOVWF  FF6
07EB2:  MOVLW  09
07EB4:  MOVWF  FF7
07EB6:  MOVLW  00
07EB8:  MOVWF  FF8
07EBA:  CALL   1304
....................             SendDataDisplay(); 
07EBE:  CALL   1336
....................          } 
....................          LuzBlanca_off;//Alarma_off; 
07EC2:  BSF    F8C.0
07EC4:  BCF    F95.0
....................          printf("minPurga.txt=\"%02u\"",mPurga); 
07EC6:  MOVLW  18
07EC8:  MOVWF  FF6
07ECA:  MOVLW  0A
07ECC:  MOVWF  FF7
07ECE:  MOVLW  00
07ED0:  MOVWF  FF8
07ED2:  MOVLW  0E
07ED4:  MOVLB  B
07ED6:  MOVWF  x02
07ED8:  MOVLB  0
07EDA:  CALL   5198
07EDE:  MOVFF  AE,B01
07EE2:  MOVLW  01
07EE4:  MOVLB  B
07EE6:  MOVWF  x02
07EE8:  MOVLB  0
07EEA:  CALL   51F6
07EEE:  MOVLW  22
07EF0:  BTFSS  F9E.4
07EF2:  BRA    7EF0
07EF4:  MOVWF  FAD
....................          SendDataDisplay(); 
07EF6:  CALL   1336
....................          printf("secPurga.txt=\"%02u\"",sPurga); 
07EFA:  MOVLW  2C
07EFC:  MOVWF  FF6
07EFE:  MOVLW  0A
07F00:  MOVWF  FF7
07F02:  MOVLW  00
07F04:  MOVWF  FF8
07F06:  MOVLW  0E
07F08:  MOVLB  B
07F0A:  MOVWF  x02
07F0C:  MOVLB  0
07F0E:  CALL   5198
07F12:  MOVFF  AC,B01
07F16:  MOVLW  01
07F18:  MOVLB  B
07F1A:  MOVWF  x02
07F1C:  MOVLB  0
07F1E:  CALL   51F6
07F22:  MOVLW  22
07F24:  BTFSS  F9E.4
07F26:  BRA    7F24
07F28:  MOVWF  FAD
....................          SendDataDisplay(); 
07F2A:  CALL   1336
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
07F2E:  MOVLW  40
07F30:  MOVWF  FF6
07F32:  MOVLW  0A
07F34:  MOVWF  FF7
07F36:  MOVLW  00
07F38:  MOVWF  FF8
07F3A:  MOVLW  11
07F3C:  MOVLB  B
07F3E:  MOVWF  x02
07F40:  MOVLB  0
07F42:  CALL   5198
07F46:  MOVFF  98,B01
07F4A:  MOVLW  01
07F4C:  MOVLB  B
07F4E:  MOVWF  x02
07F50:  MOVLB  0
07F52:  CALL   51F6
07F56:  MOVLW  2F
07F58:  BTFSS  F9E.4
07F5A:  BRA    7F58
07F5C:  MOVWF  FAD
07F5E:  MOVFF  97,B01
07F62:  MOVLW  01
07F64:  MOVLB  B
07F66:  MOVWF  x02
07F68:  MOVLB  0
07F6A:  CALL   51F6
07F6E:  MOVLW  2F
07F70:  BTFSS  F9E.4
07F72:  BRA    7F70
07F74:  MOVWF  FAD
07F76:  MOVLW  32
07F78:  BTFSS  F9E.4
07F7A:  BRA    7F78
07F7C:  MOVWF  FAD
07F7E:  MOVLW  30
07F80:  BTFSS  F9E.4
07F82:  BRA    7F80
07F84:  MOVWF  FAD
07F86:  MOVFF  96,B01
07F8A:  MOVLW  01
07F8C:  MOVLB  B
07F8E:  MOVWF  x02
07F90:  MOVLB  0
07F92:  CALL   51F6
07F96:  MOVLW  61
07F98:  MOVWF  FF6
07F9A:  MOVLW  0A
07F9C:  MOVWF  FF7
07F9E:  MOVLW  00
07FA0:  MOVWF  FF8
07FA2:  MOVLW  0A
07FA4:  MOVLB  B
07FA6:  MOVWF  x02
07FA8:  MOVLB  0
07FAA:  CALL   5198
07FAE:  MOVFF  99,B01
07FB2:  MOVLW  01
07FB4:  MOVLB  B
07FB6:  MOVWF  x02
07FB8:  MOVLB  0
07FBA:  CALL   51F6
07FBE:  MOVLW  3A
07FC0:  BTFSS  F9E.4
07FC2:  BRA    7FC0
07FC4:  MOVWF  FAD
07FC6:  MOVFF  9A,B01
07FCA:  MOVLW  01
07FCC:  MOVLB  B
07FCE:  MOVWF  x02
07FD0:  MOVLB  0
07FD2:  CALL   51F6
07FD6:  MOVLW  3A
07FD8:  BTFSS  F9E.4
07FDA:  BRA    7FD8
07FDC:  MOVWF  FAD
07FDE:  MOVFF  9B,B01
07FE2:  MOVLW  01
07FE4:  MOVLB  B
07FE6:  MOVWF  x02
07FE8:  MOVLB  0
07FEA:  CALL   51F6
07FEE:  MOVLW  20
07FF0:  BTFSS  F9E.4
07FF2:  BRA    7FF0
07FF4:  MOVWF  FAD
07FF6:  MOVLW  20
07FF8:  BTFSS  F9E.4
07FFA:  BRA    7FF8
07FFC:  MOVWF  FAD
07FFE:  MOVLW  22
08000:  BTFSS  F9E.4
08002:  BRA    8000
08004:  MOVWF  FAD
....................          SendDataDisplay(); 
08006:  CALL   1336
....................          VelMotor=Vel1; 
0800A:  MOVFF  93,2D3
....................          VelMotor2=Vel2; 
0800E:  MOVFF  94,2D4
....................          Aux_on; 
08012:  BCF    F8C.2
08014:  BCF    F95.2
....................           
....................          if(RX_Buffer[4]==0x11 || RIGHT){ 
08016:  MOVF   35,W
08018:  SUBLW  11
0801A:  BZ    8022
0801C:  BSF    F93.6
0801E:  BTFSC  F81.6
08020:  BRA    8062
....................             delay_ms(1000); 
08022:  MOVLW  04
08024:  MOVLB  B
08026:  MOVWF  x00
08028:  MOVLW  FA
0802A:  MOVWF  x22
0802C:  MOVLB  0
0802E:  CALL   11F6
08032:  MOVLB  B
08034:  DECFSZ x00,F
08036:  BRA    8028
....................             if(RX_Buffer[4]==0x11 || RIGHT){ 
08038:  MOVF   35,W
0803A:  SUBLW  11
0803C:  BZ    8044
0803E:  BSF    F93.6
08040:  BTFSC  F81.6
08042:  BRA    8064
....................                tiempo_purga=0; 
08044:  MOVLB  0
08046:  BCF    x7E.2
....................                printf("page Principal"); 
08048:  MOVLW  7E
0804A:  MOVWF  FF6
0804C:  MOVLW  0A
0804E:  MOVWF  FF7
08050:  MOVLW  00
08052:  MOVWF  FF8
08054:  CALL   1304
....................                SendDataDisplay(); 
08058:  CALL   1336
....................                flag_luz=1;flag_blower=1;flag_toma=1; 
0805C:  BSF    x7D.3
0805E:  BSF    x7D.1
08060:  BSF    x7D.2
08062:  MOVLB  B
....................             } 
....................          } 
....................         
....................          if((sPurga>=sPurgap)&&(mPurga>=mPurgap)){ 
08064:  MOVLB  0
08066:  MOVF   xAD,W
08068:  SUBWF  xAC,W
0806A:  BNC   808E
0806C:  MOVF   xAF,W
0806E:  SUBWF  xAE,W
08070:  BNC   808E
....................             tiempo_purga=0;flag_luz=!flag_luz;flag_blower=1;flag_toma=1; 
08072:  BCF    x7E.2
08074:  BTG    x7D.3
08076:  BSF    x7D.1
08078:  BSF    x7D.2
....................             printf("page Principal"); 
0807A:  MOVLW  8E
0807C:  MOVWF  FF6
0807E:  MOVLW  0A
08080:  MOVWF  FF7
08082:  MOVLW  00
08084:  MOVWF  FF8
08086:  CALL   1304
....................             SendDataDisplay(); 
0808A:  CALL   1336
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==5){ //Menu General. 
0808E:  MOVF   x81,W
08090:  SUBLW  05
08092:  BTFSS  FD8.2
08094:  GOTO   89FC
....................          Purga=OFF; 
08098:  BCF    x80.4
....................          w=0; 
0809A:  BCF    x7D.4
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);          
0809C:  MOVFF  CA,B01
080A0:  MOVLW  0A
080A2:  MOVLB  B
080A4:  MOVWF  x02
080A6:  MOVLB  0
080A8:  CALL   530C
080AC:  MOVF   01,W
080AE:  ADDWF  xC9,W
080B0:  MOVLB  B
080B2:  MOVWF  x00
080B4:  MOVFF  CB,B01
080B8:  MOVLW  64
080BA:  MOVWF  x02
080BC:  MOVLB  0
080BE:  CALL   530C
080C2:  MOVF   01,W
080C4:  MOVLB  B
080C6:  ADDWF  x00,F
080C8:  CLRF   03
080CA:  MOVLB  0
080CC:  MOVF   xCC,W
080CE:  MOVWF  00
080D0:  BTFSC  FE8.7
080D2:  DECF   03,F
080D4:  MOVLB  B
080D6:  MOVWF  x01
080D8:  MOVFF  03,B02
080DC:  MOVFF  03,B04
080E0:  MOVWF  x03
080E2:  MOVLW  03
080E4:  MOVWF  x06
080E6:  MOVLW  E8
080E8:  MOVWF  x05
080EA:  MOVLB  0
080EC:  CALL   535A
080F0:  MOVFF  02,03
080F4:  MOVF   01,W
080F6:  MOVLB  B
080F8:  ADDWF  x00,W
080FA:  MOVWF  01
080FC:  MOVLW  00
080FE:  ADDWFC 03,F
08100:  MOVFF  01,B00
08104:  MOVFF  03,B01
08108:  MOVLB  0
0810A:  CALL   53AE
0810E:  MOVFF  03,108
08112:  MOVFF  02,107
08116:  MOVFF  01,106
0811A:  MOVFF  00,105
....................          VelMotor2=Vel2; 
0811E:  MOVFF  94,2D4
....................          Aux_on; 
08122:  BCF    F8C.2
08124:  BCF    F95.2
....................          if(imprimir==1){ 
08126:  BTFSS  x7D.0
08128:  BRA    8290
....................             printf("fex.txt=\"Velocidad: %u \"",VelMotor); 
0812A:  MOVLW  9E
0812C:  MOVWF  FF6
0812E:  MOVLW  0A
08130:  MOVWF  FF7
08132:  MOVLW  00
08134:  MOVWF  FF8
08136:  MOVLW  14
08138:  MOVLB  B
0813A:  MOVWF  x02
0813C:  MOVLB  0
0813E:  CALL   5198
08142:  MOVFF  2D3,B01
08146:  MOVLW  1B
08148:  MOVLB  B
0814A:  MOVWF  x02
0814C:  MOVLB  0
0814E:  CALL   51F6
08152:  MOVLW  20
08154:  BTFSS  F9E.4
08156:  BRA    8154
08158:  MOVWF  FAD
0815A:  MOVLW  22
0815C:  BTFSS  F9E.4
0815E:  BRA    815C
08160:  MOVWF  FAD
....................             SendDataDisplay(); 
08162:  CALL   1336
....................             printf("fdown.txt=\"Extraccin: %2.2f m/s\"",Inflow); 
08166:  MOVLW  B8
08168:  MOVWF  FF6
0816A:  MOVLW  0A
0816C:  MOVWF  FF7
0816E:  MOVLW  00
08170:  MOVWF  FF8
08172:  MOVLW  17
08174:  MOVLB  B
08176:  MOVWF  x02
08178:  MOVLB  0
0817A:  CALL   5198
0817E:  MOVLW  89
08180:  MOVWF  FE9
08182:  MOVFF  DC,B03
08186:  MOVFF  DB,B02
0818A:  MOVFF  DA,B01
0818E:  MOVFF  D9,B00
08192:  MOVLW  02
08194:  MOVLB  B
08196:  MOVWF  x04
08198:  MOVLB  0
0819A:  CALL   54C2
0819E:  MOVLW  D4
081A0:  MOVWF  FF6
081A2:  MOVLW  0A
081A4:  MOVWF  FF7
081A6:  MOVLW  00
081A8:  MOVWF  FF8
081AA:  MOVLW  05
081AC:  MOVLB  B
081AE:  MOVWF  x02
081B0:  MOVLB  0
081B2:  CALL   5198
....................             SendDataDisplay(); 
081B6:  CALL   1336
....................             printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
081BA:  MOVLW  DA
081BC:  MOVWF  FF6
081BE:  MOVLW  0A
081C0:  MOVWF  FF7
081C2:  MOVLW  00
081C4:  MOVWF  FF8
081C6:  MOVLW  11
081C8:  MOVLB  B
081CA:  MOVWF  x02
081CC:  MOVLB  0
081CE:  CALL   5198
081D2:  MOVFF  98,B01
081D6:  MOVLW  01
081D8:  MOVLB  B
081DA:  MOVWF  x02
081DC:  MOVLB  0
081DE:  CALL   51F6
081E2:  MOVLW  2F
081E4:  BTFSS  F9E.4
081E6:  BRA    81E4
081E8:  MOVWF  FAD
081EA:  MOVFF  97,B01
081EE:  MOVLW  01
081F0:  MOVLB  B
081F2:  MOVWF  x02
081F4:  MOVLB  0
081F6:  CALL   51F6
081FA:  MOVLW  2F
081FC:  BTFSS  F9E.4
081FE:  BRA    81FC
08200:  MOVWF  FAD
08202:  MOVLW  32
08204:  BTFSS  F9E.4
08206:  BRA    8204
08208:  MOVWF  FAD
0820A:  MOVLW  30
0820C:  BTFSS  F9E.4
0820E:  BRA    820C
08210:  MOVWF  FAD
08212:  MOVFF  96,B01
08216:  MOVLW  01
08218:  MOVLB  B
0821A:  MOVWF  x02
0821C:  MOVLB  0
0821E:  CALL   51F6
08222:  MOVLW  FB
08224:  MOVWF  FF6
08226:  MOVLW  0A
08228:  MOVWF  FF7
0822A:  MOVLW  00
0822C:  MOVWF  FF8
0822E:  MOVLW  0A
08230:  MOVLB  B
08232:  MOVWF  x02
08234:  MOVLB  0
08236:  CALL   5198
0823A:  MOVFF  99,B01
0823E:  MOVLW  01
08240:  MOVLB  B
08242:  MOVWF  x02
08244:  MOVLB  0
08246:  CALL   51F6
0824A:  MOVLW  3A
0824C:  BTFSS  F9E.4
0824E:  BRA    824C
08250:  MOVWF  FAD
08252:  MOVFF  9A,B01
08256:  MOVLW  01
08258:  MOVLB  B
0825A:  MOVWF  x02
0825C:  MOVLB  0
0825E:  CALL   51F6
08262:  MOVLW  3A
08264:  BTFSS  F9E.4
08266:  BRA    8264
08268:  MOVWF  FAD
0826A:  MOVFF  9B,B01
0826E:  MOVLW  01
08270:  MOVLB  B
08272:  MOVWF  x02
08274:  MOVLB  0
08276:  CALL   51F6
0827A:  MOVLW  20
0827C:  BTFSS  F9E.4
0827E:  BRA    827C
08280:  MOVWF  FAD
08282:  MOVLW  22
08284:  BTFSS  F9E.4
08286:  BRA    8284
08288:  MOVWF  FAD
....................             //printf("fecha.txt=\"Pdn:%2.2f  %04Luf  %04Lu\"",Filtro_Downflow,Presion[4].adc,sensores(4)); 
....................             SendDataDisplay(); 
0828A:  CALL   1336
....................             imprimir=0; 
0828E:  BCF    x7D.0
....................          } 
....................        
.................... // Dibujo de barra de estado de filtro                   
....................       barra=100.0*(Filtro_Downflow/1.5); 
08290:  MOVFF  E4,B22
08294:  MOVFF  E3,B21
08298:  MOVFF  E2,B20
0829C:  MOVFF  E1,B1F
082A0:  MOVLB  B
082A2:  CLRF   x26
082A4:  CLRF   x25
082A6:  MOVLW  40
082A8:  MOVWF  x24
082AA:  MOVLW  7F
082AC:  MOVWF  x23
082AE:  MOVLB  0
082B0:  CALL   13A2
082B4:  MOVLB  B
082B6:  CLRF   x26
082B8:  CLRF   x25
082BA:  MOVLW  48
082BC:  MOVWF  x24
082BE:  MOVLW  85
082C0:  MOVWF  x23
082C2:  MOVFF  03,B2A
082C6:  MOVFF  02,B29
082CA:  MOVFF  01,B28
082CE:  MOVFF  00,B27
082D2:  MOVLB  0
082D4:  CALL   3908
082D8:  MOVFF  03,110
082DC:  MOVFF  02,10F
082E0:  MOVFF  01,10E
082E4:  MOVFF  00,10D
....................       if(barra>100.0) 
082E8:  MOVLB  B
082EA:  CLRF   x22
082EC:  CLRF   x21
082EE:  MOVLW  48
082F0:  MOVWF  x20
082F2:  MOVLW  85
082F4:  MOVWF  x1F
082F6:  MOVFF  110,B26
082FA:  MOVFF  10F,B25
082FE:  MOVFF  10E,B24
08302:  MOVFF  10D,B23
08306:  MOVLB  0
08308:  CALL   241C
0830C:  BNC   831C
....................          barra=100.0; 
0830E:  MOVLB  1
08310:  CLRF   x10
08312:  CLRF   x0F
08314:  MOVLW  48
08316:  MOVWF  x0E
08318:  MOVLW  85
0831A:  MOVWF  x0D
....................        
....................       if(barra<0.0) 
0831C:  MOVFF  110,B22
08320:  MOVFF  10F,B21
08324:  MOVFF  10E,B20
08328:  MOVFF  10D,B1F
0832C:  MOVLB  B
0832E:  CLRF   x26
08330:  CLRF   x25
08332:  CLRF   x24
08334:  CLRF   x23
08336:  MOVLB  0
08338:  CALL   241C
0833C:  BNC   834A
....................          barra=0.0; 
0833E:  MOVLB  1
08340:  CLRF   x10
08342:  CLRF   x0F
08344:  CLRF   x0E
08346:  CLRF   x0D
08348:  MOVLB  0
....................        
....................       printf("pdown.txt=\"%03u%%\"",(int8)barra); 
0834A:  MOVFF  110,B03
0834E:  MOVFF  10F,B02
08352:  MOVFF  10E,B01
08356:  MOVFF  10D,B00
0835A:  CALL   513E
0835E:  MOVFF  01,B00
08362:  MOVLW  16
08364:  MOVWF  FF6
08366:  MOVLW  0B
08368:  MOVWF  FF7
0836A:  MOVLW  00
0836C:  MOVWF  FF8
0836E:  MOVLW  0B
08370:  MOVLB  B
08372:  MOVWF  x02
08374:  MOVLB  0
08376:  CALL   5198
0837A:  MOVFF  B00,B01
0837E:  MOVLW  03
08380:  MOVLB  B
08382:  MOVWF  x02
08384:  MOVLB  0
08386:  CALL   51F6
0838A:  MOVLW  25
0838C:  BTFSS  F9E.4
0838E:  BRA    838C
08390:  MOVWF  FAD
08392:  MOVLW  22
08394:  BTFSS  F9E.4
08396:  BRA    8394
08398:  MOVWF  FAD
....................       SendDataDisplay(); 
0839A:  CALL   1336
....................       dibujaBarraDn(); 
0839E:  GOTO   5666
....................        
....................       if(Inflow<0.3){ 
083A2:  MOVFF  DC,B22
083A6:  MOVFF  DB,B21
083AA:  MOVFF  DA,B20
083AE:  MOVFF  D9,B1F
083B2:  MOVLW  9A
083B4:  MOVLB  B
083B6:  MOVWF  x26
083B8:  MOVLW  99
083BA:  MOVWF  x25
083BC:  MOVLW  19
083BE:  MOVWF  x24
083C0:  MOVLW  7D
083C2:  MOVWF  x23
083C4:  MOVLB  0
083C6:  CALL   241C
083CA:  BNC   8402
....................          flag_latencia=1; 
083CC:  BSF    x7E.4
....................          if(Latencia==1){          
083CE:  BTFSS  x7F.1
083D0:  BRA    8400
....................             if(Inflow<0.3){ 
083D2:  MOVFF  DC,B22
083D6:  MOVFF  DB,B21
083DA:  MOVFF  DA,B20
083DE:  MOVFF  D9,B1F
083E2:  MOVLW  9A
083E4:  MOVLB  B
083E6:  MOVWF  x26
083E8:  MOVLW  99
083EA:  MOVWF  x25
083EC:  MOVLW  19
083EE:  MOVWF  x24
083F0:  MOVLW  7D
083F2:  MOVWF  x23
083F4:  MOVLB  0
083F6:  CALL   241C
083FA:  BNC   8400
....................                Alarma=5; 
083FC:  MOVLW  05
083FE:  MOVWF  x90
....................             } 
....................          } 
....................       }else{ 
08400:  BRA    840E
....................          Latencia=0;t_latencia=0;flag_latencia=0; 
08402:  BCF    x7F.1
08404:  CLRF   xC0
08406:  CLRF   xBF
08408:  BCF    x7E.4
....................          Alarma=10; 
0840A:  MOVLW  0A
0840C:  MOVWF  x90
....................       } 
....................        
....................       if(VIDRIOUP){ // Si el vidrio esta en la posicin correcta          
0840E:  BSF    F96.1
08410:  BTFSC  F84.1
08412:  BRA    8450
....................          Alarma2=10; 
08414:  MOVLW  0A
08416:  MOVWF  x91
....................          if(flag_luz==1){ 
08418:  BTFSS  x7D.3
0841A:  BRA    8436
....................             printf("b0.pic=6"); 
0841C:  MOVLW  2A
0841E:  MOVWF  FF6
08420:  MOVLW  0B
08422:  MOVWF  FF7
08424:  MOVLW  00
08426:  MOVWF  FF8
08428:  CALL   1304
....................             SendDataDisplay();     
0842C:  CALL   1336
....................             LuzBlanca_on; 
08430:  BCF    F8C.0
08432:  BCF    F95.0
....................          }else{ 
08434:  BRA    844E
....................             printf("b0.pic=7"); 
08436:  MOVLW  34
08438:  MOVWF  FF6
0843A:  MOVLW  0B
0843C:  MOVWF  FF7
0843E:  MOVLW  00
08440:  MOVWF  FF8
08442:  CALL   1304
....................             SendDataDisplay();  
08446:  CALL   1336
....................             LuzBlanca_off; 
0844A:  BSF    F8C.0
0844C:  BCF    F95.0
....................          } 
....................       }else{// Si el vidrio no esta en la posicin correcta 
0844E:  BRA    8468
....................          LuzBlanca_off; 
08450:  BSF    F8C.0
08452:  BCF    F95.0
....................          printf("b0.pic=7"); 
08454:  MOVLW  3E
08456:  MOVWF  FF6
08458:  MOVLW  0B
0845A:  MOVWF  FF7
0845C:  MOVLW  00
0845E:  MOVWF  FF8
08460:  CALL   1304
....................          SendDataDisplay();  
08464:  CALL   1336
....................       } 
....................           
....................       if(VIDRIODN){   
08468:  BSF    F96.0
0846A:  BTFSC  F84.0
0846C:  BRA    847E
....................          Alarma2=10; 
0846E:  MOVLW  0A
08470:  MOVWF  x91
....................          if(flag_blower){ 
08472:  BTFSS  x7D.1
08474:  BRA    847A
....................             ECO=ON;    
08476:  BSF    x80.2
....................          }else{ 
08478:  BRA    847C
....................             ECO=OFF; 
0847A:  BCF    x80.2
....................          } 
....................       }else{ 
0847C:  BRA    8480
....................          ECO=OFF; 
0847E:  BCF    x80.2
....................       } 
....................           
....................       if(Alarma==5){ 
08480:  MOVF   x90,W
08482:  SUBLW  05
08484:  BNZ   84B0
....................          printf("estado.txt=\"Perdida Flujo\""); 
08486:  MOVLW  48
08488:  MOVWF  FF6
0848A:  MOVLW  0B
0848C:  MOVWF  FF7
0848E:  MOVLW  00
08490:  MOVWF  FF8
08492:  CALL   1304
....................          SendDataDisplay();     
08496:  CALL   1336
....................          printf("icon.pic=17"); 
0849A:  MOVLW  64
0849C:  MOVWF  FF6
0849E:  MOVLW  0B
084A0:  MOVWF  FF7
084A2:  MOVLW  00
084A4:  MOVWF  FF8
084A6:  CALL   1304
....................          SendDataDisplay();  
084AA:  CALL   1336
....................          //cambiaColor(63911); 
....................       }else{ 
084AE:  BRA    852A
....................          if(!VIDRIOUP){                
084B0:  BSF    F96.1
084B2:  BTFSS  F84.1
084B4:  BRA    84E4
....................             printf("estado.txt=\"Ubique Vidrio\""); 
084B6:  MOVLW  70
084B8:  MOVWF  FF6
084BA:  MOVLW  0B
084BC:  MOVWF  FF7
084BE:  MOVLW  00
084C0:  MOVWF  FF8
084C2:  CALL   1304
....................             SendDataDisplay();   
084C6:  CALL   1336
....................             printf("icon.pic=16"); 
084CA:  MOVLW  8C
084CC:  MOVWF  FF6
084CE:  MOVLW  0B
084D0:  MOVWF  FF7
084D2:  MOVLW  00
084D4:  MOVWF  FF8
084D6:  CALL   1304
....................             SendDataDisplay();  
084DA:  CALL   1336
....................             //cambiaColor(56544); 
....................             Alarma2=5; 
084DE:  MOVLW  05
084E0:  MOVWF  x91
....................          }else{    
084E2:  BRA    852A
....................             if(ECO){ 
084E4:  BTFSS  x80.2
084E6:  BRA    84FE
....................                printf("estado.txt=\"Modo Eco\""); 
084E8:  MOVLW  98
084EA:  MOVWF  FF6
084EC:  MOVLW  0B
084EE:  MOVWF  FF7
084F0:  MOVLW  00
084F2:  MOVWF  FF8
084F4:  CALL   1304
....................                SendDataDisplay();  
084F8:  CALL   1336
....................             }else{ 
084FC:  BRA    8512
....................                printf("estado.txt=\"Operacin Segura\""); 
084FE:  MOVLW  AE
08500:  MOVWF  FF6
08502:  MOVLW  0B
08504:  MOVWF  FF7
08506:  MOVLW  00
08508:  MOVWF  FF8
0850A:  CALL   1304
....................                SendDataDisplay();     
0850E:  CALL   1336
....................             } 
....................             printf("icon.pic=15"); 
08512:  MOVLW  CC
08514:  MOVWF  FF6
08516:  MOVLW  0B
08518:  MOVWF  FF7
0851A:  MOVLW  00
0851C:  MOVWF  FF8
0851E:  CALL   1304
....................             SendDataDisplay();  
08522:  CALL   1336
....................             Alarma2=10; 
08526:  MOVLW  0A
08528:  MOVWF  x91
....................             //cambiaColor(0); 
....................          } 
....................       }    
....................                    
....................       if(flag_blower==1){ 
0852A:  BTFSS  x7D.1
0852C:  BRA    86BC
....................          printf("b2.pic=12"); 
0852E:  MOVLW  D8
08530:  MOVWF  FF6
08532:  MOVLW  0B
08534:  MOVWF  FF7
08536:  MOVLW  00
08538:  MOVWF  FF8
0853A:  CALL   1304
....................          SendDataDisplay();  
0853E:  CALL   1336
....................          tiempo_trabajo=1; 
08542:  BSF    x7E.3
....................          if(guardatrabajo==1){ 
08544:  BTFSS  x7F.7
08546:  BRA    86B6
....................             VelMotor=6; 
08548:  MOVLW  06
0854A:  MOVLB  2
0854C:  MOVWF  xD3
....................             guardatrabajo=0; 
0854E:  MOVLB  0
08550:  BCF    x7F.7
....................             write_eeprom(37,make8(minutos_trabajo,0)); 
08552:  MOVFF  C3,B00
08556:  CLRF   FAA
08558:  MOVLW  25
0855A:  MOVWF  FA9
0855C:  MOVFF  B00,FA8
08560:  BCF    FA6.6
08562:  BCF    FA6.7
08564:  BSF    FA6.2
08566:  MOVF   FF2,W
08568:  MOVWF  00
0856A:  BCF    FF2.6
0856C:  BCF    FF2.7
0856E:  MOVLB  F
08570:  MOVLW  55
08572:  MOVWF  FA7
08574:  MOVLW  AA
08576:  MOVWF  FA7
08578:  BSF    FA6.1
0857A:  BTFSC  FA6.1
0857C:  BRA    857A
0857E:  BCF    FA6.2
08580:  MOVF   00,W
08582:  IORWF  FF2,F
....................             delay_ms(20); 
08584:  MOVLW  14
08586:  MOVLB  B
08588:  MOVWF  x22
0858A:  MOVLB  0
0858C:  CALL   11F6
....................             write_eeprom(38,make8(minutos_trabajo,1)); 
08590:  MOVFF  C4,B00
08594:  CLRF   FAA
08596:  MOVLW  26
08598:  MOVWF  FA9
0859A:  MOVFF  B00,FA8
0859E:  BCF    FA6.6
085A0:  BCF    FA6.7
085A2:  BSF    FA6.2
085A4:  MOVF   FF2,W
085A6:  MOVWF  00
085A8:  BCF    FF2.6
085AA:  BCF    FF2.7
085AC:  MOVLB  F
085AE:  MOVLW  55
085B0:  MOVWF  FA7
085B2:  MOVLW  AA
085B4:  MOVWF  FA7
085B6:  BSF    FA6.1
085B8:  BTFSC  FA6.1
085BA:  BRA    85B8
085BC:  BCF    FA6.2
085BE:  MOVF   00,W
085C0:  IORWF  FF2,F
....................             delay_ms(20); 
085C2:  MOVLW  14
085C4:  MOVLB  B
085C6:  MOVWF  x22
085C8:  MOVLB  0
085CA:  CALL   11F6
....................             write_eeprom(16,Ttrabajo[0]); 
085CE:  CLRF   FAA
085D0:  MOVLW  10
085D2:  MOVWF  FA9
085D4:  MOVFF  CD,FA8
085D8:  BCF    FA6.6
085DA:  BCF    FA6.7
085DC:  BSF    FA6.2
085DE:  MOVF   FF2,W
085E0:  MOVWF  00
085E2:  BCF    FF2.6
085E4:  BCF    FF2.7
085E6:  MOVLB  F
085E8:  MOVLW  55
085EA:  MOVWF  FA7
085EC:  MOVLW  AA
085EE:  MOVWF  FA7
085F0:  BSF    FA6.1
085F2:  BTFSC  FA6.1
085F4:  BRA    85F2
085F6:  BCF    FA6.2
085F8:  MOVF   00,W
085FA:  IORWF  FF2,F
....................             delay_ms(20); 
085FC:  MOVLW  14
085FE:  MOVLB  B
08600:  MOVWF  x22
08602:  MOVLB  0
08604:  CALL   11F6
....................             write_eeprom(17,Ttrabajo[1]); 
08608:  CLRF   FAA
0860A:  MOVLW  11
0860C:  MOVWF  FA9
0860E:  MOVFF  CE,FA8
08612:  BCF    FA6.6
08614:  BCF    FA6.7
08616:  BSF    FA6.2
08618:  MOVF   FF2,W
0861A:  MOVWF  00
0861C:  BCF    FF2.6
0861E:  BCF    FF2.7
08620:  MOVLB  F
08622:  MOVLW  55
08624:  MOVWF  FA7
08626:  MOVLW  AA
08628:  MOVWF  FA7
0862A:  BSF    FA6.1
0862C:  BTFSC  FA6.1
0862E:  BRA    862C
08630:  BCF    FA6.2
08632:  MOVF   00,W
08634:  IORWF  FF2,F
....................             delay_ms(20); 
08636:  MOVLW  14
08638:  MOVLB  B
0863A:  MOVWF  x22
0863C:  MOVLB  0
0863E:  CALL   11F6
....................             write_eeprom(18,Ttrabajo[2]); 
08642:  CLRF   FAA
08644:  MOVLW  12
08646:  MOVWF  FA9
08648:  MOVFF  CF,FA8
0864C:  BCF    FA6.6
0864E:  BCF    FA6.7
08650:  BSF    FA6.2
08652:  MOVF   FF2,W
08654:  MOVWF  00
08656:  BCF    FF2.6
08658:  BCF    FF2.7
0865A:  MOVLB  F
0865C:  MOVLW  55
0865E:  MOVWF  FA7
08660:  MOVLW  AA
08662:  MOVWF  FA7
08664:  BSF    FA6.1
08666:  BTFSC  FA6.1
08668:  BRA    8666
0866A:  BCF    FA6.2
0866C:  MOVF   00,W
0866E:  IORWF  FF2,F
....................             delay_ms(20); 
08670:  MOVLW  14
08672:  MOVLB  B
08674:  MOVWF  x22
08676:  MOVLB  0
08678:  CALL   11F6
....................             write_eeprom(19,Ttrabajo[3]); 
0867C:  CLRF   FAA
0867E:  MOVLW  13
08680:  MOVWF  FA9
08682:  MOVFF  D0,FA8
08686:  BCF    FA6.6
08688:  BCF    FA6.7
0868A:  BSF    FA6.2
0868C:  MOVF   FF2,W
0868E:  MOVWF  00
08690:  BCF    FF2.6
08692:  BCF    FF2.7
08694:  MOVLB  F
08696:  MOVLW  55
08698:  MOVWF  FA7
0869A:  MOVLW  AA
0869C:  MOVWF  FA7
0869E:  BSF    FA6.1
086A0:  BTFSC  FA6.1
086A2:  BRA    86A0
086A4:  BCF    FA6.2
086A6:  MOVF   00,W
086A8:  IORWF  FF2,F
....................             delay_ms(20);             
086AA:  MOVLW  14
086AC:  MOVLB  B
086AE:  MOVWF  x22
086B0:  MOVLB  0
086B2:  CALL   11F6
....................          } 
....................          VelMotor=Vel1; 
086B6:  MOVFF  93,2D3
....................       }else{ 
086BA:  BRA    8842
....................          //Filtro_Downflow=0; 
....................          printf("b2.pic=13"); 
086BC:  MOVLW  E2
086BE:  MOVWF  FF6
086C0:  MOVLW  0B
086C2:  MOVWF  FF7
086C4:  MOVLW  00
086C6:  MOVWF  FF8
086C8:  CALL   1304
....................          SendDataDisplay();  
086CC:  CALL   1336
....................          tiempo_trabajo=0;VelMotor=0; 
086D0:  BCF    x7E.3
086D2:  MOVLB  2
086D4:  CLRF   xD3
....................          if(guardatrabajo==0){ 
086D6:  MOVLB  0
086D8:  BTFSC  x7F.7
086DA:  BRA    8842
....................             guardatrabajo=1; 
086DC:  BSF    x7F.7
....................             write_eeprom(37,make8(minutos_trabajo,0)); 
086DE:  MOVFF  C3,B00
086E2:  CLRF   FAA
086E4:  MOVLW  25
086E6:  MOVWF  FA9
086E8:  MOVFF  B00,FA8
086EC:  BCF    FA6.6
086EE:  BCF    FA6.7
086F0:  BSF    FA6.2
086F2:  MOVF   FF2,W
086F4:  MOVWF  00
086F6:  BCF    FF2.6
086F8:  BCF    FF2.7
086FA:  MOVLB  F
086FC:  MOVLW  55
086FE:  MOVWF  FA7
08700:  MOVLW  AA
08702:  MOVWF  FA7
08704:  BSF    FA6.1
08706:  BTFSC  FA6.1
08708:  BRA    8706
0870A:  BCF    FA6.2
0870C:  MOVF   00,W
0870E:  IORWF  FF2,F
....................             delay_ms(20); 
08710:  MOVLW  14
08712:  MOVLB  B
08714:  MOVWF  x22
08716:  MOVLB  0
08718:  CALL   11F6
....................             write_eeprom(38,make8(minutos_trabajo,1)); 
0871C:  MOVFF  C4,B00
08720:  CLRF   FAA
08722:  MOVLW  26
08724:  MOVWF  FA9
08726:  MOVFF  B00,FA8
0872A:  BCF    FA6.6
0872C:  BCF    FA6.7
0872E:  BSF    FA6.2
08730:  MOVF   FF2,W
08732:  MOVWF  00
08734:  BCF    FF2.6
08736:  BCF    FF2.7
08738:  MOVLB  F
0873A:  MOVLW  55
0873C:  MOVWF  FA7
0873E:  MOVLW  AA
08740:  MOVWF  FA7
08742:  BSF    FA6.1
08744:  BTFSC  FA6.1
08746:  BRA    8744
08748:  BCF    FA6.2
0874A:  MOVF   00,W
0874C:  IORWF  FF2,F
....................             delay_ms(20); 
0874E:  MOVLW  14
08750:  MOVLB  B
08752:  MOVWF  x22
08754:  MOVLB  0
08756:  CALL   11F6
....................             write_eeprom(16,Ttrabajo[0]); 
0875A:  CLRF   FAA
0875C:  MOVLW  10
0875E:  MOVWF  FA9
08760:  MOVFF  CD,FA8
08764:  BCF    FA6.6
08766:  BCF    FA6.7
08768:  BSF    FA6.2
0876A:  MOVF   FF2,W
0876C:  MOVWF  00
0876E:  BCF    FF2.6
08770:  BCF    FF2.7
08772:  MOVLB  F
08774:  MOVLW  55
08776:  MOVWF  FA7
08778:  MOVLW  AA
0877A:  MOVWF  FA7
0877C:  BSF    FA6.1
0877E:  BTFSC  FA6.1
08780:  BRA    877E
08782:  BCF    FA6.2
08784:  MOVF   00,W
08786:  IORWF  FF2,F
....................             delay_ms(20); 
08788:  MOVLW  14
0878A:  MOVLB  B
0878C:  MOVWF  x22
0878E:  MOVLB  0
08790:  CALL   11F6
....................             write_eeprom(17,Ttrabajo[1]); 
08794:  CLRF   FAA
08796:  MOVLW  11
08798:  MOVWF  FA9
0879A:  MOVFF  CE,FA8
0879E:  BCF    FA6.6
087A0:  BCF    FA6.7
087A2:  BSF    FA6.2
087A4:  MOVF   FF2,W
087A6:  MOVWF  00
087A8:  BCF    FF2.6
087AA:  BCF    FF2.7
087AC:  MOVLB  F
087AE:  MOVLW  55
087B0:  MOVWF  FA7
087B2:  MOVLW  AA
087B4:  MOVWF  FA7
087B6:  BSF    FA6.1
087B8:  BTFSC  FA6.1
087BA:  BRA    87B8
087BC:  BCF    FA6.2
087BE:  MOVF   00,W
087C0:  IORWF  FF2,F
....................             delay_ms(20); 
087C2:  MOVLW  14
087C4:  MOVLB  B
087C6:  MOVWF  x22
087C8:  MOVLB  0
087CA:  CALL   11F6
....................             write_eeprom(18,Ttrabajo[2]); 
087CE:  CLRF   FAA
087D0:  MOVLW  12
087D2:  MOVWF  FA9
087D4:  MOVFF  CF,FA8
087D8:  BCF    FA6.6
087DA:  BCF    FA6.7
087DC:  BSF    FA6.2
087DE:  MOVF   FF2,W
087E0:  MOVWF  00
087E2:  BCF    FF2.6
087E4:  BCF    FF2.7
087E6:  MOVLB  F
087E8:  MOVLW  55
087EA:  MOVWF  FA7
087EC:  MOVLW  AA
087EE:  MOVWF  FA7
087F0:  BSF    FA6.1
087F2:  BTFSC  FA6.1
087F4:  BRA    87F2
087F6:  BCF    FA6.2
087F8:  MOVF   00,W
087FA:  IORWF  FF2,F
....................             delay_ms(20); 
087FC:  MOVLW  14
087FE:  MOVLB  B
08800:  MOVWF  x22
08802:  MOVLB  0
08804:  CALL   11F6
....................             write_eeprom(19,Ttrabajo[3]); 
08808:  CLRF   FAA
0880A:  MOVLW  13
0880C:  MOVWF  FA9
0880E:  MOVFF  D0,FA8
08812:  BCF    FA6.6
08814:  BCF    FA6.7
08816:  BSF    FA6.2
08818:  MOVF   FF2,W
0881A:  MOVWF  00
0881C:  BCF    FF2.6
0881E:  BCF    FF2.7
08820:  MOVLB  F
08822:  MOVLW  55
08824:  MOVWF  FA7
08826:  MOVLW  AA
08828:  MOVWF  FA7
0882A:  BSF    FA6.1
0882C:  BTFSC  FA6.1
0882E:  BRA    882C
08830:  BCF    FA6.2
08832:  MOVF   00,W
08834:  IORWF  FF2,F
....................             delay_ms(20); 
08836:  MOVLW  14
08838:  MOVLB  B
0883A:  MOVWF  x22
0883C:  MOVLB  0
0883E:  CALL   11F6
....................          } 
....................       } 
....................        
....................       if(flag_toma==1){ // Si activo Toma 
08842:  BTFSS  x7D.2
08844:  BRA    8860
....................          printf("b1.pic=8"); 
08846:  MOVLW  EC
08848:  MOVWF  FF6
0884A:  MOVLW  0B
0884C:  MOVWF  FF7
0884E:  MOVLW  00
08850:  MOVWF  FF8
08852:  CALL   1304
....................          SendDataDisplay();  
08856:  CALL   1336
....................          Toma_on; 
0885A:  BSF    F8B.1
0885C:  BCF    F94.1
....................       }else{// Si desactivo Toma         
0885E:  BRA    8878
....................          printf("b1.pic=9"); 
08860:  MOVLW  F6
08862:  MOVWF  FF6
08864:  MOVLW  0B
08866:  MOVWF  FF7
08868:  MOVLW  00
0886A:  MOVWF  FF8
0886C:  CALL   1304
....................          SendDataDisplay();  
08870:  CALL   1336
....................          Toma_off; 
08874:  BCF    F8B.1
08876:  BCF    F94.1
....................       } 
....................        
....................       if(DOWN){ 
08878:  BSF    F93.5
0887A:  BTFSC  F81.5
0887C:  BRA    8892
....................          delay_ms(10); 
0887E:  MOVLW  0A
08880:  MOVLB  B
08882:  MOVWF  x22
08884:  MOVLB  0
08886:  CALL   11F6
....................          if(DOWN){ 
0888A:  BSF    F93.5
0888C:  BTFSC  F81.5
0888E:  BRA    8892
....................             flag_luz=!flag_luz; 
08890:  BTG    x7D.3
....................          } 
....................       } 
....................        
....................       if(RIGHT && LEFT){ 
08892:  BSF    F93.6
08894:  BTFSC  F81.6
08896:  BRA    88DC
08898:  BSF    F93.7
0889A:  BTFSC  F81.7
0889C:  BRA    88DC
....................          delay_ms(500); 
0889E:  MOVLW  02
088A0:  MOVLB  B
088A2:  MOVWF  x00
088A4:  MOVLW  FA
088A6:  MOVWF  x22
088A8:  MOVLB  0
088AA:  CALL   11F6
088AE:  MOVLB  B
088B0:  DECFSZ x00,F
088B2:  BRA    88A4
....................          if(RIGHT && LEFT){ 
088B4:  BSF    F93.6
088B6:  BTFSC  F81.6
088B8:  BRA    88D8
088BA:  BSF    F93.7
088BC:  BTFSC  F81.7
088BE:  BRA    88D8
....................             printf("page PostPurga"); 
088C0:  MOVLW  00
088C2:  MOVWF  FF6
088C4:  MOVLW  0C
088C6:  MOVWF  FF7
088C8:  MOVLW  00
088CA:  MOVWF  FF8
088CC:  MOVLB  0
088CE:  CALL   1304
....................             SendDataDisplay(); 
088D2:  CALL   1336
088D6:  MOVLB  B
....................          } 
....................       }else{ 
088D8:  BRA    8912
088DA:  MOVLB  0
....................          if(RIGHT){ 
088DC:  BSF    F93.6
088DE:  BTFSC  F81.6
088E0:  BRA    88F6
....................             delay_ms(10); 
088E2:  MOVLW  0A
088E4:  MOVLB  B
088E6:  MOVWF  x22
088E8:  MOVLB  0
088EA:  CALL   11F6
....................             if(RIGHT){ 
088EE:  BSF    F93.6
088F0:  BTFSC  F81.6
088F2:  BRA    88F6
....................                flag_blower=!flag_blower; 
088F4:  BTG    x7D.1
....................             } 
....................          } 
....................           
....................          if(LEFT){ 
088F6:  BSF    F93.7
088F8:  BTFSC  F81.7
088FA:  BRA    8910
....................             delay_ms(10); 
088FC:  MOVLW  0A
088FE:  MOVLB  B
08900:  MOVWF  x22
08902:  MOVLB  0
08904:  CALL   11F6
....................             if(LEFT){ 
08908:  BSF    F93.7
0890A:  BTFSC  F81.7
0890C:  BRA    8910
....................                flag_uv=!flag_uv; 
0890E:  BTG    x7D.5
08910:  MOVLB  B
....................             } 
....................          } 
....................       } 
....................        
....................       if(UP){//Si oprime boton de Toma.          
08912:  BSF    F93.4
08914:  BTFSC  F81.4
08916:  BRA    8962
....................          delay_ms(500); 
08918:  MOVLW  02
0891A:  MOVWF  x00
0891C:  MOVLW  FA
0891E:  MOVWF  x22
08920:  MOVLB  0
08922:  CALL   11F6
08926:  MOVLB  B
08928:  DECFSZ x00,F
0892A:  BRA    891C
....................          if(UP){//Si oprime boton de Toma. 
0892C:  BSF    F93.4
0892E:  BTFSC  F81.4
08930:  BRA    8954
....................             delay_ms(30); 
08932:  MOVLW  1E
08934:  MOVWF  x22
08936:  MOVLB  0
08938:  CALL   11F6
....................             printf("page Ajustes"); 
0893C:  MOVLW  10
0893E:  MOVWF  FF6
08940:  MOVLW  0C
08942:  MOVWF  FF7
08944:  MOVLW  00
08946:  MOVWF  FF8
08948:  CALL   1304
....................             SendDataDisplay(); 
0894C:  CALL   1336
....................          }else{ 
08950:  BRA    8960
08952:  MOVLB  B
....................             delay_ms(30);flag_toma=!flag_toma; 
08954:  MOVLW  1E
08956:  MOVWF  x22
08958:  MOVLB  0
0895A:  CALL   11F6
0895E:  BTG    x7D.2
08960:  MOVLB  B
....................          } 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x01){          
08962:  DECFSZ 35,W
08964:  BRA    8970
....................          flag_luz=!flag_luz; 
08966:  MOVLB  0
08968:  BTG    x7D.3
....................          RX_Buffer[4]=0x00;   
0896A:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
0896C:  CLRF   40
0896E:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x02){ 
08970:  MOVF   35,W
08972:  SUBLW  02
08974:  BNZ   8980
....................          flag_blower=!flag_blower; 
08976:  MOVLB  0
08978:  BTG    x7D.1
....................          RX_Buffer[4]=0x00;   
0897A:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
0897C:  CLRF   40
0897E:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x03){ 
08980:  MOVF   35,W
08982:  SUBLW  03
08984:  BNZ   8990
....................          flag_toma=!flag_toma; 
08986:  MOVLB  0
08988:  BTG    x7D.2
....................          RX_Buffer[4]=0x00;   
0898A:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
0898C:  CLRF   40
0898E:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x04){ 
08990:  MOVF   35,W
08992:  SUBLW  04
08994:  BNZ   89A0
....................          flag_uv=!flag_uv; 
08996:  MOVLB  0
08998:  BTG    x7D.5
....................          RX_Buffer[4]=0x00;   
0899A:  CLRF   35
....................          RX_Buffer2[4]=0x00; 
0899C:  CLRF   40
0899E:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x05){          
089A0:  MOVF   35,W
089A2:  SUBLW  05
089A4:  BNZ   89BE
....................          printf("page Ajustes"); 
089A6:  MOVLW  1E
089A8:  MOVWF  FF6
089AA:  MOVLW  0C
089AC:  MOVWF  FF7
089AE:  MOVLW  00
089B0:  MOVWF  FF8
089B2:  MOVLB  0
089B4:  CALL   1304
....................          SendDataDisplay(); 
089B8:  CALL   1336
089BC:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0a){          
089BE:  MOVF   35,W
089C0:  SUBLW  0A
089C2:  BNZ   89D0
....................          subirVidrio(); 
089C4:  MOVLB  0
089C6:  CALL   3454
....................          BYTE_IR[3]=0x00; 
089CA:  MOVLB  2
089CC:  CLRF   xE2
089CE:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0c){          
089D0:  MOVF   35,W
089D2:  SUBLW  0C
089D4:  BNZ   89E2
....................          bajarVidrio(); 
089D6:  MOVLB  0
089D8:  CALL   3430
....................          BYTE_IR[3]=0x00; 
089DC:  MOVLB  2
089DE:  CLRF   xE2
089E0:  MOVLB  B
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0b || RX_Buffer[4]==0x0d){          
089E2:  MOVF   35,W
089E4:  SUBLW  0B
089E6:  BZ    89EE
089E8:  MOVF   35,W
089EA:  SUBLW  0D
089EC:  BNZ   89FA
....................          detenerVidrio(); 
089EE:  MOVLB  0
089F0:  CALL   5274
....................          BYTE_IR[3]=0x00; 
089F4:  MOVLB  2
089F6:  CLRF   xE2
089F8:  MOVLB  B
089FA:  MOVLB  0
....................       } 
....................       /* 
....................       if(RX_Buffer[4]==0x06){          
....................          printf("page PostPurga"); 
....................          SendDataDisplay(); 
....................       } 
....................       */ 
....................              
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==6){//Menu de Post-Purga. 
089FC:  MOVF   x81,W
089FE:  SUBLW  06
08A00:  BTFSS  FD8.2
08A02:  BRA    8BD4
....................          tiempo_postpurga=1; 
08A04:  BSF    x80.1
....................          LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off; 
08A06:  BSF    F8C.0
08A08:  BCF    F95.0
08A0A:  BSF    F8C.1
08A0C:  BCF    F95.1
08A0E:  BCF    F8B.1
08A10:  BCF    F94.1
08A12:  BCF    F8B.0
08A14:  BCF    F94.0
....................          printf("minPurga.txt=\"%02u\"",mPPurga); 
08A16:  MOVLW  2C
08A18:  MOVWF  FF6
08A1A:  MOVLW  0C
08A1C:  MOVWF  FF7
08A1E:  MOVLW  00
08A20:  MOVWF  FF8
08A22:  MOVLW  0E
08A24:  MOVLB  B
08A26:  MOVWF  x02
08A28:  MOVLB  0
08A2A:  CALL   5198
08A2E:  MOVFF  B2,B01
08A32:  MOVLW  01
08A34:  MOVLB  B
08A36:  MOVWF  x02
08A38:  MOVLB  0
08A3A:  CALL   51F6
08A3E:  MOVLW  22
08A40:  BTFSS  F9E.4
08A42:  BRA    8A40
08A44:  MOVWF  FAD
....................          SendDataDisplay(); 
08A46:  CALL   1336
....................          printf("secPurga.txt=\"%02u\"",sPPurga); 
08A4A:  MOVLW  40
08A4C:  MOVWF  FF6
08A4E:  MOVLW  0C
08A50:  MOVWF  FF7
08A52:  MOVLW  00
08A54:  MOVWF  FF8
08A56:  MOVLW  0E
08A58:  MOVLB  B
08A5A:  MOVWF  x02
08A5C:  MOVLB  0
08A5E:  CALL   5198
08A62:  MOVFF  B0,B01
08A66:  MOVLW  01
08A68:  MOVLB  B
08A6A:  MOVWF  x02
08A6C:  MOVLB  0
08A6E:  CALL   51F6
08A72:  MOVLW  22
08A74:  BTFSS  F9E.4
08A76:  BRA    8A74
08A78:  MOVWF  FAD
....................          SendDataDisplay(); 
08A7A:  CALL   1336
....................          VelMotor=Vel1; 
08A7E:  MOVFF  93,2D3
....................          VelMotor2=Vel2; 
08A82:  MOVFF  94,2D4
....................          Aux_on; 
08A86:  BCF    F8C.2
08A88:  BCF    F95.2
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
08A8A:  MOVLW  54
08A8C:  MOVWF  FF6
08A8E:  MOVLW  0C
08A90:  MOVWF  FF7
08A92:  MOVLW  00
08A94:  MOVWF  FF8
08A96:  MOVLW  11
08A98:  MOVLB  B
08A9A:  MOVWF  x02
08A9C:  MOVLB  0
08A9E:  CALL   5198
08AA2:  MOVFF  98,B01
08AA6:  MOVLW  01
08AA8:  MOVLB  B
08AAA:  MOVWF  x02
08AAC:  MOVLB  0
08AAE:  CALL   51F6
08AB2:  MOVLW  2F
08AB4:  BTFSS  F9E.4
08AB6:  BRA    8AB4
08AB8:  MOVWF  FAD
08ABA:  MOVFF  97,B01
08ABE:  MOVLW  01
08AC0:  MOVLB  B
08AC2:  MOVWF  x02
08AC4:  MOVLB  0
08AC6:  CALL   51F6
08ACA:  MOVLW  2F
08ACC:  BTFSS  F9E.4
08ACE:  BRA    8ACC
08AD0:  MOVWF  FAD
08AD2:  MOVLW  32
08AD4:  BTFSS  F9E.4
08AD6:  BRA    8AD4
08AD8:  MOVWF  FAD
08ADA:  MOVLW  30
08ADC:  BTFSS  F9E.4
08ADE:  BRA    8ADC
08AE0:  MOVWF  FAD
08AE2:  MOVFF  96,B01
08AE6:  MOVLW  01
08AE8:  MOVLB  B
08AEA:  MOVWF  x02
08AEC:  MOVLB  0
08AEE:  CALL   51F6
08AF2:  MOVLW  75
08AF4:  MOVWF  FF6
08AF6:  MOVLW  0C
08AF8:  MOVWF  FF7
08AFA:  MOVLW  00
08AFC:  MOVWF  FF8
08AFE:  MOVLW  0A
08B00:  MOVLB  B
08B02:  MOVWF  x02
08B04:  MOVLB  0
08B06:  CALL   5198
08B0A:  MOVFF  99,B01
08B0E:  MOVLW  01
08B10:  MOVLB  B
08B12:  MOVWF  x02
08B14:  MOVLB  0
08B16:  CALL   51F6
08B1A:  MOVLW  3A
08B1C:  BTFSS  F9E.4
08B1E:  BRA    8B1C
08B20:  MOVWF  FAD
08B22:  MOVFF  9A,B01
08B26:  MOVLW  01
08B28:  MOVLB  B
08B2A:  MOVWF  x02
08B2C:  MOVLB  0
08B2E:  CALL   51F6
08B32:  MOVLW  3A
08B34:  BTFSS  F9E.4
08B36:  BRA    8B34
08B38:  MOVWF  FAD
08B3A:  MOVFF  9B,B01
08B3E:  MOVLW  01
08B40:  MOVLB  B
08B42:  MOVWF  x02
08B44:  MOVLB  0
08B46:  CALL   51F6
08B4A:  MOVLW  20
08B4C:  BTFSS  F9E.4
08B4E:  BRA    8B4C
08B50:  MOVWF  FAD
08B52:  MOVLW  20
08B54:  BTFSS  F9E.4
08B56:  BRA    8B54
08B58:  MOVWF  FAD
08B5A:  MOVLW  22
08B5C:  BTFSS  F9E.4
08B5E:  BRA    8B5C
08B60:  MOVWF  FAD
....................          SendDataDisplay(); 
08B62:  CALL   1336
....................           
....................          if(RX_Buffer[4]==0x11){ 
08B66:  MOVF   35,W
08B68:  SUBLW  11
08B6A:  BNZ   8B86
....................             tiempo_postpurga=0; 
08B6C:  BCF    x80.1
....................             printf("page Principal"); 
08B6E:  MOVLW  92
08B70:  MOVWF  FF6
08B72:  MOVLW  0C
08B74:  MOVWF  FF7
08B76:  MOVLW  00
08B78:  MOVWF  FF8
08B7A:  CALL   1304
....................             SendDataDisplay(); 
08B7E:  CALL   1336
....................             RX_Buffer[4]=0x00;   
08B82:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
08B84:  CLRF   40
....................          } 
....................         
....................          if((sPPurga>=sPPurgap)&&(mPPurga>=mPPurgap)){ 
08B86:  MOVF   xB1,W
08B88:  SUBWF  xB0,W
08B8A:  BNC   8BD4
08B8C:  MOVF   xB3,W
08B8E:  SUBWF  xB2,W
08B90:  BNC   8BD4
....................             tiempo_postpurga=0; 
08B92:  BCF    x80.1
....................             ApagaSalidas(); 
08B94:  CALL   517A
....................             //Display_off; 
....................             Encendio=OFF; 
08B98:  BCF    x7F.6
....................             VelMotor=0;VelMotor2=0;LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off;Motor_off;Motor2_off;Aux_off; 
08B9A:  MOVLB  2
08B9C:  CLRF   xD3
08B9E:  CLRF   xD4
08BA0:  BSF    F8C.0
08BA2:  BCF    F95.0
08BA4:  BSF    F8C.1
08BA6:  BCF    F95.1
08BA8:  BCF    F8B.1
08BAA:  BCF    F94.1
08BAC:  BCF    F8B.0
08BAE:  BCF    F94.0
08BB0:  BCF    F8B.3
08BB2:  BCF    F94.3
08BB4:  BCF    F8B.2
08BB6:  BCF    F94.2
08BB8:  BSF    F8C.2
08BBA:  BCF    F95.2
....................             printf("page Off"); 
08BBC:  MOVLW  A2
08BBE:  MOVWF  FF6
08BC0:  MOVLW  0C
08BC2:  MOVWF  FF7
08BC4:  MOVLW  00
08BC6:  MOVWF  FF8
08BC8:  MOVLB  0
08BCA:  CALL   1304
....................             SendDataDisplay(); 
08BCE:  CALL   1336
....................             reset_cpu(); 
08BD2:  RESET
....................          }       
....................       } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................       if(Menu==7){ //Menu de Configuracin de Fecha y Hora 
08BD4:  MOVF   x81,W
08BD6:  SUBLW  07
08BD8:  BTFSS  FD8.2
08BDA:  BRA    8FD0
....................          if(RX_Buffer[4]==0x0a){//Selecciono Hora 
08BDC:  MOVF   35,W
08BDE:  SUBLW  0A
08BE0:  BNZ   8BE6
....................             Opcion=4; 
08BE2:  MOVLW  04
08BE4:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Minuto 
08BE6:  MOVF   35,W
08BE8:  SUBLW  0B
08BEA:  BNZ   8BF0
....................             Opcion=5; 
08BEC:  MOVLW  05
08BEE:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c){//Selecciono Dia 
08BF0:  MOVF   35,W
08BF2:  SUBLW  0C
08BF4:  BNZ   8BFA
....................             Opcion=1; 
08BF6:  MOVLW  01
08BF8:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0d){//Selecciono Hora 
08BFA:  MOVF   35,W
08BFC:  SUBLW  0D
08BFE:  BNZ   8C04
....................             Opcion=2; 
08C00:  MOVLW  02
08C02:  MOVWF  x82
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0e){//Selecciono Year 
08C04:  MOVF   35,W
08C06:  SUBLW  0E
08C08:  BNZ   8C0E
....................             Opcion=3; 
08C0A:  MOVLW  03
08C0C:  MOVWF  x82
....................          } 
....................           
....................          if(RIGHT){ 
08C0E:  BSF    F93.6
08C10:  BTFSC  F81.6
08C12:  BRA    8C28
....................             delay_ms(200); 
08C14:  MOVLW  C8
08C16:  MOVLB  B
08C18:  MOVWF  x22
08C1A:  MOVLB  0
08C1C:  CALL   11F6
....................             if(RIGHT){ 
08C20:  BSF    F93.6
08C22:  BTFSC  F81.6
08C24:  BRA    8C28
....................                Opcion++; 
08C26:  INCF   x82,F
....................             } 
....................          } 
....................          if(Opcion>5) 
08C28:  MOVF   x82,W
08C2A:  SUBLW  05
08C2C:  BC    8C32
....................             Opcion=1; 
08C2E:  MOVLW  01
08C30:  MOVWF  x82
....................          if(Opcion<1) 
08C32:  MOVF   x82,F
08C34:  BNZ   8C3A
....................             Opcion=5; 
08C36:  MOVLW  05
08C38:  MOVWF  x82
....................              
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
08C3A:  MOVF   35,W
08C3C:  SUBLW  11
08C3E:  BZ    8C46
08C40:  BSF    F93.7
08C42:  BTFSC  F81.7
08C44:  BRA    8D44
....................             printf("page Ajustes"); 
08C46:  MOVLW  AC
08C48:  MOVWF  FF6
08C4A:  MOVLW  0C
08C4C:  MOVWF  FF7
08C4E:  MOVLW  00
08C50:  MOVWF  FF8
08C52:  CALL   1304
....................             SendDataDisplay();   
08C56:  CALL   1336
....................             PantallaPrincipal=0; 
08C5A:  CLRF   xA9
....................              
....................             if(esBisiesto(YearTx)) 
08C5C:  MOVFF  9F,B00
08C60:  CALL   5BF2
08C64:  MOVF   01,F
08C66:  BZ    8C7C
....................                Modulo=Bisiesto[MesTx]; 
08C68:  CLRF   03
08C6A:  MOVF   xA0,W
08C6C:  ADDLW  71
08C6E:  MOVWF  FE9
08C70:  MOVLW  00
08C72:  ADDWFC 03,W
08C74:  MOVWF  FEA
08C76:  MOVFF  FEF,B9
....................             else 
08C7A:  BRA    8C8E
....................                Modulo=Regular[MesTx]; 
08C7C:  CLRF   03
08C7E:  MOVF   xA0,W
08C80:  ADDLW  65
08C82:  MOVWF  FE9
08C84:  MOVLW  00
08C86:  ADDWFC 03,W
08C88:  MOVWF  FEA
08C8A:  MOVFF  FEF,B9
....................           
....................             dowTx=((YearTx-1)%7+((YearTx-1)/4-3*((YearTx-1)/100+1)/4)%7+Modulo+DiaTx%7)%7; 
08C8E:  MOVLW  01
08C90:  SUBWF  x9F,W
08C92:  MOVLB  B
08C94:  MOVWF  x01
08C96:  MOVWF  x09
08C98:  MOVLW  07
08C9A:  MOVWF  x0A
08C9C:  MOVLB  0
08C9E:  CALL   51CA
08CA2:  MOVFF  00,B00
08CA6:  MOVLW  01
08CA8:  SUBWF  x9F,W
08CAA:  MOVWF  00
08CAC:  RRCF   00,W
08CAE:  MOVLB  B
08CB0:  MOVWF  x01
08CB2:  RRCF   x01,F
08CB4:  MOVLW  3F
08CB6:  ANDWF  x01,F
08CB8:  MOVLW  01
08CBA:  MOVLB  0
08CBC:  SUBWF  x9F,W
08CBE:  MOVLB  B
08CC0:  MOVWF  x03
08CC2:  MOVWF  x09
08CC4:  MOVLW  64
08CC6:  MOVWF  x0A
08CC8:  MOVLB  0
08CCA:  CALL   51CA
08CCE:  MOVLW  01
08CD0:  ADDWF  01,W
08CD2:  MULLW  03
08CD4:  MOVFF  FF3,00
08CD8:  RRCF   00,F
08CDA:  RRCF   00,F
08CDC:  MOVLW  3F
08CDE:  ANDWF  00,F
08CE0:  MOVF   00,W
08CE2:  MOVLB  B
08CE4:  SUBWF  x01,W
08CE6:  MOVWF  x02
08CE8:  MOVWF  x09
08CEA:  MOVLW  07
08CEC:  MOVWF  x0A
08CEE:  MOVLB  0
08CF0:  CALL   51CA
08CF4:  MOVF   00,W
08CF6:  MOVLB  B
08CF8:  ADDWF  x00,W
08CFA:  MOVLB  0
08CFC:  ADDWF  xB9,W
08CFE:  MOVLB  B
08D00:  MOVWF  x00
08D02:  MOVFF  A1,B09
08D06:  MOVLW  07
08D08:  MOVWF  x0A
08D0A:  MOVLB  0
08D0C:  CALL   51CA
08D10:  MOVF   00,W
08D12:  MOVLB  B
08D14:  ADDWF  x00,W
08D16:  MOVWF  x01
08D18:  MOVWF  x09
08D1A:  MOVLW  07
08D1C:  MOVWF  x0A
08D1E:  MOVLB  0
08D20:  CALL   51CA
08D24:  MOVFF  00,A4
....................             rtc_set_datetime(DiaTx,MesTx,YearTx,dowTx,HoraTx,MinutoTx); 
08D28:  MOVFF  A1,B00
08D2C:  MOVFF  A0,B01
08D30:  MOVFF  9F,B02
08D34:  MOVFF  A4,B03
08D38:  MOVFF  A2,B04
08D3C:  MOVFF  A3,B05
08D40:  GOTO   5C78
....................          } 
....................           
....................          if((RX_Buffer[4]==0x2a)|| UP){//Tecla Arriba Oprimida 
08D44:  MOVF   35,W
08D46:  SUBLW  2A
08D48:  BZ    8D50
08D4A:  BSF    F93.4
08D4C:  BTFSC  F81.4
08D4E:  BRA    8E44
....................             delay_ms(200); 
08D50:  MOVLW  C8
08D52:  MOVLB  B
08D54:  MOVWF  x22
08D56:  MOVLB  0
08D58:  CALL   11F6
....................             if((RX_Buffer[4]==0x2a)|| UP){    
08D5C:  MOVF   35,W
08D5E:  SUBLW  2A
08D60:  BZ    8D68
08D62:  BSF    F93.4
08D64:  BTFSC  F81.4
08D66:  BRA    8E44
....................                if(Opcion==1){ 
08D68:  DECFSZ x82,W
08D6A:  BRA    8DF0
....................                   if(MesTx==2){ 
08D6C:  MOVF   xA0,W
08D6E:  SUBLW  02
08D70:  BNZ   8D9E
....................                      if(esBisiesto(YearTx)){ 
08D72:  MOVFF  9F,B00
08D76:  CALL   5BF2
08D7A:  MOVF   01,F
08D7C:  BZ    8D8E
....................                         if(DiaTx<29) 
08D7E:  MOVF   xA1,W
08D80:  SUBLW  1C
08D82:  BNC   8D88
....................                            DiaTx++; 
08D84:  INCF   xA1,F
....................                         else 
08D86:  BRA    8D8C
....................                            DiaTx=1;    
08D88:  MOVLW  01
08D8A:  MOVWF  xA1
....................                      }else{ 
08D8C:  BRA    8D9C
....................                         if(DiaTx<28) 
08D8E:  MOVF   xA1,W
08D90:  SUBLW  1B
08D92:  BNC   8D98
....................                            DiaTx++; 
08D94:  INCF   xA1,F
....................                         else 
08D96:  BRA    8D9C
....................                            DiaTx=1;    
08D98:  MOVLW  01
08D9A:  MOVWF  xA1
....................                      } 
....................                   }else{ 
08D9C:  BRA    8DEE
....................                      if(MesTx<=7){ 
08D9E:  MOVF   xA0,W
08DA0:  SUBLW  07
08DA2:  BNC   8DCA
....................                         if(MesTx % 2 ==0){ 
08DA4:  MOVF   xA0,W
08DA6:  ANDLW  01
08DA8:  BNZ   8DBA
....................                            if(DiaTx<30) 
08DAA:  MOVF   xA1,W
08DAC:  SUBLW  1D
08DAE:  BNC   8DB4
....................                               DiaTx++;     
08DB0:  INCF   xA1,F
....................                            else 
08DB2:  BRA    8DB8
....................                               DiaTx=1;    
08DB4:  MOVLW  01
08DB6:  MOVWF  xA1
....................                         }else{ 
08DB8:  BRA    8DC8
....................                            if(DiaTx<31) 
08DBA:  MOVF   xA1,W
08DBC:  SUBLW  1E
08DBE:  BNC   8DC4
....................                               DiaTx++;     
08DC0:  INCF   xA1,F
....................                            else 
08DC2:  BRA    8DC8
....................                               DiaTx=1;    
08DC4:  MOVLW  01
08DC6:  MOVWF  xA1
....................                         }     
....................                      }else{ 
08DC8:  BRA    8DEE
....................                         if(MesTx % 2 ==0){ 
08DCA:  MOVF   xA0,W
08DCC:  ANDLW  01
08DCE:  BNZ   8DE0
....................                            if(DiaTx<31) 
08DD0:  MOVF   xA1,W
08DD2:  SUBLW  1E
08DD4:  BNC   8DDA
....................                               DiaTx++;   
08DD6:  INCF   xA1,F
....................                            else 
08DD8:  BRA    8DDE
....................                               DiaTx=1; 
08DDA:  MOVLW  01
08DDC:  MOVWF  xA1
....................                         }else{ 
08DDE:  BRA    8DEE
....................                            if(DiaTx<30) 
08DE0:  MOVF   xA1,W
08DE2:  SUBLW  1D
08DE4:  BNC   8DEA
....................                               DiaTx++;     
08DE6:  INCF   xA1,F
....................                            else 
08DE8:  BRA    8DEE
....................                               DiaTx=1; 
08DEA:  MOVLW  01
08DEC:  MOVWF  xA1
....................                         }     
....................                      } 
....................                   } 
....................                }else if(Opcion==2){ 
08DEE:  BRA    8E40
08DF0:  MOVF   x82,W
08DF2:  SUBLW  02
08DF4:  BNZ   8E06
....................                   if(MesTx<12) 
08DF6:  MOVF   xA0,W
08DF8:  SUBLW  0B
08DFA:  BNC   8E00
....................                      MesTx++; 
08DFC:  INCF   xA0,F
....................                   else 
08DFE:  BRA    8E04
....................                      MesTx=1; 
08E00:  MOVLW  01
08E02:  MOVWF  xA0
....................                }else if(Opcion==3){ 
08E04:  BRA    8E40
08E06:  MOVF   x82,W
08E08:  SUBLW  03
08E0A:  BNZ   8E1A
....................                   if(YearTx<99) 
08E0C:  MOVF   x9F,W
08E0E:  SUBLW  62
08E10:  BNC   8E16
....................                      YearTx++; 
08E12:  INCF   x9F,F
....................                   else  
08E14:  BRA    8E18
....................                      YearTx=0; 
08E16:  CLRF   x9F
....................                }else if(Opcion==4){ 
08E18:  BRA    8E40
08E1A:  MOVF   x82,W
08E1C:  SUBLW  04
08E1E:  BNZ   8E2E
....................                   if(HoraTx<24) 
08E20:  MOVF   xA2,W
08E22:  SUBLW  17
08E24:  BNC   8E2A
....................                      HoraTx++; 
08E26:  INCF   xA2,F
....................                   else 
08E28:  BRA    8E2C
....................                      HoraTx=0; 
08E2A:  CLRF   xA2
....................                }else if(Opcion==5){ 
08E2C:  BRA    8E40
08E2E:  MOVF   x82,W
08E30:  SUBLW  05
08E32:  BNZ   8E40
....................                   if(MinutoTx<59) 
08E34:  MOVF   xA3,W
08E36:  SUBLW  3A
08E38:  BNC   8E3E
....................                      MinutoTx++; 
08E3A:  INCF   xA3,F
....................                   else 
08E3C:  BRA    8E40
....................                      MinutoTx=0; 
08E3E:  CLRF   xA3
....................                } 
....................                RX_Buffer[4]=0x00; 
08E40:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
08E42:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x2b || DOWN){//Tecla Abajo Oprimida 
08E44:  MOVF   35,W
08E46:  SUBLW  2B
08E48:  BZ    8E50
08E4A:  BSF    F93.5
08E4C:  BTFSC  F81.5
08E4E:  BRA    8EC8
....................             delay_ms(200); 
08E50:  MOVLW  C8
08E52:  MOVLB  B
08E54:  MOVWF  x22
08E56:  MOVLB  0
08E58:  CALL   11F6
....................             if(RX_Buffer[4]==0x2b || DOWN){    
08E5C:  MOVF   35,W
08E5E:  SUBLW  2B
08E60:  BZ    8E68
08E62:  BSF    F93.5
08E64:  BTFSC  F81.5
08E66:  BRA    8EC8
....................                if(Opcion==1){ 
08E68:  DECFSZ x82,W
08E6A:  BRA    8E74
....................                   if(DiaTx>0) 
08E6C:  MOVF   xA1,F
08E6E:  BZ    8E72
....................                      DiaTx--; 
08E70:  DECF   xA1,F
....................                }else if(Opcion==2){ 
08E72:  BRA    8EC4
08E74:  MOVF   x82,W
08E76:  SUBLW  02
08E78:  BNZ   8E8A
....................                   if(MesTx>1) 
08E7A:  MOVF   xA0,W
08E7C:  SUBLW  01
08E7E:  BC    8E84
....................                      MesTx--; 
08E80:  DECF   xA0,F
....................                   else 
08E82:  BRA    8E88
....................                      MesTx=12; 
08E84:  MOVLW  0C
08E86:  MOVWF  xA0
....................                }else if(Opcion==3){ 
08E88:  BRA    8EC4
08E8A:  MOVF   x82,W
08E8C:  SUBLW  03
08E8E:  BNZ   8E9E
....................                   if(YearTx>0) 
08E90:  MOVF   x9F,F
08E92:  BZ    8E98
....................                      YearTx--; 
08E94:  DECF   x9F,F
....................                   else 
08E96:  BRA    8E9C
....................                      YearTx=99; 
08E98:  MOVLW  63
08E9A:  MOVWF  x9F
....................                }else if(Opcion==4){ 
08E9C:  BRA    8EC4
08E9E:  MOVF   x82,W
08EA0:  SUBLW  04
08EA2:  BNZ   8EB2
....................                   if(HoraTx>0) 
08EA4:  MOVF   xA2,F
08EA6:  BZ    8EAC
....................                      HoraTx--; 
08EA8:  DECF   xA2,F
....................                   else 
08EAA:  BRA    8EB0
....................                      HoraTx=23; 
08EAC:  MOVLW  17
08EAE:  MOVWF  xA2
....................                }else if(Opcion==5){ 
08EB0:  BRA    8EC4
08EB2:  MOVF   x82,W
08EB4:  SUBLW  05
08EB6:  BNZ   8EC4
....................                   if(MinutoTx>0) 
08EB8:  MOVF   xA3,F
08EBA:  BZ    8EC0
....................                      MinutoTx--; 
08EBC:  DECF   xA3,F
....................                   else 
08EBE:  BRA    8EC4
....................                      MinutoTx=59; 
08EC0:  MOVLW  3B
08EC2:  MOVWF  xA3
....................                } 
....................                RX_Buffer[4]=0x00; 
08EC4:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
08EC6:  CLRF   40
....................             } 
....................          } 
....................        
....................       printf("thora.txt=\"%02u\"",HoraTx); 
08EC8:  MOVLW  BA
08ECA:  MOVWF  FF6
08ECC:  MOVLW  0C
08ECE:  MOVWF  FF7
08ED0:  MOVLW  00
08ED2:  MOVWF  FF8
08ED4:  MOVLW  0B
08ED6:  MOVLB  B
08ED8:  MOVWF  x02
08EDA:  MOVLB  0
08EDC:  CALL   5198
08EE0:  MOVFF  A2,B01
08EE4:  MOVLW  01
08EE6:  MOVLB  B
08EE8:  MOVWF  x02
08EEA:  MOVLB  0
08EEC:  CALL   51F6
08EF0:  MOVLW  22
08EF2:  BTFSS  F9E.4
08EF4:  BRA    8EF2
08EF6:  MOVWF  FAD
....................       SendDataDisplay(); 
08EF8:  CALL   1336
....................       printf("tminutos.txt=\"%02u\"",MinutoTx); 
08EFC:  MOVLW  CC
08EFE:  MOVWF  FF6
08F00:  MOVLW  0C
08F02:  MOVWF  FF7
08F04:  MOVLW  00
08F06:  MOVWF  FF8
08F08:  MOVLW  0E
08F0A:  MOVLB  B
08F0C:  MOVWF  x02
08F0E:  MOVLB  0
08F10:  CALL   5198
08F14:  MOVFF  A3,B01
08F18:  MOVLW  01
08F1A:  MOVLB  B
08F1C:  MOVWF  x02
08F1E:  MOVLB  0
08F20:  CALL   51F6
08F24:  MOVLW  22
08F26:  BTFSS  F9E.4
08F28:  BRA    8F26
08F2A:  MOVWF  FAD
....................       SendDataDisplay(); 
08F2C:  CALL   1336
....................       printf("tdia.txt=\"%02u\"",DiaTx); 
08F30:  MOVLW  E0
08F32:  MOVWF  FF6
08F34:  MOVLW  0C
08F36:  MOVWF  FF7
08F38:  MOVLW  00
08F3A:  MOVWF  FF8
08F3C:  MOVLW  0A
08F3E:  MOVLB  B
08F40:  MOVWF  x02
08F42:  MOVLB  0
08F44:  CALL   5198
08F48:  MOVFF  A1,B01
08F4C:  MOVLW  01
08F4E:  MOVLB  B
08F50:  MOVWF  x02
08F52:  MOVLB  0
08F54:  CALL   51F6
08F58:  MOVLW  22
08F5A:  BTFSS  F9E.4
08F5C:  BRA    8F5A
08F5E:  MOVWF  FAD
....................       SendDataDisplay(); 
08F60:  CALL   1336
....................       printf("tmes.txt=\"%02u\"",MesTx); 
08F64:  MOVLW  F0
08F66:  MOVWF  FF6
08F68:  MOVLW  0C
08F6A:  MOVWF  FF7
08F6C:  MOVLW  00
08F6E:  MOVWF  FF8
08F70:  MOVLW  0A
08F72:  MOVLB  B
08F74:  MOVWF  x02
08F76:  MOVLB  0
08F78:  CALL   5198
08F7C:  MOVFF  A0,B01
08F80:  MOVLW  01
08F82:  MOVLB  B
08F84:  MOVWF  x02
08F86:  MOVLB  0
08F88:  CALL   51F6
08F8C:  MOVLW  22
08F8E:  BTFSS  F9E.4
08F90:  BRA    8F8E
08F92:  MOVWF  FAD
....................       SendDataDisplay(); 
08F94:  CALL   1336
....................       printf("tyear.txt=\"%02u\"",YearTx); 
08F98:  MOVLW  00
08F9A:  MOVWF  FF6
08F9C:  MOVLW  0D
08F9E:  MOVWF  FF7
08FA0:  MOVLW  00
08FA2:  MOVWF  FF8
08FA4:  MOVLW  0B
08FA6:  MOVLB  B
08FA8:  MOVWF  x02
08FAA:  MOVLB  0
08FAC:  CALL   5198
08FB0:  MOVFF  9F,B01
08FB4:  MOVLW  01
08FB6:  MOVLB  B
08FB8:  MOVWF  x02
08FBA:  MOVLB  0
08FBC:  CALL   51F6
08FC0:  MOVLW  22
08FC2:  BTFSS  F9E.4
08FC4:  BRA    8FC2
08FC6:  MOVWF  FAD
....................       SendDataDisplay(); 
08FC8:  CALL   1336
....................       LimitaDia();   
08FCC:  GOTO   5D34
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==8){//Menu de off 
08FD0:  MOVF   x81,W
08FD2:  SUBLW  08
08FD4:  BNZ   90A2
....................       VelMotor=0;VelMotor2=0;LuzBlanca_off;LuzUV_off;Toma_off;Alarma_off;Motor_off;Motor2_off;Aux_off; 
08FD6:  MOVLB  2
08FD8:  CLRF   xD3
08FDA:  CLRF   xD4
08FDC:  BSF    F8C.0
08FDE:  BCF    F95.0
08FE0:  BSF    F8C.1
08FE2:  BCF    F95.1
08FE4:  BCF    F8B.1
08FE6:  BCF    F94.1
08FE8:  BCF    F8B.0
08FEA:  BCF    F94.0
08FEC:  BCF    F8B.3
08FEE:  BCF    F94.3
08FF0:  BCF    F8B.2
08FF2:  BCF    F94.2
08FF4:  BSF    F8C.2
08FF6:  BCF    F95.2
....................       mPurga=0;sPurga=0;mPPurga=0;sPPurga=0;mUV=0;sUV=0;flagClave=0;tClave=0; 
08FF8:  MOVLB  0
08FFA:  CLRF   xAE
08FFC:  CLRF   xAC
08FFE:  CLRF   xB2
09000:  CLRF   xB0
09002:  CLRF   xB5
09004:  CLRF   xB4
09006:  BCF    x7F.5
09008:  CLRF   xC8
0900A:  CLRF   xC7
....................       tiempo_purga=0;tiempo_postpurga=0;TipoClave=0; 
0900C:  BCF    x7E.2
0900E:  BCF    x80.1
09010:  CLRF   xA8
....................       if(!Encendio) 
09012:  BTFSC  x7F.6
09014:  BRA    9084
....................          //Display_off; 
....................        
....................       if(RIGHT || UP || DOWN){ 
09016:  BSF    F93.6
09018:  BTFSS  F81.6
0901A:  BRA    9028
0901C:  BSF    F93.4
0901E:  BTFSS  F81.4
09020:  BRA    9028
09022:  BSF    F93.5
09024:  BTFSC  F81.5
09026:  BRA    9084
....................          delay_ms(500); 
09028:  MOVLW  02
0902A:  MOVLB  B
0902C:  MOVWF  x00
0902E:  MOVLW  FA
09030:  MOVWF  x22
09032:  MOVLB  0
09034:  CALL   11F6
09038:  MOVLB  B
0903A:  DECFSZ x00,F
0903C:  BRA    902E
....................          if(RIGHT || UP || DOWN){ 
0903E:  BSF    F93.6
09040:  BTFSS  F81.6
09042:  BRA    9050
09044:  BSF    F93.4
09046:  BTFSS  F81.4
09048:  BRA    9050
0904A:  BSF    F93.5
0904C:  BTFSC  F81.5
0904E:  BRA    9086
....................             Display_on; 
09050:  BSF    F8C.5
09052:  BCF    F95.5
....................             Encendio=ON; 
09054:  MOVLB  0
09056:  BSF    x7F.6
....................             delay_ms(1000); 
09058:  MOVLW  04
0905A:  MOVLB  B
0905C:  MOVWF  x00
0905E:  MOVLW  FA
09060:  MOVWF  x22
09062:  MOVLB  0
09064:  CALL   11F6
09068:  MOVLB  B
0906A:  DECFSZ x00,F
0906C:  BRA    905E
....................             printf("page Bienvenida"); 
0906E:  MOVLW  12
09070:  MOVWF  FF6
09072:  MOVLW  0D
09074:  MOVWF  FF7
09076:  MOVLW  00
09078:  MOVWF  FF8
0907A:  MOVLB  0
0907C:  CALL   1304
....................             SendDataDisplay();                   
09080:  CALL   1336
09084:  MOVLB  B
....................          } 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x11){ 
09086:  MOVF   35,W
09088:  SUBLW  11
0908A:  BNZ   90A4
....................          printf("page Bienvenida"); 
0908C:  MOVLW  22
0908E:  MOVWF  FF6
09090:  MOVLW  0D
09092:  MOVWF  FF7
09094:  MOVLW  00
09096:  MOVWF  FF8
09098:  MOVLB  0
0909A:  CALL   1304
....................          SendDataDisplay();                   
0909E:  CALL   1336
090A2:  MOVLB  B
....................       } 
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==9){ //Menu de Tiempo de UV 
090A4:  MOVLB  0
090A6:  MOVF   x81,W
090A8:  SUBLW  09
090AA:  BTFSS  FD8.2
090AC:  BRA    93DC
....................          printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u:%02u  \"",Dia,Mes,Year,Hora,Minuto,Segundo); 
090AE:  MOVLW  32
090B0:  MOVWF  FF6
090B2:  MOVLW  0D
090B4:  MOVWF  FF7
090B6:  MOVLW  00
090B8:  MOVWF  FF8
090BA:  MOVLW  11
090BC:  MOVLB  B
090BE:  MOVWF  x02
090C0:  MOVLB  0
090C2:  CALL   5198
090C6:  MOVFF  98,B01
090CA:  MOVLW  01
090CC:  MOVLB  B
090CE:  MOVWF  x02
090D0:  MOVLB  0
090D2:  CALL   51F6
090D6:  MOVLW  2F
090D8:  BTFSS  F9E.4
090DA:  BRA    90D8
090DC:  MOVWF  FAD
090DE:  MOVFF  97,B01
090E2:  MOVLW  01
090E4:  MOVLB  B
090E6:  MOVWF  x02
090E8:  MOVLB  0
090EA:  CALL   51F6
090EE:  MOVLW  2F
090F0:  BTFSS  F9E.4
090F2:  BRA    90F0
090F4:  MOVWF  FAD
090F6:  MOVLW  32
090F8:  BTFSS  F9E.4
090FA:  BRA    90F8
090FC:  MOVWF  FAD
090FE:  MOVLW  30
09100:  BTFSS  F9E.4
09102:  BRA    9100
09104:  MOVWF  FAD
09106:  MOVFF  96,B01
0910A:  MOVLW  01
0910C:  MOVLB  B
0910E:  MOVWF  x02
09110:  MOVLB  0
09112:  CALL   51F6
09116:  MOVLW  53
09118:  MOVWF  FF6
0911A:  MOVLW  0D
0911C:  MOVWF  FF7
0911E:  MOVLW  00
09120:  MOVWF  FF8
09122:  MOVLW  0A
09124:  MOVLB  B
09126:  MOVWF  x02
09128:  MOVLB  0
0912A:  CALL   5198
0912E:  MOVFF  99,B01
09132:  MOVLW  01
09134:  MOVLB  B
09136:  MOVWF  x02
09138:  MOVLB  0
0913A:  CALL   51F6
0913E:  MOVLW  3A
09140:  BTFSS  F9E.4
09142:  BRA    9140
09144:  MOVWF  FAD
09146:  MOVFF  9A,B01
0914A:  MOVLW  01
0914C:  MOVLB  B
0914E:  MOVWF  x02
09150:  MOVLB  0
09152:  CALL   51F6
09156:  MOVLW  3A
09158:  BTFSS  F9E.4
0915A:  BRA    9158
0915C:  MOVWF  FAD
0915E:  MOVFF  9B,B01
09162:  MOVLW  01
09164:  MOVLB  B
09166:  MOVWF  x02
09168:  MOVLB  0
0916A:  CALL   51F6
0916E:  MOVLW  20
09170:  BTFSS  F9E.4
09172:  BRA    9170
09174:  MOVWF  FAD
09176:  MOVLW  20
09178:  BTFSS  F9E.4
0917A:  BRA    9178
0917C:  MOVWF  FAD
0917E:  MOVLW  22
09180:  BTFSS  F9E.4
09182:  BRA    9180
09184:  MOVWF  FAD
....................          SendDataDisplay(); 
09186:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Selecciono Minutos 
0918A:  MOVF   35,W
0918C:  SUBLW  0A
0918E:  BNZ   9194
....................             Minutos=ON; 
09190:  BSF    x7E.7
....................             Segundos=OFF; 
09192:  BCF    x7F.0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Selecciono Segundos 
09194:  MOVF   35,W
09196:  SUBLW  0B
09198:  BNZ   919E
....................             Segundos=ON; 
0919A:  BSF    x7F.0
....................             Minutos=OFF; 
0919C:  BCF    x7E.7
....................          }     
....................           
....................          if(RIGHT){ 
0919E:  BSF    F93.6
091A0:  BTFSC  F81.6
091A2:  BRA    9218
....................             delay_ms(200); 
091A4:  MOVLW  C8
091A6:  MOVLB  B
091A8:  MOVWF  x22
091AA:  MOVLB  0
091AC:  CALL   11F6
....................             if(RIGHT){ 
091B0:  BSF    F93.6
091B2:  BTFSC  F81.6
091B4:  BRA    9218
....................                if(!Segundos){ 
091B6:  BTFSC  x7F.0
091B8:  BRA    91E8
....................                   Segundos=ON; 
091BA:  BSF    x7F.0
....................                   Minutos=OFF; 
091BC:  BCF    x7E.7
....................                   printf("tsecest.pco=65535"); 
091BE:  MOVLW  70
091C0:  MOVWF  FF6
091C2:  MOVLW  0D
091C4:  MOVWF  FF7
091C6:  MOVLW  00
091C8:  MOVWF  FF8
091CA:  CALL   1304
....................                   SendDataDisplay();   
091CE:  CALL   1336
....................                   printf("tminest.pco=0"); 
091D2:  MOVLW  82
091D4:  MOVWF  FF6
091D6:  MOVLW  0D
091D8:  MOVWF  FF7
091DA:  MOVLW  00
091DC:  MOVWF  FF8
091DE:  CALL   1304
....................                   SendDataDisplay();   
091E2:  CALL   1336
....................                }else if(!Minutos){ 
091E6:  BRA    9218
091E8:  BTFSC  x7E.7
091EA:  BRA    9218
....................                   Segundos=OFF; 
091EC:  BCF    x7F.0
....................                   Minutos=ON; 
091EE:  BSF    x7E.7
....................                   printf("tsecest.pco=0"); 
091F0:  MOVLW  90
091F2:  MOVWF  FF6
091F4:  MOVLW  0D
091F6:  MOVWF  FF7
091F8:  MOVLW  00
091FA:  MOVWF  FF8
091FC:  CALL   1304
....................                   SendDataDisplay();   
09200:  CALL   1336
....................                   printf("tminest.pco=65535"); 
09204:  MOVLW  9E
09206:  MOVWF  FF6
09208:  MOVLW  0D
0920A:  MOVWF  FF7
0920C:  MOVLW  00
0920E:  MOVWF  FF8
09210:  CALL   1304
....................                   SendDataDisplay();   
09214:  CALL   1336
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x11 || LEFT){//Selecciono Regresar 
09218:  MOVF   35,W
0921A:  SUBLW  11
0921C:  BZ    9224
0921E:  BSF    F93.7
09220:  BTFSC  F81.7
09222:  BRA    92D6
....................             delay_ms(200); 
09224:  MOVLW  C8
09226:  MOVLB  B
09228:  MOVWF  x22
0922A:  MOVLB  0
0922C:  CALL   11F6
....................             if(RX_Buffer[4]==0x11 || LEFT){ 
09230:  MOVF   35,W
09232:  SUBLW  11
09234:  BZ    923C
09236:  BSF    F93.7
09238:  BTFSC  F81.7
0923A:  BRA    92D6
....................                Segundos=OFF; 
0923C:  BCF    x7F.0
....................                Minutos=OFF; 
0923E:  BCF    x7E.7
....................                printf("page Ajustes"); 
09240:  MOVLW  B0
09242:  MOVWF  FF6
09244:  MOVLW  0D
09246:  MOVWF  FF7
09248:  MOVLW  00
0924A:  MOVWF  FF8
0924C:  CALL   1304
....................                SendDataDisplay();   
09250:  CALL   1336
....................                if(!GuardaEEPROM){ 
09254:  BTFSC  x7E.6
09256:  BRA    92D6
....................                   write_eeprom(8,mUVp); 
09258:  CLRF   FAA
0925A:  MOVLW  08
0925C:  MOVWF  FA9
0925E:  MOVFF  B7,FA8
09262:  BCF    FA6.6
09264:  BCF    FA6.7
09266:  BSF    FA6.2
09268:  MOVF   FF2,W
0926A:  MOVWF  00
0926C:  BCF    FF2.6
0926E:  BCF    FF2.7
09270:  MOVLB  F
09272:  MOVLW  55
09274:  MOVWF  FA7
09276:  MOVLW  AA
09278:  MOVWF  FA7
0927A:  BSF    FA6.1
0927C:  BTFSC  FA6.1
0927E:  BRA    927C
09280:  BCF    FA6.2
09282:  MOVF   00,W
09284:  IORWF  FF2,F
....................                   delay_ms(10); 
09286:  MOVLW  0A
09288:  MOVLB  B
0928A:  MOVWF  x22
0928C:  MOVLB  0
0928E:  CALL   11F6
....................                   write_eeprom(9,sUVp); 
09292:  CLRF   FAA
09294:  MOVLW  09
09296:  MOVWF  FA9
09298:  MOVFF  B6,FA8
0929C:  BCF    FA6.6
0929E:  BCF    FA6.7
092A0:  BSF    FA6.2
092A2:  MOVF   FF2,W
092A4:  MOVWF  00
092A6:  BCF    FF2.6
092A8:  BCF    FF2.7
092AA:  MOVLB  F
092AC:  MOVLW  55
092AE:  MOVWF  FA7
092B0:  MOVLW  AA
092B2:  MOVWF  FA7
092B4:  BSF    FA6.1
092B6:  BTFSC  FA6.1
092B8:  BRA    92B6
092BA:  BCF    FA6.2
092BC:  MOVF   00,W
092BE:  IORWF  FF2,F
....................                   delay_ms(10); 
092C0:  MOVLW  0A
092C2:  MOVLB  B
092C4:  MOVWF  x22
092C6:  MOVLB  0
092C8:  CALL   11F6
....................                   mUV=mUVp; 
092CC:  MOVFF  B7,B5
....................                   sUV=sUVp; 
092D0:  MOVFF  B6,B4
....................                   GuardaEEPROM=ON; 
092D4:  BSF    x7E.6
....................                } 
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
092D6:  MOVF   35,W
092D8:  SUBLW  0C
092DA:  BZ    92E8
092DC:  MOVF   35,W
092DE:  SUBLW  0D
092E0:  BZ    92E8
092E2:  BSF    F93.4
092E4:  BTFSC  F81.4
092E6:  BRA    9316
....................             delay_ms(10); 
092E8:  MOVLW  0A
092EA:  MOVLB  B
092EC:  MOVWF  x22
092EE:  MOVLB  0
092F0:  CALL   11F6
....................             if(RX_Buffer[4]==0x0c || RX_Buffer[4]==0x0d || UP){//Tecla arriba Oprimida 
092F4:  MOVF   35,W
092F6:  SUBLW  0C
092F8:  BZ    9306
092FA:  MOVF   35,W
092FC:  SUBLW  0D
092FE:  BZ    9306
09300:  BSF    F93.4
09302:  BTFSC  F81.4
09304:  BRA    9316
....................                if(Segundos){ 
09306:  BTFSS  x7F.0
09308:  BRA    930C
....................                   sUVp++; 
0930A:  INCF   xB6,F
....................                } 
....................                if(Minutos){ 
0930C:  BTFSS  x7E.7
0930E:  BRA    9312
....................                   mUVp++; 
09310:  INCF   xB7,F
....................                }   
....................                RX_Buffer[4]=0x00;   
09312:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09314:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
09316:  MOVF   35,W
09318:  SUBLW  0F
0931A:  BZ    9328
0931C:  MOVF   35,W
0931E:  SUBLW  0E
09320:  BZ    9328
09322:  BSF    F93.5
09324:  BTFSC  F81.5
09326:  BRA    935A
....................             delay_ms(10); 
09328:  MOVLW  0A
0932A:  MOVLB  B
0932C:  MOVWF  x22
0932E:  MOVLB  0
09330:  CALL   11F6
....................             if(RX_Buffer[4]==0x0f || RX_Buffer[4]==0x0e || DOWN){//Tecla abajo oprimida 
09334:  MOVF   35,W
09336:  SUBLW  0F
09338:  BZ    9346
0933A:  MOVF   35,W
0933C:  SUBLW  0E
0933E:  BZ    9346
09340:  BSF    F93.5
09342:  BTFSC  F81.5
09344:  BRA    935A
....................                if(Segundos && sUVp>0){ 
09346:  BTFSS  x7F.0
09348:  BRA    9350
0934A:  MOVF   xB6,F
0934C:  BZ    9350
....................                   sUVp--; 
0934E:  DECF   xB6,F
....................                } 
....................                if(Minutos){ 
09350:  BTFSS  x7E.7
09352:  BRA    9356
....................                   mUVp--; 
09354:  DECF   xB7,F
....................                } 
....................                RX_Buffer[4]=0x00;   
09356:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09358:  CLRF   40
....................             } 
....................          } 
....................           
....................          if(mUVp<1)mUVp=99; 
0935A:  MOVF   xB7,F
0935C:  BNZ   9362
0935E:  MOVLW  63
09360:  MOVWF  xB7
....................          if(mUVp>99)mUVp=1; 
09362:  MOVF   xB7,W
09364:  SUBLW  63
09366:  BC    936C
09368:  MOVLW  01
0936A:  MOVWF  xB7
....................          if(sUVp>59)sUVp=0; 
0936C:  MOVF   xB6,W
0936E:  SUBLW  3B
09370:  BTFSS  FD8.0
09372:  CLRF   xB6
....................              
....................          printf("tminest.txt=\"%02u\"",mUVp); 
09374:  MOVLW  BE
09376:  MOVWF  FF6
09378:  MOVLW  0D
0937A:  MOVWF  FF7
0937C:  MOVLW  00
0937E:  MOVWF  FF8
09380:  MOVLW  0D
09382:  MOVLB  B
09384:  MOVWF  x02
09386:  MOVLB  0
09388:  CALL   5198
0938C:  MOVFF  B7,B01
09390:  MOVLW  01
09392:  MOVLB  B
09394:  MOVWF  x02
09396:  MOVLB  0
09398:  CALL   51F6
0939C:  MOVLW  22
0939E:  BTFSS  F9E.4
093A0:  BRA    939E
093A2:  MOVWF  FAD
....................          SendDataDisplay(); 
093A4:  CALL   1336
....................          printf("tsecest.txt=\"%02u\"",sUVp); 
093A8:  MOVLW  D2
093AA:  MOVWF  FF6
093AC:  MOVLW  0D
093AE:  MOVWF  FF7
093B0:  MOVLW  00
093B2:  MOVWF  FF8
093B4:  MOVLW  0D
093B6:  MOVLB  B
093B8:  MOVWF  x02
093BA:  MOVLB  0
093BC:  CALL   5198
093C0:  MOVFF  B6,B01
093C4:  MOVLW  01
093C6:  MOVLB  B
093C8:  MOVWF  x02
093CA:  MOVLB  0
093CC:  CALL   51F6
093D0:  MOVLW  22
093D2:  BTFSS  F9E.4
093D4:  BRA    93D2
093D6:  MOVWF  FAD
....................          SendDataDisplay(); 
093D8:  CALL   1336
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==10){ // Menu de Mantenimiento 
093DC:  MOVF   x81,W
093DE:  SUBLW  0A
093E0:  BTFSS  FD8.2
093E2:  BRA    9A98
....................           
....................          LuzBlanca_on; 
093E4:  BCF    F8C.0
093E6:  BCF    F95.0
....................          UVTime=Tuv[0]+(Tuv[1]*10)+(Tuv[2]*100)+(Tuv[3]*1000);    
093E8:  MOVFF  CA,B01
093EC:  MOVLW  0A
093EE:  MOVLB  B
093F0:  MOVWF  x02
093F2:  MOVLB  0
093F4:  CALL   530C
093F8:  MOVF   01,W
093FA:  ADDWF  xC9,W
093FC:  MOVLB  B
093FE:  MOVWF  x00
09400:  MOVFF  CB,B01
09404:  MOVLW  64
09406:  MOVWF  x02
09408:  MOVLB  0
0940A:  CALL   530C
0940E:  MOVF   01,W
09410:  MOVLB  B
09412:  ADDWF  x00,F
09414:  CLRF   03
09416:  MOVLB  0
09418:  MOVF   xCC,W
0941A:  MOVWF  00
0941C:  BTFSC  FE8.7
0941E:  DECF   03,F
09420:  MOVLB  B
09422:  MOVWF  x01
09424:  MOVFF  03,B02
09428:  MOVFF  03,B04
0942C:  MOVWF  x03
0942E:  MOVLW  03
09430:  MOVWF  x06
09432:  MOVLW  E8
09434:  MOVWF  x05
09436:  MOVLB  0
09438:  CALL   535A
0943C:  MOVFF  02,03
09440:  MOVF   01,W
09442:  MOVLB  B
09444:  ADDWF  x00,W
09446:  MOVWF  01
09448:  MOVLW  00
0944A:  ADDWFC 03,F
0944C:  MOVFF  01,B00
09450:  MOVFF  03,B01
09454:  MOVLB  0
09456:  CALL   53AE
0945A:  MOVFF  03,108
0945E:  MOVFF  02,107
09462:  MOVFF  01,106
09466:  MOVFF  00,105
....................          TrabajoTime=Ttrabajo[0]+(Ttrabajo[1]*10)+(Ttrabajo[2]*100)+(Ttrabajo[3]*1000); 
0946A:  MOVFF  CE,B01
0946E:  MOVLW  0A
09470:  MOVLB  B
09472:  MOVWF  x02
09474:  MOVLB  0
09476:  CALL   530C
0947A:  MOVF   01,W
0947C:  ADDWF  xCD,W
0947E:  MOVLB  B
09480:  MOVWF  x00
09482:  MOVFF  CF,B01
09486:  MOVLW  64
09488:  MOVWF  x02
0948A:  MOVLB  0
0948C:  CALL   530C
09490:  MOVF   01,W
09492:  MOVLB  B
09494:  ADDWF  x00,F
09496:  CLRF   03
09498:  MOVLB  0
0949A:  MOVF   xD0,W
0949C:  MOVWF  00
0949E:  BTFSC  FE8.7
094A0:  DECF   03,F
094A2:  MOVLB  B
094A4:  MOVWF  x01
094A6:  MOVFF  03,B02
094AA:  MOVFF  03,B04
094AE:  MOVWF  x03
094B0:  MOVLW  03
094B2:  MOVWF  x06
094B4:  MOVLW  E8
094B6:  MOVWF  x05
094B8:  MOVLB  0
094BA:  CALL   535A
094BE:  MOVFF  02,03
094C2:  MOVF   01,W
094C4:  MOVLB  B
094C6:  ADDWF  x00,W
094C8:  MOVWF  01
094CA:  MOVLW  00
094CC:  ADDWFC 03,F
094CE:  MOVFF  01,B00
094D2:  MOVFF  03,B01
094D6:  MOVLB  0
094D8:  CALL   53AE
094DC:  MOVFF  03,10C
094E0:  MOVFF  02,10B
094E4:  MOVFF  01,10A
094E8:  MOVFF  00,109
....................           
....................          printf("b0.txt=\"UV(horas):%05Lu %X\"",(int16)UVTime,BYTE_IR[3]); 
094EC:  MOVFF  108,B03
094F0:  MOVFF  107,B02
094F4:  MOVFF  106,B01
094F8:  MOVFF  105,B00
094FC:  CALL   513E
09500:  MOVFF  02,B01
09504:  MOVFF  01,B00
09508:  MOVLW  E6
0950A:  MOVWF  FF6
0950C:  MOVLW  0D
0950E:  MOVWF  FF7
09510:  MOVLW  00
09512:  MOVWF  FF8
09514:  MOVLW  12
09516:  MOVLB  B
09518:  MOVWF  x02
0951A:  MOVLB  0
0951C:  CALL   5198
09520:  MOVLW  08
09522:  MOVWF  FE9
09524:  MOVFF  B01,B03
09528:  MOVFF  B00,B02
0952C:  CALL   5DBC
09530:  MOVLW  20
09532:  BTFSS  F9E.4
09534:  BRA    9532
09536:  MOVWF  FAD
09538:  MOVFF  2E2,B02
0953C:  MOVLW  37
0953E:  MOVLB  B
09540:  MOVWF  x03
09542:  MOVLB  0
09544:  CALL   5E66
09548:  MOVLW  22
0954A:  BTFSS  F9E.4
0954C:  BRA    954A
0954E:  MOVWF  FAD
....................          SendDataDisplay(); 
09550:  CALL   1336
....................          printf("b1.txt=\"Filtro(horas):%05Lu\"",(int16)TrabajoTime); 
09554:  MOVFF  10C,B03
09558:  MOVFF  10B,B02
0955C:  MOVFF  10A,B01
09560:  MOVFF  109,B00
09564:  CALL   513E
09568:  MOVFF  02,B01
0956C:  MOVFF  01,B00
09570:  MOVLW  02
09572:  MOVWF  FF6
09574:  MOVLW  0E
09576:  MOVWF  FF7
09578:  MOVLW  00
0957A:  MOVWF  FF8
0957C:  MOVLW  16
0957E:  MOVLB  B
09580:  MOVWF  x02
09582:  MOVLB  0
09584:  CALL   5198
09588:  MOVLW  08
0958A:  MOVWF  FE9
0958C:  MOVFF  B01,B03
09590:  MOVFF  B00,B02
09594:  CALL   5DBC
09598:  MOVLW  22
0959A:  BTFSS  F9E.4
0959C:  BRA    959A
0959E:  MOVWF  FAD
....................          SendDataDisplay(); 
095A0:  CALL   1336
....................           
....................          printf("ceroIn.txt=\"Cero InFlow: %2.0f\"",Flujo[1].zero_actual); 
095A4:  MOVLW  20
095A6:  MOVWF  FF6
095A8:  MOVLW  0E
095AA:  MOVWF  FF7
095AC:  MOVLW  00
095AE:  MOVWF  FF8
095B0:  MOVLW  19
095B2:  MOVLB  B
095B4:  MOVWF  x02
095B6:  MOVLB  0
095B8:  CALL   5198
095BC:  MOVLW  01
095BE:  MOVWF  FE9
095C0:  MOVFF  43F,B03
095C4:  MOVFF  43E,B02
095C8:  MOVFF  43D,B01
095CC:  MOVFF  43C,B00
095D0:  MOVLB  B
095D2:  CLRF   x04
095D4:  MOVLB  0
095D6:  CALL   54C2
095DA:  MOVLW  22
095DC:  BTFSS  F9E.4
095DE:  BRA    95DC
095E0:  MOVWF  FAD
....................          SendDataDisplay(); 
095E2:  CALL   1336
....................          printf("ceroDn.txt=\"Cero DnFlow: %2.0f\"",Flujo[2].zero_actual); 
095E6:  MOVLW  40
095E8:  MOVWF  FF6
095EA:  MOVLW  0E
095EC:  MOVWF  FF7
095EE:  MOVLW  00
095F0:  MOVWF  FF8
095F2:  MOVLW  19
095F4:  MOVLB  B
095F6:  MOVWF  x02
095F8:  MOVLB  0
095FA:  CALL   5198
095FE:  MOVLW  01
09600:  MOVWF  FE9
09602:  MOVFF  598,B03
09606:  MOVFF  597,B02
0960A:  MOVFF  596,B01
0960E:  MOVFF  595,B00
09612:  MOVLB  B
09614:  CLRF   x04
09616:  MOVLB  0
09618:  CALL   54C2
0961C:  MOVLW  22
0961E:  BTFSS  F9E.4
09620:  BRA    961E
09622:  MOVWF  FAD
....................          SendDataDisplay(); 
09624:  CALL   1336
....................          printf("ajusteIn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[1].ajuste); 
09628:  MOVLW  60
0962A:  MOVWF  FF6
0962C:  MOVLW  0E
0962E:  MOVWF  FF7
09630:  MOVLW  00
09632:  MOVWF  FF8
09634:  MOVLW  1D
09636:  MOVLB  B
09638:  MOVWF  x02
0963A:  MOVLB  0
0963C:  CALL   5198
09640:  MOVLW  01
09642:  MOVWF  FE9
09644:  MOVFF  454,B03
09648:  MOVFF  453,B02
0964C:  MOVFF  452,B01
09650:  MOVFF  451,B00
09654:  MOVLB  B
09656:  MOVWF  x04
09658:  MOVLB  0
0965A:  CALL   54C2
0965E:  MOVLW  22
09660:  BTFSS  F9E.4
09662:  BRA    9660
09664:  MOVWF  FAD
....................          SendDataDisplay(); 
09666:  CALL   1336
....................          printf("ajusteDn.txt=\"Ajuste InFlow: %2.1f\"",Flujo[2].ajuste); 
0966A:  MOVLW  84
0966C:  MOVWF  FF6
0966E:  MOVLW  0E
09670:  MOVWF  FF7
09672:  MOVLW  00
09674:  MOVWF  FF8
09676:  MOVLW  1D
09678:  MOVLB  B
0967A:  MOVWF  x02
0967C:  MOVLB  0
0967E:  CALL   5198
09682:  MOVLW  01
09684:  MOVWF  FE9
09686:  MOVFF  5AD,B03
0968A:  MOVFF  5AC,B02
0968E:  MOVFF  5AB,B01
09692:  MOVFF  5AA,B00
09696:  MOVLB  B
09698:  MOVWF  x04
0969A:  MOVLB  0
0969C:  CALL   54C2
096A0:  MOVLW  22
096A2:  BTFSS  F9E.4
096A4:  BRA    96A2
096A6:  MOVWF  FAD
....................          SendDataDisplay(); 
096A8:  CALL   1336
....................          printf("inflow.txt=\"InFlow: %2.2f %2.2f \"",Flujo[1].Velocidad,Flujo[1].Flujo); 
096AC:  MOVLW  A8
096AE:  MOVWF  FF6
096B0:  MOVLW  0E
096B2:  MOVWF  FF7
096B4:  MOVLW  00
096B6:  MOVWF  FF8
096B8:  MOVLW  14
096BA:  MOVLB  B
096BC:  MOVWF  x02
096BE:  MOVLB  0
096C0:  CALL   5198
096C4:  MOVLW  89
096C6:  MOVWF  FE9
096C8:  MOVFF  44A,B03
096CC:  MOVFF  449,B02
096D0:  MOVFF  448,B01
096D4:  MOVFF  447,B00
096D8:  MOVLW  02
096DA:  MOVLB  B
096DC:  MOVWF  x04
096DE:  MOVLB  0
096E0:  CALL   54C2
096E4:  MOVLW  20
096E6:  BTFSS  F9E.4
096E8:  BRA    96E6
096EA:  MOVWF  FAD
096EC:  MOVLW  89
096EE:  MOVWF  FE9
096F0:  MOVFF  450,B03
096F4:  MOVFF  44F,B02
096F8:  MOVFF  44E,B01
096FC:  MOVFF  44D,B00
09700:  MOVLW  02
09702:  MOVLB  B
09704:  MOVWF  x04
09706:  MOVLB  0
09708:  CALL   54C2
0970C:  MOVLW  20
0970E:  BTFSS  F9E.4
09710:  BRA    970E
09712:  MOVWF  FAD
09714:  MOVLW  22
09716:  BTFSS  F9E.4
09718:  BRA    9716
0971A:  MOVWF  FAD
....................          SendDataDisplay(); 
0971C:  CALL   1336
....................          printf("downflow.txt=\"DownFlow: %2.2f\"",DownFlow); 
09720:  MOVLW  CA
09722:  MOVWF  FF6
09724:  MOVLW  0E
09726:  MOVWF  FF7
09728:  MOVLW  00
0972A:  MOVWF  FF8
0972C:  MOVLW  18
0972E:  MOVLB  B
09730:  MOVWF  x02
09732:  MOVLB  0
09734:  CALL   5198
09738:  MOVLW  89
0973A:  MOVWF  FE9
0973C:  MOVFF  E0,B03
09740:  MOVFF  DF,B02
09744:  MOVFF  DE,B01
09748:  MOVFF  DD,B00
0974C:  MOVLW  02
0974E:  MOVLB  B
09750:  MOVWF  x04
09752:  MOVLB  0
09754:  CALL   54C2
09758:  MOVLW  22
0975A:  BTFSS  F9E.4
0975C:  BRA    975A
0975E:  MOVWF  FAD
....................          SendDataDisplay(); 
09760:  CALL   1336
....................          printf("adcin.txt=\"ADCIn: %04Lu\"",(int16)Flujo[1].adc); 
09764:  MOVLW  EA
09766:  MOVWF  FF6
09768:  MOVLW  0E
0976A:  MOVWF  FF7
0976C:  MOVLW  00
0976E:  MOVWF  FF8
09770:  MOVLW  12
09772:  MOVLB  B
09774:  MOVWF  x02
09776:  MOVLB  0
09778:  CALL   5198
0977C:  MOVLW  09
0977E:  MOVWF  FE9
09780:  MOVFF  445,B03
09784:  MOVFF  444,B02
09788:  CALL   5DBC
0978C:  MOVLW  22
0978E:  BTFSS  F9E.4
09790:  BRA    978E
09792:  MOVWF  FAD
....................          SendDataDisplay(); 
09794:  CALL   1336
....................          printf("adcdn.txt=\"ADCDn: %04Lu\"",sensores(2)); 
09798:  MOVLW  02
0979A:  MOVLB  B
0979C:  MOVWF  x1F
0979E:  MOVLB  0
097A0:  CALL   38CA
097A4:  MOVFF  02,B01
097A8:  MOVFF  01,B00
097AC:  MOVLW  04
097AE:  MOVWF  FF6
097B0:  MOVLW  0F
097B2:  MOVWF  FF7
097B4:  MOVLW  00
097B6:  MOVWF  FF8
097B8:  MOVLW  12
097BA:  MOVLB  B
097BC:  MOVWF  x02
097BE:  MOVLB  0
097C0:  CALL   5198
097C4:  MOVLW  09
097C6:  MOVWF  FE9
097C8:  MOVFF  B01,B03
097CC:  MOVFF  B00,B02
097D0:  CALL   5DBC
097D4:  MOVLW  22
097D6:  BTFSS  F9E.4
097D8:  BRA    97D6
097DA:  MOVWF  FAD
....................          SendDataDisplay(); 
097DC:  CALL   1336
....................           
....................          if(RX_Buffer[4]==0x01 || (UP && RIGHT)){ // Reinicia Tiempo de Luz UV          
097E0:  DECFSZ 35,W
097E2:  BRA    97E6
097E4:  BRA    97F2
097E6:  BSF    F93.4
097E8:  BTFSC  F81.4
097EA:  BRA    991E
097EC:  BSF    F93.6
097EE:  BTFSC  F81.6
097F0:  BRA    991E
....................             delay_ms(2000);  
097F2:  MOVLW  08
097F4:  MOVLB  B
097F6:  MOVWF  x00
097F8:  MOVLW  FA
097FA:  MOVWF  x22
097FC:  MOVLB  0
097FE:  CALL   11F6
09802:  MOVLB  B
09804:  DECFSZ x00,F
09806:  BRA    97F8
....................             if(RX_Buffer[4]==0x01 || (UP && RIGHT)){ // Reinicia Tiempo de Luz UV 
09808:  DECFSZ 35,W
0980A:  BRA    980E
0980C:  BRA    981A
0980E:  BSF    F93.4
09810:  BTFSC  F81.4
09812:  BRA    9920
09814:  BSF    F93.6
09816:  BTFSC  F81.6
09818:  BRA    9920
....................                write_eeprom(12,0); 
0981A:  CLRF   FAA
0981C:  MOVLW  0C
0981E:  MOVWF  FA9
09820:  CLRF   FA8
09822:  BCF    FA6.6
09824:  BCF    FA6.7
09826:  BSF    FA6.2
09828:  MOVF   FF2,W
0982A:  MOVWF  00
0982C:  BCF    FF2.6
0982E:  BCF    FF2.7
09830:  MOVLB  F
09832:  MOVLW  55
09834:  MOVWF  FA7
09836:  MOVLW  AA
09838:  MOVWF  FA7
0983A:  BSF    FA6.1
0983C:  BTFSC  FA6.1
0983E:  BRA    983C
09840:  BCF    FA6.2
09842:  MOVF   00,W
09844:  IORWF  FF2,F
....................                delay_ms(20); 
09846:  MOVLW  14
09848:  MOVLB  B
0984A:  MOVWF  x22
0984C:  MOVLB  0
0984E:  CALL   11F6
....................                write_eeprom(13,0); 
09852:  CLRF   FAA
09854:  MOVLW  0D
09856:  MOVWF  FA9
09858:  CLRF   FA8
0985A:  BCF    FA6.6
0985C:  BCF    FA6.7
0985E:  BSF    FA6.2
09860:  MOVF   FF2,W
09862:  MOVWF  00
09864:  BCF    FF2.6
09866:  BCF    FF2.7
09868:  MOVLB  F
0986A:  MOVLW  55
0986C:  MOVWF  FA7
0986E:  MOVLW  AA
09870:  MOVWF  FA7
09872:  BSF    FA6.1
09874:  BTFSC  FA6.1
09876:  BRA    9874
09878:  BCF    FA6.2
0987A:  MOVF   00,W
0987C:  IORWF  FF2,F
....................                delay_ms(20); 
0987E:  MOVLW  14
09880:  MOVLB  B
09882:  MOVWF  x22
09884:  MOVLB  0
09886:  CALL   11F6
....................                write_eeprom(14,0); 
0988A:  CLRF   FAA
0988C:  MOVLW  0E
0988E:  MOVWF  FA9
09890:  CLRF   FA8
09892:  BCF    FA6.6
09894:  BCF    FA6.7
09896:  BSF    FA6.2
09898:  MOVF   FF2,W
0989A:  MOVWF  00
0989C:  BCF    FF2.6
0989E:  BCF    FF2.7
098A0:  MOVLB  F
098A2:  MOVLW  55
098A4:  MOVWF  FA7
098A6:  MOVLW  AA
098A8:  MOVWF  FA7
098AA:  BSF    FA6.1
098AC:  BTFSC  FA6.1
098AE:  BRA    98AC
098B0:  BCF    FA6.2
098B2:  MOVF   00,W
098B4:  IORWF  FF2,F
....................                delay_ms(20); 
098B6:  MOVLW  14
098B8:  MOVLB  B
098BA:  MOVWF  x22
098BC:  MOVLB  0
098BE:  CALL   11F6
....................                write_eeprom(15,0); 
098C2:  CLRF   FAA
098C4:  MOVLW  0F
098C6:  MOVWF  FA9
098C8:  CLRF   FA8
098CA:  BCF    FA6.6
098CC:  BCF    FA6.7
098CE:  BSF    FA6.2
098D0:  MOVF   FF2,W
098D2:  MOVWF  00
098D4:  BCF    FF2.6
098D6:  BCF    FF2.7
098D8:  MOVLB  F
098DA:  MOVLW  55
098DC:  MOVWF  FA7
098DE:  MOVLW  AA
098E0:  MOVWF  FA7
098E2:  BSF    FA6.1
098E4:  BTFSC  FA6.1
098E6:  BRA    98E4
098E8:  BCF    FA6.2
098EA:  MOVF   00,W
098EC:  IORWF  FF2,F
....................                delay_ms(20); 
098EE:  MOVLW  14
098F0:  MOVLB  B
098F2:  MOVWF  x22
098F4:  MOVLB  0
098F6:  CALL   11F6
....................                Tuv[3]=0;Tuv[2]=0;Tuv[1]=0;Tuv[0]=0; 
098FA:  CLRF   xCC
098FC:  CLRF   xCB
098FE:  CLRF   xCA
09900:  CLRF   xC9
....................                LuzBlanca_off; 
09902:  BSF    F8C.0
09904:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
09906:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09908:  CLRF   40
....................                printf("page Ajustes"); 
0990A:  MOVLW  1E
0990C:  MOVWF  FF6
0990E:  MOVLW  0F
09910:  MOVWF  FF7
09912:  MOVLW  00
09914:  MOVWF  FF8
09916:  CALL   1304
....................                SendDataDisplay(); 
0991A:  CALL   1336
0991E:  MOVLB  B
....................             } 
....................          } 
....................        
....................          if(RX_Buffer[4]==0x02 || (DOWN && RIGHT)){ // Reinicia Tiempo de Trabajo         
09920:  MOVF   35,W
09922:  SUBLW  02
09924:  BZ    9932
09926:  BSF    F93.5
09928:  BTFSC  F81.5
0992A:  BRA    9A5E
0992C:  BSF    F93.6
0992E:  BTFSC  F81.6
09930:  BRA    9A5E
....................             delay_ms(2000); 
09932:  MOVLW  08
09934:  MOVWF  x00
09936:  MOVLW  FA
09938:  MOVWF  x22
0993A:  MOVLB  0
0993C:  CALL   11F6
09940:  MOVLB  B
09942:  DECFSZ x00,F
09944:  BRA    9936
....................             if(RX_Buffer[4]==0x02 || (DOWN && RIGHT)){ // Reinicia Tiempo de Trabajo         
09946:  MOVF   35,W
09948:  SUBLW  02
0994A:  BZ    9958
0994C:  BSF    F93.5
0994E:  BTFSC  F81.5
09950:  BRA    9A5E
09952:  BSF    F93.6
09954:  BTFSC  F81.6
09956:  BRA    9A5E
....................                write_eeprom(16,0); 
09958:  CLRF   FAA
0995A:  MOVLW  10
0995C:  MOVWF  FA9
0995E:  CLRF   FA8
09960:  BCF    FA6.6
09962:  BCF    FA6.7
09964:  BSF    FA6.2
09966:  MOVF   FF2,W
09968:  MOVWF  00
0996A:  BCF    FF2.6
0996C:  BCF    FF2.7
0996E:  MOVLB  F
09970:  MOVLW  55
09972:  MOVWF  FA7
09974:  MOVLW  AA
09976:  MOVWF  FA7
09978:  BSF    FA6.1
0997A:  BTFSC  FA6.1
0997C:  BRA    997A
0997E:  BCF    FA6.2
09980:  MOVF   00,W
09982:  IORWF  FF2,F
....................                delay_ms(20); 
09984:  MOVLW  14
09986:  MOVLB  B
09988:  MOVWF  x22
0998A:  MOVLB  0
0998C:  CALL   11F6
....................                write_eeprom(17,0); 
09990:  CLRF   FAA
09992:  MOVLW  11
09994:  MOVWF  FA9
09996:  CLRF   FA8
09998:  BCF    FA6.6
0999A:  BCF    FA6.7
0999C:  BSF    FA6.2
0999E:  MOVF   FF2,W
099A0:  MOVWF  00
099A2:  BCF    FF2.6
099A4:  BCF    FF2.7
099A6:  MOVLB  F
099A8:  MOVLW  55
099AA:  MOVWF  FA7
099AC:  MOVLW  AA
099AE:  MOVWF  FA7
099B0:  BSF    FA6.1
099B2:  BTFSC  FA6.1
099B4:  BRA    99B2
099B6:  BCF    FA6.2
099B8:  MOVF   00,W
099BA:  IORWF  FF2,F
....................                delay_ms(20); 
099BC:  MOVLW  14
099BE:  MOVLB  B
099C0:  MOVWF  x22
099C2:  MOVLB  0
099C4:  CALL   11F6
....................                write_eeprom(18,0); 
099C8:  CLRF   FAA
099CA:  MOVLW  12
099CC:  MOVWF  FA9
099CE:  CLRF   FA8
099D0:  BCF    FA6.6
099D2:  BCF    FA6.7
099D4:  BSF    FA6.2
099D6:  MOVF   FF2,W
099D8:  MOVWF  00
099DA:  BCF    FF2.6
099DC:  BCF    FF2.7
099DE:  MOVLB  F
099E0:  MOVLW  55
099E2:  MOVWF  FA7
099E4:  MOVLW  AA
099E6:  MOVWF  FA7
099E8:  BSF    FA6.1
099EA:  BTFSC  FA6.1
099EC:  BRA    99EA
099EE:  BCF    FA6.2
099F0:  MOVF   00,W
099F2:  IORWF  FF2,F
....................                delay_ms(20); 
099F4:  MOVLW  14
099F6:  MOVLB  B
099F8:  MOVWF  x22
099FA:  MOVLB  0
099FC:  CALL   11F6
....................                write_eeprom(19,0); 
09A00:  CLRF   FAA
09A02:  MOVLW  13
09A04:  MOVWF  FA9
09A06:  CLRF   FA8
09A08:  BCF    FA6.6
09A0A:  BCF    FA6.7
09A0C:  BSF    FA6.2
09A0E:  MOVF   FF2,W
09A10:  MOVWF  00
09A12:  BCF    FF2.6
09A14:  BCF    FF2.7
09A16:  MOVLB  F
09A18:  MOVLW  55
09A1A:  MOVWF  FA7
09A1C:  MOVLW  AA
09A1E:  MOVWF  FA7
09A20:  BSF    FA6.1
09A22:  BTFSC  FA6.1
09A24:  BRA    9A22
09A26:  BCF    FA6.2
09A28:  MOVF   00,W
09A2A:  IORWF  FF2,F
....................                delay_ms(20); 
09A2C:  MOVLW  14
09A2E:  MOVLB  B
09A30:  MOVWF  x22
09A32:  MOVLB  0
09A34:  CALL   11F6
....................                Ttrabajo[3]=0;Ttrabajo[2]=0;Ttrabajo[1]=0;Ttrabajo[0]=0; 
09A38:  CLRF   xD0
09A3A:  CLRF   xCF
09A3C:  CLRF   xCE
09A3E:  CLRF   xCD
....................                LuzBlanca_off; 
09A40:  BSF    F8C.0
09A42:  BCF    F95.0
....................                RX_Buffer[4]=0x00;   
09A44:  CLRF   35
....................                RX_Buffer2[4]=0x00; 
09A46:  CLRF   40
....................                printf("page Ajustes"); 
09A48:  MOVLW  2C
09A4A:  MOVWF  FF6
09A4C:  MOVLW  0F
09A4E:  MOVWF  FF7
09A50:  MOVLW  00
09A52:  MOVWF  FF8
09A54:  CALL   1304
....................                SendDataDisplay(); 
09A58:  CALL   1336
09A5C:  MOVLB  B
....................             } 
....................          } 
....................           
....................          if(RX_Buffer[4]==0x21 || LEFT){//Oprimio salir 
09A5E:  MOVF   35,W
09A60:  SUBLW  21
09A62:  BZ    9A6A
09A64:  BSF    F93.7
09A66:  BTFSC  F81.7
09A68:  BRA    9A9A
....................             delay_ms(50); 
09A6A:  MOVLW  32
09A6C:  MOVWF  x22
09A6E:  MOVLB  0
09A70:  CALL   11F6
....................             if(RX_Buffer[4]==0x21 || LEFT){ 
09A74:  MOVF   35,W
09A76:  SUBLW  21
09A78:  BZ    9A80
09A7A:  BSF    F93.7
09A7C:  BTFSC  F81.7
09A7E:  BRA    9A98
....................                printf("page Ajustes"); 
09A80:  MOVLW  3A
09A82:  MOVWF  FF6
09A84:  MOVLW  0F
09A86:  MOVWF  FF7
09A88:  MOVLW  00
09A8A:  MOVWF  FF8
09A8C:  CALL   1304
....................                SendDataDisplay(); 
09A90:  CALL   1336
....................                LuzBlanca_off; 
09A94:  BSF    F8C.0
09A96:  BCF    F95.0
09A98:  MOVLB  B
....................                // Falta apagar Todo 
....................             } 
....................          } 
....................      } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------     
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==15){//Menu de Clave Correcta 
09A9A:  MOVLB  0
09A9C:  MOVF   x81,W
09A9E:  SUBLW  0F
09AA0:  BNZ   9AD4
....................       if(!entro){ 
09AA2:  BTFSC  x7E.5
09AA4:  BRA    9AC0
....................          delay_ms(2000); 
09AA6:  MOVLW  08
09AA8:  MOVLB  B
09AAA:  MOVWF  x00
09AAC:  MOVLW  FA
09AAE:  MOVWF  x22
09AB0:  MOVLB  0
09AB2:  CALL   11F6
09AB6:  MOVLB  B
09AB8:  DECFSZ x00,F
09ABA:  BRA    9AAC
....................          entro=ON; 
09ABC:  MOVLB  0
09ABE:  BSF    x7E.5
....................       } 
....................       printf("page Purga"); 
09AC0:  MOVLW  48
09AC2:  MOVWF  FF6
09AC4:  MOVLW  0F
09AC6:  MOVWF  FF7
09AC8:  MOVLW  00
09ACA:  MOVWF  FF8
09ACC:  CALL   1304
....................       SendDataDisplay(); 
09AD0:  CALL   1336
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................     if(Menu==16){//Menu de Clave InCorrecta 
09AD4:  MOVF   x81,W
09AD6:  SUBLW  10
09AD8:  BNZ   9B0C
....................       if(!entro){ 
09ADA:  BTFSC  x7E.5
09ADC:  BRA    9AF8
....................          delay_ms(2000); 
09ADE:  MOVLW  08
09AE0:  MOVLB  B
09AE2:  MOVWF  x00
09AE4:  MOVLW  FA
09AE6:  MOVWF  x22
09AE8:  MOVLB  0
09AEA:  CALL   11F6
09AEE:  MOVLB  B
09AF0:  DECFSZ x00,F
09AF2:  BRA    9AE4
....................          entro=ON; 
09AF4:  MOVLB  0
09AF6:  BSF    x7E.5
....................       } 
....................       printf("page Clave"); 
09AF8:  MOVLW  54
09AFA:  MOVWF  FF6
09AFC:  MOVLW  0F
09AFE:  MOVWF  FF7
09B00:  MOVLW  00
09B02:  MOVWF  FF8
09B04:  CALL   1304
....................       SendDataDisplay(); 
09B08:  CALL   1336
....................    } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------       
....................  
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................       if(Menu==100){ //Menu de Configuracin de Parametros de Control 
09B0C:  MOVF   x81,W
09B0E:  SUBLW  64
09B10:  BTFSS  FD8.2
09B12:  GOTO   B404
....................       
....................       if(Opcion2>13) 
09B16:  MOVF   xBA,W
09B18:  SUBLW  0D
09B1A:  BC    9B20
....................          Opcion2=1; 
09B1C:  MOVLW  01
09B1E:  MOVWF  xBA
....................       if(Opcion2<1) 
09B20:  MOVF   xBA,F
09B22:  BNZ   9B28
....................          Opcion2=13; 
09B24:  MOVLW  0D
09B26:  MOVWF  xBA
....................        
....................       if(Opcion2==1){ 
09B28:  DECFSZ xBA,W
09B2A:  BRA    9C36
....................          printf("Config.t2c.txt=\"Velocidad\""); 
09B2C:  MOVLW  60
09B2E:  MOVWF  FF6
09B30:  MOVLW  0F
09B32:  MOVWF  FF7
09B34:  MOVLW  00
09B36:  MOVWF  FF8
09B38:  CALL   1304
....................          SendDataDisplay();       
09B3C:  CALL   1336
....................          printf("t3c.txt=\"%u\"",Vel1); 
09B40:  MOVLW  7C
09B42:  MOVWF  FF6
09B44:  MOVLW  0F
09B46:  MOVWF  FF7
09B48:  MOVLW  00
09B4A:  MOVWF  FF8
09B4C:  MOVLW  09
09B4E:  MOVLB  B
09B50:  MOVWF  x02
09B52:  MOVLB  0
09B54:  CALL   5198
09B58:  MOVFF  93,B01
09B5C:  MOVLW  1B
09B5E:  MOVLB  B
09B60:  MOVWF  x02
09B62:  MOVLB  0
09B64:  CALL   51F6
09B68:  MOVLW  22
09B6A:  BTFSS  F9E.4
09B6C:  BRA    9B6A
09B6E:  MOVWF  FAD
....................          SendDataDisplay(); 
09B70:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
09B74:  MOVF   35,W
09B76:  SUBLW  0A
09B78:  BNZ   9BC8
....................                Vel1+=1.0; 
09B7A:  MOVLB  B
09B7C:  CLRF   x20
09B7E:  MOVFF  93,B1F
09B82:  MOVLB  0
09B84:  CALL   136C
09B88:  BCF    FD8.1
09B8A:  MOVFF  03,B26
09B8E:  MOVFF  02,B25
09B92:  MOVFF  01,B24
09B96:  MOVFF  00,B23
09B9A:  MOVLB  B
09B9C:  CLRF   x2A
09B9E:  CLRF   x29
09BA0:  CLRF   x28
09BA2:  MOVLW  7F
09BA4:  MOVWF  x27
09BA6:  MOVLB  0
09BA8:  CALL   1500
09BAC:  MOVFF  03,B03
09BB0:  MOVFF  02,B02
09BB4:  MOVFF  01,B01
09BB8:  MOVFF  00,B00
09BBC:  CALL   513E
09BC0:  MOVFF  01,93
....................                RX_Buffer[4]=0x00;   
09BC4:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
09BC6:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
09BC8:  MOVF   35,W
09BCA:  SUBLW  0B
09BCC:  BNZ   9C1C
....................                Vel1-=1.0; 
09BCE:  MOVLB  B
09BD0:  CLRF   x20
09BD2:  MOVFF  93,B1F
09BD6:  MOVLB  0
09BD8:  CALL   136C
09BDC:  BSF    FD8.1
09BDE:  MOVFF  03,B26
09BE2:  MOVFF  02,B25
09BE6:  MOVFF  01,B24
09BEA:  MOVFF  00,B23
09BEE:  MOVLB  B
09BF0:  CLRF   x2A
09BF2:  CLRF   x29
09BF4:  CLRF   x28
09BF6:  MOVLW  7F
09BF8:  MOVWF  x27
09BFA:  MOVLB  0
09BFC:  CALL   1500
09C00:  MOVFF  03,B03
09C04:  MOVFF  02,B02
09C08:  MOVFF  01,B01
09C0C:  MOVFF  00,B00
09C10:  CALL   513E
09C14:  MOVFF  01,93
....................                RX_Buffer[4]=0x00; 
09C18:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
09C1A:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................          VelMotor=Vel1; 
09C1C:  MOVFF  93,2D3
....................          if(Vel1>6) 
09C20:  MOVF   x93,W
09C22:  SUBLW  06
09C24:  BC    9C2A
....................             Vel1=1; 
09C26:  MOVLW  01
09C28:  MOVWF  x93
....................          if(Vel1<1) 
09C2A:  MOVF   x93,F
09C2C:  BNZ   9C32
....................             Vel1=6; 
09C2E:  MOVLW  06
09C30:  MOVWF  x93
....................       }else if(Opcion2==2){ 
09C32:  GOTO   AC78
09C36:  MOVF   xBA,W
09C38:  SUBLW  02
09C3A:  BTFSS  FD8.2
09C3C:  BRA    9F4C
....................          VelMotor=0; 
09C3E:  MOVLB  2
09C40:  CLRF   xD3
....................          VelMotor2=0; 
09C42:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero InFlow\""); 
09C44:  MOVLW  8A
09C46:  MOVWF  FF6
09C48:  MOVLW  0F
09C4A:  MOVWF  FF7
09C4C:  MOVLW  00
09C4E:  MOVWF  FF8
09C50:  MOVLB  0
09C52:  CALL   1304
....................          SendDataDisplay();       
09C56:  CALL   1336
....................          printf("t3c.txt=\"%2.0f\"",Flujo[1].zero_actual); 
09C5A:  MOVLW  A8
09C5C:  MOVWF  FF6
09C5E:  MOVLW  0F
09C60:  MOVWF  FF7
09C62:  MOVLW  00
09C64:  MOVWF  FF8
09C66:  MOVLW  09
09C68:  MOVLB  B
09C6A:  MOVWF  x02
09C6C:  MOVLB  0
09C6E:  CALL   5198
09C72:  MOVLW  01
09C74:  MOVWF  FE9
09C76:  MOVFF  43F,B03
09C7A:  MOVFF  43E,B02
09C7E:  MOVFF  43D,B01
09C82:  MOVFF  43C,B00
09C86:  MOVLB  B
09C88:  CLRF   x04
09C8A:  MOVLB  0
09C8C:  CALL   54C2
09C90:  MOVLW  22
09C92:  BTFSS  F9E.4
09C94:  BRA    9C92
09C96:  MOVWF  FAD
....................          SendDataDisplay(); 
09C98:  CALL   1336
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
09C9C:  MOVF   35,W
09C9E:  SUBLW  0A
09CA0:  BTFSS  FD8.2
09CA2:  BRA    9F3E
....................             Flujo[1].zero_actual=sensores(1); 
09CA4:  MOVLW  01
09CA6:  MOVLB  B
09CA8:  MOVWF  x1F
09CAA:  MOVLB  0
09CAC:  CALL   38CA
09CB0:  MOVFF  02,B20
09CB4:  MOVFF  01,B1F
09CB8:  CALL   136C
09CBC:  MOVFF  03,43F
09CC0:  MOVFF  02,43E
09CC4:  MOVFF  01,43D
09CC8:  MOVFF  00,43C
....................             Flujo[1].adc=sensores(1); 
09CCC:  MOVLW  01
09CCE:  MOVLB  B
09CD0:  MOVWF  x1F
09CD2:  MOVLB  0
09CD4:  CALL   38CA
09CD8:  MOVFF  02,445
09CDC:  MOVFF  01,444
....................             Flujo[1].Diferencia=zero_fabrica-Flujo[1].adc; 
09CE0:  MOVFF  445,B20
09CE4:  MOVFF  444,B1F
09CE8:  CALL   136C
09CEC:  BSF    FD8.1
09CEE:  MOVFF  2BC,B26
09CF2:  MOVFF  2BB,B25
09CF6:  MOVFF  2BA,B24
09CFA:  MOVFF  2B9,B23
09CFE:  MOVFF  03,B2A
09D02:  MOVFF  02,B29
09D06:  MOVFF  01,B28
09D0A:  MOVFF  00,B27
09D0E:  CALL   1500
09D12:  MOVFF  03,443
09D16:  MOVFF  02,442
09D1A:  MOVFF  01,441
09D1E:  MOVFF  00,440
....................                 
....................             if(Flujo[1].Diferencia>=0){ 
09D22:  MOVLB  B
09D24:  CLRF   x22
09D26:  CLRF   x21
09D28:  CLRF   x20
09D2A:  CLRF   x1F
09D2C:  MOVFF  443,B26
09D30:  MOVFF  442,B25
09D34:  MOVFF  441,B24
09D38:  MOVFF  440,B23
09D3C:  MOVLB  0
09D3E:  CALL   241C
09D42:  BC    9D46
09D44:  BNZ   9D86
....................                Flujo[1].negativo=10;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
09D46:  MOVLW  0A
09D48:  MOVLB  4
09D4A:  MOVWF  x46
09D4C:  CLRF   FAA
09D4E:  MOVLW  32
09D50:  MOVWF  FA9
09D52:  MOVFF  446,FA8
09D56:  BCF    FA6.6
09D58:  BCF    FA6.7
09D5A:  BSF    FA6.2
09D5C:  MOVF   FF2,W
09D5E:  MOVWF  00
09D60:  BCF    FF2.6
09D62:  BCF    FF2.7
09D64:  MOVLB  F
09D66:  MOVLW  55
09D68:  MOVWF  FA7
09D6A:  MOVLW  AA
09D6C:  MOVWF  FA7
09D6E:  BSF    FA6.1
09D70:  BTFSC  FA6.1
09D72:  BRA    9D70
09D74:  BCF    FA6.2
09D76:  MOVF   00,W
09D78:  IORWF  FF2,F
09D7A:  MOVLW  14
09D7C:  MOVLB  B
09D7E:  MOVWF  x22
09D80:  MOVLB  0
09D82:  CALL   11F6
....................             } 
....................             if(Flujo[1].Diferencia<0){ 
09D86:  MOVFF  443,B22
09D8A:  MOVFF  442,B21
09D8E:  MOVFF  441,B20
09D92:  MOVFF  440,B1F
09D96:  MOVLB  B
09D98:  CLRF   x26
09D9A:  CLRF   x25
09D9C:  CLRF   x24
09D9E:  CLRF   x23
09DA0:  MOVLB  0
09DA2:  CALL   241C
09DA6:  BNC   9DE8
....................                Flujo[1].negativo=20;write_eeprom(50,Flujo[1].negativo);delay_ms(20); 
09DA8:  MOVLW  14
09DAA:  MOVLB  4
09DAC:  MOVWF  x46
09DAE:  CLRF   FAA
09DB0:  MOVLW  32
09DB2:  MOVWF  FA9
09DB4:  MOVFF  446,FA8
09DB8:  BCF    FA6.6
09DBA:  BCF    FA6.7
09DBC:  BSF    FA6.2
09DBE:  MOVF   FF2,W
09DC0:  MOVWF  00
09DC2:  BCF    FF2.6
09DC4:  BCF    FF2.7
09DC6:  MOVLB  F
09DC8:  MOVLW  55
09DCA:  MOVWF  FA7
09DCC:  MOVLW  AA
09DCE:  MOVWF  FA7
09DD0:  BSF    FA6.1
09DD2:  BTFSC  FA6.1
09DD4:  BRA    9DD2
09DD6:  BCF    FA6.2
09DD8:  MOVF   00,W
09DDA:  IORWF  FF2,F
09DDC:  MOVLW  14
09DDE:  MOVLB  B
09DE0:  MOVWF  x22
09DE2:  MOVLB  0
09DE4:  CALL   11F6
....................             } 
....................             Flujo[1].Diferencia=abs(Flujo[1].Diferencia); 
09DE8:  MOVFF  440,00
09DEC:  MOVFF  441,01
09DF0:  MOVFF  442,02
09DF4:  MOVFF  443,03
09DF8:  BCF    01.7
09DFA:  MOVFF  443,443
09DFE:  MOVFF  442,442
09E02:  MOVFF  01,441
09E06:  MOVFF  440,440
....................             Temporal1=(int16)Flujo[1].Diferencia; 
09E0A:  MOVFF  443,B03
09E0E:  MOVFF  442,B02
09E12:  MOVFF  441,B01
09E16:  MOVFF  440,B00
09E1A:  CALL   513E
09E1E:  MOVFF  02,BC
09E22:  MOVFF  01,BB
....................             write_eeprom(42,make8(Temporal1,0)); 
09E26:  MOVFF  BB,B00
09E2A:  CLRF   FAA
09E2C:  MOVLW  2A
09E2E:  MOVWF  FA9
09E30:  MOVFF  B00,FA8
09E34:  BCF    FA6.6
09E36:  BCF    FA6.7
09E38:  BSF    FA6.2
09E3A:  MOVF   FF2,W
09E3C:  MOVWF  00
09E3E:  BCF    FF2.6
09E40:  BCF    FF2.7
09E42:  MOVLB  F
09E44:  MOVLW  55
09E46:  MOVWF  FA7
09E48:  MOVLW  AA
09E4A:  MOVWF  FA7
09E4C:  BSF    FA6.1
09E4E:  BTFSC  FA6.1
09E50:  BRA    9E4E
09E52:  BCF    FA6.2
09E54:  MOVF   00,W
09E56:  IORWF  FF2,F
....................             delay_ms(20); 
09E58:  MOVLW  14
09E5A:  MOVLB  B
09E5C:  MOVWF  x22
09E5E:  MOVLB  0
09E60:  CALL   11F6
....................             write_eeprom(43,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
09E64:  MOVFF  BC,B00
09E68:  CLRF   FAA
09E6A:  MOVLW  2B
09E6C:  MOVWF  FA9
09E6E:  MOVFF  B00,FA8
09E72:  BCF    FA6.6
09E74:  BCF    FA6.7
09E76:  BSF    FA6.2
09E78:  MOVF   FF2,W
09E7A:  MOVWF  00
09E7C:  BCF    FF2.6
09E7E:  BCF    FF2.7
09E80:  MOVLB  F
09E82:  MOVLW  55
09E84:  MOVWF  FA7
09E86:  MOVLW  AA
09E88:  MOVWF  FA7
09E8A:  BSF    FA6.1
09E8C:  BTFSC  FA6.1
09E8E:  BRA    9E8C
09E90:  BCF    FA6.2
09E92:  MOVF   00,W
09E94:  IORWF  FF2,F
....................             delay_ms(20); 
09E96:  MOVLW  14
09E98:  MOVLB  B
09E9A:  MOVWF  x22
09E9C:  MOVLB  0
09E9E:  CALL   11F6
....................     
....................             Temporal1=(int16)Flujo[1].zero_actual; 
09EA2:  MOVFF  43F,B03
09EA6:  MOVFF  43E,B02
09EAA:  MOVFF  43D,B01
09EAE:  MOVFF  43C,B00
09EB2:  CALL   513E
09EB6:  MOVFF  02,BC
09EBA:  MOVFF  01,BB
....................             write_eeprom(33,make8(Temporal1,0)); 
09EBE:  MOVFF  BB,B00
09EC2:  CLRF   FAA
09EC4:  MOVLW  21
09EC6:  MOVWF  FA9
09EC8:  MOVFF  B00,FA8
09ECC:  BCF    FA6.6
09ECE:  BCF    FA6.7
09ED0:  BSF    FA6.2
09ED2:  MOVF   FF2,W
09ED4:  MOVWF  00
09ED6:  BCF    FF2.6
09ED8:  BCF    FF2.7
09EDA:  MOVLB  F
09EDC:  MOVLW  55
09EDE:  MOVWF  FA7
09EE0:  MOVLW  AA
09EE2:  MOVWF  FA7
09EE4:  BSF    FA6.1
09EE6:  BTFSC  FA6.1
09EE8:  BRA    9EE6
09EEA:  BCF    FA6.2
09EEC:  MOVF   00,W
09EEE:  IORWF  FF2,F
....................             delay_ms(20); 
09EF0:  MOVLW  14
09EF2:  MOVLB  B
09EF4:  MOVWF  x22
09EF6:  MOVLB  0
09EF8:  CALL   11F6
....................             write_eeprom(34,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
09EFC:  MOVFF  BC,B00
09F00:  CLRF   FAA
09F02:  MOVLW  22
09F04:  MOVWF  FA9
09F06:  MOVFF  B00,FA8
09F0A:  BCF    FA6.6
09F0C:  BCF    FA6.7
09F0E:  BSF    FA6.2
09F10:  MOVF   FF2,W
09F12:  MOVWF  00
09F14:  BCF    FF2.6
09F16:  BCF    FF2.7
09F18:  MOVLB  F
09F1A:  MOVLW  55
09F1C:  MOVWF  FA7
09F1E:  MOVLW  AA
09F20:  MOVWF  FA7
09F22:  BSF    FA6.1
09F24:  BTFSC  FA6.1
09F26:  BRA    9F24
09F28:  BCF    FA6.2
09F2A:  MOVF   00,W
09F2C:  IORWF  FF2,F
....................             delay_ms(20); 
09F2E:  MOVLW  14
09F30:  MOVLB  B
09F32:  MOVWF  x22
09F34:  MOVLB  0
09F36:  CALL   11F6
....................             RX_Buffer[4]=0x00;   
09F3A:  CLRF   35
....................             RX_Buffer2[4]=0x00;                            
09F3C:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
09F3E:  MOVF   35,W
09F40:  SUBLW  0B
09F42:  BNZ   9F48
....................                RX_Buffer[4]=0x00; 
09F44:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
09F46:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==3){ 
09F48:  GOTO   AC78
09F4C:  MOVF   xBA,W
09F4E:  SUBLW  03
09F50:  BTFSS  FD8.2
09F52:  BRA    A262
....................          VelMotor=0; 
09F54:  MOVLB  2
09F56:  CLRF   xD3
....................          VelMotor2=0; 
09F58:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero Flujo2\""); 
09F5A:  MOVLW  B8
09F5C:  MOVWF  FF6
09F5E:  MOVLW  0F
09F60:  MOVWF  FF7
09F62:  MOVLW  00
09F64:  MOVWF  FF8
09F66:  MOVLB  0
09F68:  CALL   1304
....................          SendDataDisplay();       
09F6C:  CALL   1336
....................          printf("t3c.txt=\"%2.0f\"",Flujo[2].zero_actual); 
09F70:  MOVLW  D6
09F72:  MOVWF  FF6
09F74:  MOVLW  0F
09F76:  MOVWF  FF7
09F78:  MOVLW  00
09F7A:  MOVWF  FF8
09F7C:  MOVLW  09
09F7E:  MOVLB  B
09F80:  MOVWF  x02
09F82:  MOVLB  0
09F84:  CALL   5198
09F88:  MOVLW  01
09F8A:  MOVWF  FE9
09F8C:  MOVFF  598,B03
09F90:  MOVFF  597,B02
09F94:  MOVFF  596,B01
09F98:  MOVFF  595,B00
09F9C:  MOVLB  B
09F9E:  CLRF   x04
09FA0:  MOVLB  0
09FA2:  CALL   54C2
09FA6:  MOVLW  22
09FA8:  BTFSS  F9E.4
09FAA:  BRA    9FA8
09FAC:  MOVWF  FAD
....................          SendDataDisplay(); 
09FAE:  CALL   1336
....................           
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
09FB2:  MOVF   35,W
09FB4:  SUBLW  0A
09FB6:  BTFSS  FD8.2
09FB8:  BRA    A254
....................             Flujo[2].zero_actual=sensores(2); 
09FBA:  MOVLW  02
09FBC:  MOVLB  B
09FBE:  MOVWF  x1F
09FC0:  MOVLB  0
09FC2:  CALL   38CA
09FC6:  MOVFF  02,B20
09FCA:  MOVFF  01,B1F
09FCE:  CALL   136C
09FD2:  MOVFF  03,598
09FD6:  MOVFF  02,597
09FDA:  MOVFF  01,596
09FDE:  MOVFF  00,595
....................             Flujo[2].adc=sensores(2); 
09FE2:  MOVLW  02
09FE4:  MOVLB  B
09FE6:  MOVWF  x1F
09FE8:  MOVLB  0
09FEA:  CALL   38CA
09FEE:  MOVFF  02,59E
09FF2:  MOVFF  01,59D
....................             Flujo[2].Diferencia=zero_fabrica-Flujo[2].adc; 
09FF6:  MOVFF  59E,B20
09FFA:  MOVFF  59D,B1F
09FFE:  CALL   136C
0A002:  BSF    FD8.1
0A004:  MOVFF  2BC,B26
0A008:  MOVFF  2BB,B25
0A00C:  MOVFF  2BA,B24
0A010:  MOVFF  2B9,B23
0A014:  MOVFF  03,B2A
0A018:  MOVFF  02,B29
0A01C:  MOVFF  01,B28
0A020:  MOVFF  00,B27
0A024:  CALL   1500
0A028:  MOVFF  03,59C
0A02C:  MOVFF  02,59B
0A030:  MOVFF  01,59A
0A034:  MOVFF  00,599
....................                 
....................             if(Flujo[2].Diferencia>=0){ 
0A038:  MOVLB  B
0A03A:  CLRF   x22
0A03C:  CLRF   x21
0A03E:  CLRF   x20
0A040:  CLRF   x1F
0A042:  MOVFF  59C,B26
0A046:  MOVFF  59B,B25
0A04A:  MOVFF  59A,B24
0A04E:  MOVFF  599,B23
0A052:  MOVLB  0
0A054:  CALL   241C
0A058:  BC    A05C
0A05A:  BNZ   A09C
....................                Flujo[2].negativo=10;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
0A05C:  MOVLW  0A
0A05E:  MOVLB  5
0A060:  MOVWF  x9F
0A062:  CLRF   FAA
0A064:  MOVLW  33
0A066:  MOVWF  FA9
0A068:  MOVFF  59F,FA8
0A06C:  BCF    FA6.6
0A06E:  BCF    FA6.7
0A070:  BSF    FA6.2
0A072:  MOVF   FF2,W
0A074:  MOVWF  00
0A076:  BCF    FF2.6
0A078:  BCF    FF2.7
0A07A:  MOVLB  F
0A07C:  MOVLW  55
0A07E:  MOVWF  FA7
0A080:  MOVLW  AA
0A082:  MOVWF  FA7
0A084:  BSF    FA6.1
0A086:  BTFSC  FA6.1
0A088:  BRA    A086
0A08A:  BCF    FA6.2
0A08C:  MOVF   00,W
0A08E:  IORWF  FF2,F
0A090:  MOVLW  14
0A092:  MOVLB  B
0A094:  MOVWF  x22
0A096:  MOVLB  0
0A098:  CALL   11F6
....................             } 
....................             if(Flujo[2].Diferencia<0){ 
0A09C:  MOVFF  59C,B22
0A0A0:  MOVFF  59B,B21
0A0A4:  MOVFF  59A,B20
0A0A8:  MOVFF  599,B1F
0A0AC:  MOVLB  B
0A0AE:  CLRF   x26
0A0B0:  CLRF   x25
0A0B2:  CLRF   x24
0A0B4:  CLRF   x23
0A0B6:  MOVLB  0
0A0B8:  CALL   241C
0A0BC:  BNC   A0FE
....................                Flujo[2].negativo=20;write_eeprom(51,Flujo[2].negativo);delay_ms(20); 
0A0BE:  MOVLW  14
0A0C0:  MOVLB  5
0A0C2:  MOVWF  x9F
0A0C4:  CLRF   FAA
0A0C6:  MOVLW  33
0A0C8:  MOVWF  FA9
0A0CA:  MOVFF  59F,FA8
0A0CE:  BCF    FA6.6
0A0D0:  BCF    FA6.7
0A0D2:  BSF    FA6.2
0A0D4:  MOVF   FF2,W
0A0D6:  MOVWF  00
0A0D8:  BCF    FF2.6
0A0DA:  BCF    FF2.7
0A0DC:  MOVLB  F
0A0DE:  MOVLW  55
0A0E0:  MOVWF  FA7
0A0E2:  MOVLW  AA
0A0E4:  MOVWF  FA7
0A0E6:  BSF    FA6.1
0A0E8:  BTFSC  FA6.1
0A0EA:  BRA    A0E8
0A0EC:  BCF    FA6.2
0A0EE:  MOVF   00,W
0A0F0:  IORWF  FF2,F
0A0F2:  MOVLW  14
0A0F4:  MOVLB  B
0A0F6:  MOVWF  x22
0A0F8:  MOVLB  0
0A0FA:  CALL   11F6
....................             } 
....................             Flujo[2].Diferencia=abs(Flujo[2].Diferencia); 
0A0FE:  MOVFF  599,00
0A102:  MOVFF  59A,01
0A106:  MOVFF  59B,02
0A10A:  MOVFF  59C,03
0A10E:  BCF    01.7
0A110:  MOVFF  59C,59C
0A114:  MOVFF  59B,59B
0A118:  MOVFF  01,59A
0A11C:  MOVFF  599,599
....................             Temporal1=(int16)Flujo[2].Diferencia; 
0A120:  MOVFF  59C,B03
0A124:  MOVFF  59B,B02
0A128:  MOVFF  59A,B01
0A12C:  MOVFF  599,B00
0A130:  CALL   513E
0A134:  MOVFF  02,BC
0A138:  MOVFF  01,BB
....................             write_eeprom(44,make8(Temporal1,0)); 
0A13C:  MOVFF  BB,B00
0A140:  CLRF   FAA
0A142:  MOVLW  2C
0A144:  MOVWF  FA9
0A146:  MOVFF  B00,FA8
0A14A:  BCF    FA6.6
0A14C:  BCF    FA6.7
0A14E:  BSF    FA6.2
0A150:  MOVF   FF2,W
0A152:  MOVWF  00
0A154:  BCF    FF2.6
0A156:  BCF    FF2.7
0A158:  MOVLB  F
0A15A:  MOVLW  55
0A15C:  MOVWF  FA7
0A15E:  MOVLW  AA
0A160:  MOVWF  FA7
0A162:  BSF    FA6.1
0A164:  BTFSC  FA6.1
0A166:  BRA    A164
0A168:  BCF    FA6.2
0A16A:  MOVF   00,W
0A16C:  IORWF  FF2,F
....................             delay_ms(20); 
0A16E:  MOVLW  14
0A170:  MOVLB  B
0A172:  MOVWF  x22
0A174:  MOVLB  0
0A176:  CALL   11F6
....................             write_eeprom(45,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A17A:  MOVFF  BC,B00
0A17E:  CLRF   FAA
0A180:  MOVLW  2D
0A182:  MOVWF  FA9
0A184:  MOVFF  B00,FA8
0A188:  BCF    FA6.6
0A18A:  BCF    FA6.7
0A18C:  BSF    FA6.2
0A18E:  MOVF   FF2,W
0A190:  MOVWF  00
0A192:  BCF    FF2.6
0A194:  BCF    FF2.7
0A196:  MOVLB  F
0A198:  MOVLW  55
0A19A:  MOVWF  FA7
0A19C:  MOVLW  AA
0A19E:  MOVWF  FA7
0A1A0:  BSF    FA6.1
0A1A2:  BTFSC  FA6.1
0A1A4:  BRA    A1A2
0A1A6:  BCF    FA6.2
0A1A8:  MOVF   00,W
0A1AA:  IORWF  FF2,F
....................             delay_ms(20); 
0A1AC:  MOVLW  14
0A1AE:  MOVLB  B
0A1B0:  MOVWF  x22
0A1B2:  MOVLB  0
0A1B4:  CALL   11F6
....................     
....................             Temporal1=(int16)Flujo[2].zero_actual; 
0A1B8:  MOVFF  598,B03
0A1BC:  MOVFF  597,B02
0A1C0:  MOVFF  596,B01
0A1C4:  MOVFF  595,B00
0A1C8:  CALL   513E
0A1CC:  MOVFF  02,BC
0A1D0:  MOVFF  01,BB
....................             write_eeprom(35,make8(Temporal1,0)); 
0A1D4:  MOVFF  BB,B00
0A1D8:  CLRF   FAA
0A1DA:  MOVLW  23
0A1DC:  MOVWF  FA9
0A1DE:  MOVFF  B00,FA8
0A1E2:  BCF    FA6.6
0A1E4:  BCF    FA6.7
0A1E6:  BSF    FA6.2
0A1E8:  MOVF   FF2,W
0A1EA:  MOVWF  00
0A1EC:  BCF    FF2.6
0A1EE:  BCF    FF2.7
0A1F0:  MOVLB  F
0A1F2:  MOVLW  55
0A1F4:  MOVWF  FA7
0A1F6:  MOVLW  AA
0A1F8:  MOVWF  FA7
0A1FA:  BSF    FA6.1
0A1FC:  BTFSC  FA6.1
0A1FE:  BRA    A1FC
0A200:  BCF    FA6.2
0A202:  MOVF   00,W
0A204:  IORWF  FF2,F
....................             delay_ms(20); 
0A206:  MOVLW  14
0A208:  MOVLB  B
0A20A:  MOVWF  x22
0A20C:  MOVLB  0
0A20E:  CALL   11F6
....................             write_eeprom(36,make8(Temporal1,1));//Guardar valor de Setpoint en eeprom 
0A212:  MOVFF  BC,B00
0A216:  CLRF   FAA
0A218:  MOVLW  24
0A21A:  MOVWF  FA9
0A21C:  MOVFF  B00,FA8
0A220:  BCF    FA6.6
0A222:  BCF    FA6.7
0A224:  BSF    FA6.2
0A226:  MOVF   FF2,W
0A228:  MOVWF  00
0A22A:  BCF    FF2.6
0A22C:  BCF    FF2.7
0A22E:  MOVLB  F
0A230:  MOVLW  55
0A232:  MOVWF  FA7
0A234:  MOVLW  AA
0A236:  MOVWF  FA7
0A238:  BSF    FA6.1
0A23A:  BTFSC  FA6.1
0A23C:  BRA    A23A
0A23E:  BCF    FA6.2
0A240:  MOVF   00,W
0A242:  IORWF  FF2,F
....................             delay_ms(20); 
0A244:  MOVLW  14
0A246:  MOVLB  B
0A248:  MOVWF  x22
0A24A:  MOVLB  0
0A24C:  CALL   11F6
....................             RX_Buffer[4]=0x00;   
0A250:  CLRF   35
....................             RX_Buffer2[4]=0x00;                            
0A252:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A254:  MOVF   35,W
0A256:  SUBLW  0B
0A258:  BNZ   A25E
....................                RX_Buffer[4]=0x00; 
0A25A:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A25C:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==4){ 
0A25E:  GOTO   AC78
0A262:  MOVF   xBA,W
0A264:  SUBLW  04
0A266:  BTFSS  FD8.2
0A268:  BRA    A394
....................          printf("Config.t2c.txt=\"Ajuste InFlow\""); 
0A26A:  MOVLW  E6
0A26C:  MOVWF  FF6
0A26E:  MOVLW  0F
0A270:  MOVWF  FF7
0A272:  MOVLW  00
0A274:  MOVWF  FF8
0A276:  CALL   1304
....................          SendDataDisplay();       
0A27A:  CALL   1336
....................          printf("t3c.txt=\"%2.1f\"",Flujo[1].Ajuste); 
0A27E:  MOVLW  06
0A280:  MOVWF  FF6
0A282:  MOVLW  10
0A284:  MOVWF  FF7
0A286:  MOVLW  00
0A288:  MOVWF  FF8
0A28A:  MOVLW  09
0A28C:  MOVLB  B
0A28E:  MOVWF  x02
0A290:  MOVLB  0
0A292:  CALL   5198
0A296:  MOVLW  01
0A298:  MOVWF  FE9
0A29A:  MOVFF  454,B03
0A29E:  MOVFF  453,B02
0A2A2:  MOVFF  452,B01
0A2A6:  MOVFF  451,B00
0A2AA:  MOVLB  B
0A2AC:  MOVWF  x04
0A2AE:  MOVLB  0
0A2B0:  CALL   54C2
0A2B4:  MOVLW  22
0A2B6:  BTFSS  F9E.4
0A2B8:  BRA    A2B6
0A2BA:  MOVWF  FAD
....................          SendDataDisplay(); 
0A2BC:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A2C0:  MOVF   35,W
0A2C2:  SUBLW  0A
0A2C4:  BNZ   A32A
....................                if(Flujo[1].Ajuste<10) 
0A2C6:  MOVFF  454,B22
0A2CA:  MOVFF  453,B21
0A2CE:  MOVFF  452,B20
0A2D2:  MOVFF  451,B1F
0A2D6:  MOVLB  B
0A2D8:  CLRF   x26
0A2DA:  CLRF   x25
0A2DC:  MOVLW  20
0A2DE:  MOVWF  x24
0A2E0:  MOVLW  82
0A2E2:  MOVWF  x23
0A2E4:  MOVLB  0
0A2E6:  CALL   241C
0A2EA:  BNC   A326
....................                   Flujo[1].Ajuste+=0.1; 
0A2EC:  BCF    FD8.1
0A2EE:  MOVFF  454,B26
0A2F2:  MOVFF  453,B25
0A2F6:  MOVFF  452,B24
0A2FA:  MOVFF  451,B23
0A2FE:  MOVLW  CD
0A300:  MOVLB  B
0A302:  MOVWF  x2A
0A304:  MOVLW  CC
0A306:  MOVWF  x29
0A308:  MOVLW  4C
0A30A:  MOVWF  x28
0A30C:  MOVLW  7B
0A30E:  MOVWF  x27
0A310:  MOVLB  0
0A312:  CALL   1500
0A316:  MOVFF  03,454
0A31A:  MOVFF  02,453
0A31E:  MOVFF  01,452
0A322:  MOVFF  00,451
....................                RX_Buffer[4]=0x00;   
0A326:  CLRF   35
....................                RX_Buffer2[4]=0x00;                            
0A328:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A32A:  MOVF   35,W
0A32C:  SUBLW  0B
0A32E:  BNZ   A390
....................                if(Flujo[1].Ajuste>0) 
0A330:  MOVLB  B
0A332:  CLRF   x22
0A334:  CLRF   x21
0A336:  CLRF   x20
0A338:  CLRF   x1F
0A33A:  MOVFF  454,B26
0A33E:  MOVFF  453,B25
0A342:  MOVFF  452,B24
0A346:  MOVFF  451,B23
0A34A:  MOVLB  0
0A34C:  CALL   241C
0A350:  BNC   A38C
....................                   Flujo[1].Ajuste-=0.1; 
0A352:  BSF    FD8.1
0A354:  MOVFF  454,B26
0A358:  MOVFF  453,B25
0A35C:  MOVFF  452,B24
0A360:  MOVFF  451,B23
0A364:  MOVLW  CD
0A366:  MOVLB  B
0A368:  MOVWF  x2A
0A36A:  MOVLW  CC
0A36C:  MOVWF  x29
0A36E:  MOVLW  4C
0A370:  MOVWF  x28
0A372:  MOVLW  7B
0A374:  MOVWF  x27
0A376:  MOVLB  0
0A378:  CALL   1500
0A37C:  MOVFF  03,454
0A380:  MOVFF  02,453
0A384:  MOVFF  01,452
0A388:  MOVFF  00,451
....................                RX_Buffer[4]=0x00; 
0A38C:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A38E:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................       }else if(Opcion2==5){ 
0A390:  GOTO   AC78
0A394:  MOVF   xBA,W
0A396:  SUBLW  05
0A398:  BTFSS  FD8.2
0A39A:  BRA    A4C6
....................          printf("Config.t2c.txt=\"Ajuste Flujo2\""); 
0A39C:  MOVLW  16
0A39E:  MOVWF  FF6
0A3A0:  MOVLW  10
0A3A2:  MOVWF  FF7
0A3A4:  MOVLW  00
0A3A6:  MOVWF  FF8
0A3A8:  CALL   1304
....................          SendDataDisplay();       
0A3AC:  CALL   1336
....................          printf("t3c.txt=\"%2.1f\"",Flujo[2].Ajuste); 
0A3B0:  MOVLW  36
0A3B2:  MOVWF  FF6
0A3B4:  MOVLW  10
0A3B6:  MOVWF  FF7
0A3B8:  MOVLW  00
0A3BA:  MOVWF  FF8
0A3BC:  MOVLW  09
0A3BE:  MOVLB  B
0A3C0:  MOVWF  x02
0A3C2:  MOVLB  0
0A3C4:  CALL   5198
0A3C8:  MOVLW  01
0A3CA:  MOVWF  FE9
0A3CC:  MOVFF  5AD,B03
0A3D0:  MOVFF  5AC,B02
0A3D4:  MOVFF  5AB,B01
0A3D8:  MOVFF  5AA,B00
0A3DC:  MOVLB  B
0A3DE:  MOVWF  x04
0A3E0:  MOVLB  0
0A3E2:  CALL   54C2
0A3E6:  MOVLW  22
0A3E8:  BTFSS  F9E.4
0A3EA:  BRA    A3E8
0A3EC:  MOVWF  FAD
....................          SendDataDisplay(); 
0A3EE:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0A3F2:  MOVF   35,W
0A3F4:  SUBLW  0A
0A3F6:  BNZ   A45C
....................                if(Flujo[2].Ajuste<10) 
0A3F8:  MOVFF  5AD,B22
0A3FC:  MOVFF  5AC,B21
0A400:  MOVFF  5AB,B20
0A404:  MOVFF  5AA,B1F
0A408:  MOVLB  B
0A40A:  CLRF   x26
0A40C:  CLRF   x25
0A40E:  MOVLW  20
0A410:  MOVWF  x24
0A412:  MOVLW  82
0A414:  MOVWF  x23
0A416:  MOVLB  0
0A418:  CALL   241C
0A41C:  BNC   A458
....................                   Flujo[2].Ajuste+=0.1; 
0A41E:  BCF    FD8.1
0A420:  MOVFF  5AD,B26
0A424:  MOVFF  5AC,B25
0A428:  MOVFF  5AB,B24
0A42C:  MOVFF  5AA,B23
0A430:  MOVLW  CD
0A432:  MOVLB  B
0A434:  MOVWF  x2A
0A436:  MOVLW  CC
0A438:  MOVWF  x29
0A43A:  MOVLW  4C
0A43C:  MOVWF  x28
0A43E:  MOVLW  7B
0A440:  MOVWF  x27
0A442:  MOVLB  0
0A444:  CALL   1500
0A448:  MOVFF  03,5AD
0A44C:  MOVFF  02,5AC
0A450:  MOVFF  01,5AB
0A454:  MOVFF  00,5AA
....................                RX_Buffer[4]=0x00;   
0A458:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A45A:  CLRF   40
....................                //BorraBuffer(); 
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0A45C:  MOVF   35,W
0A45E:  SUBLW  0B
0A460:  BNZ   A4C2
....................                if(Flujo[2].Ajuste>0) 
0A462:  MOVLB  B
0A464:  CLRF   x22
0A466:  CLRF   x21
0A468:  CLRF   x20
0A46A:  CLRF   x1F
0A46C:  MOVFF  5AD,B26
0A470:  MOVFF  5AC,B25
0A474:  MOVFF  5AB,B24
0A478:  MOVFF  5AA,B23
0A47C:  MOVLB  0
0A47E:  CALL   241C
0A482:  BNC   A4BE
....................                   Flujo[2].Ajuste-=0.1; 
0A484:  BSF    FD8.1
0A486:  MOVFF  5AD,B26
0A48A:  MOVFF  5AC,B25
0A48E:  MOVFF  5AB,B24
0A492:  MOVFF  5AA,B23
0A496:  MOVLW  CD
0A498:  MOVLB  B
0A49A:  MOVWF  x2A
0A49C:  MOVLW  CC
0A49E:  MOVWF  x29
0A4A0:  MOVLW  4C
0A4A2:  MOVWF  x28
0A4A4:  MOVLW  7B
0A4A6:  MOVWF  x27
0A4A8:  MOVLB  0
0A4AA:  CALL   1500
0A4AE:  MOVFF  03,5AD
0A4B2:  MOVFF  02,5AC
0A4B6:  MOVFF  01,5AB
0A4BA:  MOVFF  00,5AA
....................                RX_Buffer[4]=0x00; 
0A4BE:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A4C0:  CLRF   40
....................                //BorraBuffer();             
....................          } 
....................       }else if(Opcion2==6){ 
0A4C2:  GOTO   AC78
0A4C6:  MOVF   xBA,W
0A4C8:  SUBLW  06
0A4CA:  BTFSS  FD8.2
0A4CC:  BRA    A61E
....................          VelMotor=0; 
0A4CE:  MOVLB  2
0A4D0:  CLRF   xD3
....................          VelMotor2=0; 
0A4D2:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero P1\""); 
0A4D4:  MOVLW  46
0A4D6:  MOVWF  FF6
0A4D8:  MOVLW  10
0A4DA:  MOVWF  FF7
0A4DC:  MOVLW  00
0A4DE:  MOVWF  FF8
0A4E0:  MOVLB  0
0A4E2:  CALL   1304
....................          SendDataDisplay();       
0A4E6:  CALL   1336
....................          printf("t3c.txt=\"%2.0f\"",Presion[4].G); 
0A4EA:  MOVLW  60
0A4EC:  MOVWF  FF6
0A4EE:  MOVLW  10
0A4F0:  MOVWF  FF7
0A4F2:  MOVLW  00
0A4F4:  MOVWF  FF8
0A4F6:  MOVLW  09
0A4F8:  MOVLB  B
0A4FA:  MOVWF  x02
0A4FC:  MOVLB  0
0A4FE:  CALL   5198
0A502:  MOVLW  01
0A504:  MOVWF  FE9
0A506:  MOVFF  AB9,B03
0A50A:  MOVFF  AB8,B02
0A50E:  MOVFF  AB7,B01
0A512:  MOVFF  AB6,B00
0A516:  MOVLB  B
0A518:  CLRF   x04
0A51A:  MOVLB  0
0A51C:  CALL   54C2
0A520:  MOVLW  22
0A522:  BTFSS  F9E.4
0A524:  BRA    A522
0A526:  MOVWF  FAD
....................          //printf("t3c.txt=\"%2.0f\"",Gdn); 
....................          SendDataDisplay(); 
0A528:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A52C:  MOVF   35,W
0A52E:  SUBLW  0A
0A530:  BNZ   A616
....................             Presion[4].G=sensores(4);//Presion[4].adc; 
0A532:  MOVLW  04
0A534:  MOVLB  B
0A536:  MOVWF  x1F
0A538:  MOVLB  0
0A53A:  CALL   38CA
0A53E:  MOVFF  02,B20
0A542:  MOVFF  01,B1F
0A546:  CALL   136C
0A54A:  MOVFF  03,AB9
0A54E:  MOVFF  02,AB8
0A552:  MOVFF  01,AB7
0A556:  MOVFF  00,AB6
....................             G16=(int16)Presion[4].G; 
0A55A:  MOVFF  AB9,B03
0A55E:  MOVFF  AB8,B02
0A562:  MOVFF  AB7,B01
0A566:  MOVFF  AB6,B00
0A56A:  CALL   513E
0A56E:  MOVFF  02,C6
0A572:  MOVFF  01,C5
....................             //Gdn=sensores(4);//Presion[4].adc; 
....................             //G16=(int16)Gdn; 
....................             G_l=G16; G_h=(G16>>8); 
0A576:  MOVFF  C5,84
0A57A:  MOVFF  C6,85
....................                 
....................             write_eeprom(46,G_l); 
0A57E:  CLRF   FAA
0A580:  MOVLW  2E
0A582:  MOVWF  FA9
0A584:  MOVFF  84,FA8
0A588:  BCF    FA6.6
0A58A:  BCF    FA6.7
0A58C:  BSF    FA6.2
0A58E:  MOVF   FF2,W
0A590:  MOVWF  00
0A592:  BCF    FF2.6
0A594:  BCF    FF2.7
0A596:  MOVLB  F
0A598:  MOVLW  55
0A59A:  MOVWF  FA7
0A59C:  MOVLW  AA
0A59E:  MOVWF  FA7
0A5A0:  BSF    FA6.1
0A5A2:  BTFSC  FA6.1
0A5A4:  BRA    A5A2
0A5A6:  BCF    FA6.2
0A5A8:  MOVF   00,W
0A5AA:  IORWF  FF2,F
....................             delay_ms(20); 
0A5AC:  MOVLW  14
0A5AE:  MOVLB  B
0A5B0:  MOVWF  x22
0A5B2:  MOVLB  0
0A5B4:  CALL   11F6
....................             write_eeprom(47,G_h);//Guardar valor de Setpoint en eeprom 
0A5B8:  CLRF   FAA
0A5BA:  MOVLW  2F
0A5BC:  MOVWF  FA9
0A5BE:  MOVFF  85,FA8
0A5C2:  BCF    FA6.6
0A5C4:  BCF    FA6.7
0A5C6:  BSF    FA6.2
0A5C8:  MOVF   FF2,W
0A5CA:  MOVWF  00
0A5CC:  BCF    FF2.6
0A5CE:  BCF    FF2.7
0A5D0:  MOVLB  F
0A5D2:  MOVLW  55
0A5D4:  MOVWF  FA7
0A5D6:  MOVLW  AA
0A5D8:  MOVWF  FA7
0A5DA:  BSF    FA6.1
0A5DC:  BTFSC  FA6.1
0A5DE:  BRA    A5DC
0A5E0:  BCF    FA6.2
0A5E2:  MOVF   00,W
0A5E4:  IORWF  FF2,F
....................             delay_ms(20); 
0A5E6:  MOVLW  14
0A5E8:  MOVLB  B
0A5EA:  MOVWF  x22
0A5EC:  MOVLB  0
0A5EE:  CALL   11F6
....................             RX_Buffer[4]=0x00;   
0A5F2:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
0A5F4:  CLRF   40
....................             Alarma_on;delay_ms(500);Alarma_off; 
0A5F6:  BSF    F8B.0
0A5F8:  BCF    F94.0
0A5FA:  MOVLW  02
0A5FC:  MOVLB  B
0A5FE:  MOVWF  x00
0A600:  MOVLW  FA
0A602:  MOVWF  x22
0A604:  MOVLB  0
0A606:  CALL   11F6
0A60A:  MOVLB  B
0A60C:  DECFSZ x00,F
0A60E:  BRA    A600
0A610:  BCF    F8B.0
0A612:  BCF    F94.0
0A614:  MOVLB  0
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A616:  MOVF   35,W
0A618:  SUBLW  0B
0A61A:  BNZ   A61C
....................                 
....................          } 
....................       }else if(Opcion2==7){ 
0A61C:  BRA    AC78
0A61E:  MOVF   xBA,W
0A620:  SUBLW  07
0A622:  BTFSS  FD8.2
0A624:  BRA    A776
....................          VelMotor=0; 
0A626:  MOVLB  2
0A628:  CLRF   xD3
....................          VelMotor2=0; 
0A62A:  CLRF   xD4
....................          printf("Config.t2c.txt=\"Cero P2\""); 
0A62C:  MOVLW  70
0A62E:  MOVWF  FF6
0A630:  MOVLW  10
0A632:  MOVWF  FF7
0A634:  MOVLW  00
0A636:  MOVWF  FF8
0A638:  MOVLB  0
0A63A:  CALL   1304
....................          SendDataDisplay();       
0A63E:  CALL   1336
....................          printf("t3c.txt=\"%2.0f\"",Presion[3].G); 
0A642:  MOVLW  8A
0A644:  MOVWF  FF6
0A646:  MOVLW  10
0A648:  MOVWF  FF7
0A64A:  MOVLW  00
0A64C:  MOVWF  FF8
0A64E:  MOVLW  09
0A650:  MOVLB  B
0A652:  MOVWF  x02
0A654:  MOVLB  0
0A656:  CALL   5198
0A65A:  MOVLW  01
0A65C:  MOVWF  FE9
0A65E:  MOVFF  A75,B03
0A662:  MOVFF  A74,B02
0A666:  MOVFF  A73,B01
0A66A:  MOVFF  A72,B00
0A66E:  MOVLB  B
0A670:  CLRF   x04
0A672:  MOVLB  0
0A674:  CALL   54C2
0A678:  MOVLW  22
0A67A:  BTFSS  F9E.4
0A67C:  BRA    A67A
0A67E:  MOVWF  FAD
....................          SendDataDisplay(); 
0A680:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A684:  MOVF   35,W
0A686:  SUBLW  0A
0A688:  BNZ   A76E
....................             Presion[3].G=sensores(3);//Presion[3].adc; 
0A68A:  MOVLW  03
0A68C:  MOVLB  B
0A68E:  MOVWF  x1F
0A690:  MOVLB  0
0A692:  CALL   38CA
0A696:  MOVFF  02,B20
0A69A:  MOVFF  01,B1F
0A69E:  CALL   136C
0A6A2:  MOVFF  03,A75
0A6A6:  MOVFF  02,A74
0A6AA:  MOVFF  01,A73
0A6AE:  MOVFF  00,A72
....................             G16=(int16)Presion[3].G; 
0A6B2:  MOVFF  A75,B03
0A6B6:  MOVFF  A74,B02
0A6BA:  MOVFF  A73,B01
0A6BE:  MOVFF  A72,B00
0A6C2:  CALL   513E
0A6C6:  MOVFF  02,C6
0A6CA:  MOVFF  01,C5
....................             G_l=G16; G_h=(G16>>8); 
0A6CE:  MOVFF  C5,84
0A6D2:  MOVFF  C6,85
....................                 
....................             write_eeprom(48,G_l); 
0A6D6:  CLRF   FAA
0A6D8:  MOVLW  30
0A6DA:  MOVWF  FA9
0A6DC:  MOVFF  84,FA8
0A6E0:  BCF    FA6.6
0A6E2:  BCF    FA6.7
0A6E4:  BSF    FA6.2
0A6E6:  MOVF   FF2,W
0A6E8:  MOVWF  00
0A6EA:  BCF    FF2.6
0A6EC:  BCF    FF2.7
0A6EE:  MOVLB  F
0A6F0:  MOVLW  55
0A6F2:  MOVWF  FA7
0A6F4:  MOVLW  AA
0A6F6:  MOVWF  FA7
0A6F8:  BSF    FA6.1
0A6FA:  BTFSC  FA6.1
0A6FC:  BRA    A6FA
0A6FE:  BCF    FA6.2
0A700:  MOVF   00,W
0A702:  IORWF  FF2,F
....................             delay_ms(20); 
0A704:  MOVLW  14
0A706:  MOVLB  B
0A708:  MOVWF  x22
0A70A:  MOVLB  0
0A70C:  CALL   11F6
....................             write_eeprom(49,G_h);//Guardar valor de Setpoint en eeprom 
0A710:  CLRF   FAA
0A712:  MOVLW  31
0A714:  MOVWF  FA9
0A716:  MOVFF  85,FA8
0A71A:  BCF    FA6.6
0A71C:  BCF    FA6.7
0A71E:  BSF    FA6.2
0A720:  MOVF   FF2,W
0A722:  MOVWF  00
0A724:  BCF    FF2.6
0A726:  BCF    FF2.7
0A728:  MOVLB  F
0A72A:  MOVLW  55
0A72C:  MOVWF  FA7
0A72E:  MOVLW  AA
0A730:  MOVWF  FA7
0A732:  BSF    FA6.1
0A734:  BTFSC  FA6.1
0A736:  BRA    A734
0A738:  BCF    FA6.2
0A73A:  MOVF   00,W
0A73C:  IORWF  FF2,F
....................             delay_ms(20); 
0A73E:  MOVLW  14
0A740:  MOVLB  B
0A742:  MOVWF  x22
0A744:  MOVLB  0
0A746:  CALL   11F6
....................             RX_Buffer[4]=0x00;   
0A74A:  CLRF   35
....................             RX_Buffer2[4]=0x00; 
0A74C:  CLRF   40
....................             Alarma_on;delay_ms(500);Alarma_off; 
0A74E:  BSF    F8B.0
0A750:  BCF    F94.0
0A752:  MOVLW  02
0A754:  MOVLB  B
0A756:  MOVWF  x00
0A758:  MOVLW  FA
0A75A:  MOVWF  x22
0A75C:  MOVLB  0
0A75E:  CALL   11F6
0A762:  MOVLB  B
0A764:  DECFSZ x00,F
0A766:  BRA    A758
0A768:  BCF    F8B.0
0A76A:  BCF    F94.0
0A76C:  MOVLB  0
....................          } 
....................           
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida             
0A76E:  MOVF   35,W
0A770:  SUBLW  0B
0A772:  BNZ   A774
....................                 
....................          } 
....................       }else if(Opcion2==8){ 
0A774:  BRA    AC78
0A776:  MOVF   xBA,W
0A778:  SUBLW  08
0A77A:  BTFSS  FD8.2
0A77C:  BRA    A8A6
....................          printf("Config.t2c.txt=\"Ajuste Presion1\""); 
0A77E:  MOVLW  9A
0A780:  MOVWF  FF6
0A782:  MOVLW  10
0A784:  MOVWF  FF7
0A786:  MOVLW  00
0A788:  MOVWF  FF8
0A78A:  CALL   1304
....................          SendDataDisplay();       
0A78E:  CALL   1336
....................          printf("t3c.txt=\"%2.1f\"",Presion[4].Ajuste); 
0A792:  MOVLW  BC
0A794:  MOVWF  FF6
0A796:  MOVLW  10
0A798:  MOVWF  FF7
0A79A:  MOVLW  00
0A79C:  MOVWF  FF8
0A79E:  MOVLW  09
0A7A0:  MOVLB  B
0A7A2:  MOVWF  x02
0A7A4:  MOVLB  0
0A7A6:  CALL   5198
0A7AA:  MOVLW  01
0A7AC:  MOVWF  FE9
0A7AE:  MOVFF  AC7,B03
0A7B2:  MOVFF  AC6,B02
0A7B6:  MOVFF  AC5,B01
0A7BA:  MOVFF  AC4,B00
0A7BE:  MOVLB  B
0A7C0:  MOVWF  x04
0A7C2:  MOVLB  0
0A7C4:  CALL   54C2
0A7C8:  MOVLW  22
0A7CA:  BTFSS  F9E.4
0A7CC:  BRA    A7CA
0A7CE:  MOVWF  FAD
....................          //printf("t3c.txt=\"%2.1f\"",Ajustedn); 
....................          SendDataDisplay(); 
0A7D0:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A7D4:  MOVF   35,W
0A7D6:  SUBLW  0A
0A7D8:  BNZ   A83E
....................                if(Presion[4].Ajuste<5.0) 
0A7DA:  MOVFF  AC7,B22
0A7DE:  MOVFF  AC6,B21
0A7E2:  MOVFF  AC5,B20
0A7E6:  MOVFF  AC4,B1F
0A7EA:  MOVLB  B
0A7EC:  CLRF   x26
0A7EE:  CLRF   x25
0A7F0:  MOVLW  20
0A7F2:  MOVWF  x24
0A7F4:  MOVLW  81
0A7F6:  MOVWF  x23
0A7F8:  MOVLB  0
0A7FA:  CALL   241C
0A7FE:  BNC   A83A
....................                   Presion[4].Ajuste+=0.1; 
0A800:  BCF    FD8.1
0A802:  MOVFF  AC7,B26
0A806:  MOVFF  AC6,B25
0A80A:  MOVFF  AC5,B24
0A80E:  MOVFF  AC4,B23
0A812:  MOVLW  CD
0A814:  MOVLB  B
0A816:  MOVWF  x2A
0A818:  MOVLW  CC
0A81A:  MOVWF  x29
0A81C:  MOVLW  4C
0A81E:  MOVWF  x28
0A820:  MOVLW  7B
0A822:  MOVWF  x27
0A824:  MOVLB  0
0A826:  CALL   1500
0A82A:  MOVFF  03,AC7
0A82E:  MOVFF  02,AC6
0A832:  MOVFF  01,AC5
0A836:  MOVFF  00,AC4
....................                //if(Ajustedn<5.0) 
....................                //   Ajustedn+=0.1; 
....................                RX_Buffer[4]=0x00;   
0A83A:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A83C:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0A83E:  MOVF   35,W
0A840:  SUBLW  0B
0A842:  BNZ   A8A4
....................                if(Presion[4].Ajuste>0.0) 
0A844:  MOVLB  B
0A846:  CLRF   x22
0A848:  CLRF   x21
0A84A:  CLRF   x20
0A84C:  CLRF   x1F
0A84E:  MOVFF  AC7,B26
0A852:  MOVFF  AC6,B25
0A856:  MOVFF  AC5,B24
0A85A:  MOVFF  AC4,B23
0A85E:  MOVLB  0
0A860:  CALL   241C
0A864:  BNC   A8A0
....................                   Presion[4].Ajuste-=0.1; 
0A866:  BSF    FD8.1
0A868:  MOVFF  AC7,B26
0A86C:  MOVFF  AC6,B25
0A870:  MOVFF  AC5,B24
0A874:  MOVFF  AC4,B23
0A878:  MOVLW  CD
0A87A:  MOVLB  B
0A87C:  MOVWF  x2A
0A87E:  MOVLW  CC
0A880:  MOVWF  x29
0A882:  MOVLW  4C
0A884:  MOVWF  x28
0A886:  MOVLW  7B
0A888:  MOVWF  x27
0A88A:  MOVLB  0
0A88C:  CALL   1500
0A890:  MOVFF  03,AC7
0A894:  MOVFF  02,AC6
0A898:  MOVFF  01,AC5
0A89C:  MOVFF  00,AC4
....................                //if(Ajustedn>0.0) 
....................                //   Ajustedn-=0.1; 
....................                RX_Buffer[4]=0x00; 
0A8A0:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A8A2:  CLRF   40
....................          } 
....................       }else if(Opcion2==9){ 
0A8A4:  BRA    AC78
0A8A6:  MOVF   xBA,W
0A8A8:  SUBLW  09
0A8AA:  BTFSS  FD8.2
0A8AC:  BRA    A9D6
....................          printf("Config.t2c.txt=\"Ajuste Presion2\""); 
0A8AE:  MOVLW  CC
0A8B0:  MOVWF  FF6
0A8B2:  MOVLW  10
0A8B4:  MOVWF  FF7
0A8B6:  MOVLW  00
0A8B8:  MOVWF  FF8
0A8BA:  CALL   1304
....................          SendDataDisplay();       
0A8BE:  CALL   1336
....................          printf("t3c.txt=\"%2.1f\"",Presion[3].Ajuste); 
0A8C2:  MOVLW  EE
0A8C4:  MOVWF  FF6
0A8C6:  MOVLW  10
0A8C8:  MOVWF  FF7
0A8CA:  MOVLW  00
0A8CC:  MOVWF  FF8
0A8CE:  MOVLW  09
0A8D0:  MOVLB  B
0A8D2:  MOVWF  x02
0A8D4:  MOVLB  0
0A8D6:  CALL   5198
0A8DA:  MOVLW  01
0A8DC:  MOVWF  FE9
0A8DE:  MOVFF  A83,B03
0A8E2:  MOVFF  A82,B02
0A8E6:  MOVFF  A81,B01
0A8EA:  MOVFF  A80,B00
0A8EE:  MOVLB  B
0A8F0:  MOVWF  x04
0A8F2:  MOVLB  0
0A8F4:  CALL   54C2
0A8F8:  MOVLW  22
0A8FA:  BTFSS  F9E.4
0A8FC:  BRA    A8FA
0A8FE:  MOVWF  FAD
....................          SendDataDisplay(); 
0A900:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida             
0A904:  MOVF   35,W
0A906:  SUBLW  0A
0A908:  BNZ   A96E
....................                if(Presion[3].Ajuste<5.0) 
0A90A:  MOVFF  A83,B22
0A90E:  MOVFF  A82,B21
0A912:  MOVFF  A81,B20
0A916:  MOVFF  A80,B1F
0A91A:  MOVLB  B
0A91C:  CLRF   x26
0A91E:  CLRF   x25
0A920:  MOVLW  20
0A922:  MOVWF  x24
0A924:  MOVLW  81
0A926:  MOVWF  x23
0A928:  MOVLB  0
0A92A:  CALL   241C
0A92E:  BNC   A96A
....................                   Presion[3].Ajuste+=0.1; 
0A930:  BCF    FD8.1
0A932:  MOVFF  A83,B26
0A936:  MOVFF  A82,B25
0A93A:  MOVFF  A81,B24
0A93E:  MOVFF  A80,B23
0A942:  MOVLW  CD
0A944:  MOVLB  B
0A946:  MOVWF  x2A
0A948:  MOVLW  CC
0A94A:  MOVWF  x29
0A94C:  MOVLW  4C
0A94E:  MOVWF  x28
0A950:  MOVLW  7B
0A952:  MOVWF  x27
0A954:  MOVLB  0
0A956:  CALL   1500
0A95A:  MOVFF  03,A83
0A95E:  MOVFF  02,A82
0A962:  MOVFF  01,A81
0A966:  MOVFF  00,A80
....................                RX_Buffer[4]=0x00;   
0A96A:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A96C:  CLRF   40
....................          } 
....................              
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0A96E:  MOVF   35,W
0A970:  SUBLW  0B
0A972:  BNZ   A9D4
....................                if(Presion[3].Ajuste>0.0) 
0A974:  MOVLB  B
0A976:  CLRF   x22
0A978:  CLRF   x21
0A97A:  CLRF   x20
0A97C:  CLRF   x1F
0A97E:  MOVFF  A83,B26
0A982:  MOVFF  A82,B25
0A986:  MOVFF  A81,B24
0A98A:  MOVFF  A80,B23
0A98E:  MOVLB  0
0A990:  CALL   241C
0A994:  BNC   A9D0
....................                   Presion[3].Ajuste-=0.1; 
0A996:  BSF    FD8.1
0A998:  MOVFF  A83,B26
0A99C:  MOVFF  A82,B25
0A9A0:  MOVFF  A81,B24
0A9A4:  MOVFF  A80,B23
0A9A8:  MOVLW  CD
0A9AA:  MOVLB  B
0A9AC:  MOVWF  x2A
0A9AE:  MOVLW  CC
0A9B0:  MOVWF  x29
0A9B2:  MOVLW  4C
0A9B4:  MOVWF  x28
0A9B6:  MOVLW  7B
0A9B8:  MOVWF  x27
0A9BA:  MOVLB  0
0A9BC:  CALL   1500
0A9C0:  MOVFF  03,A83
0A9C4:  MOVFF  02,A82
0A9C8:  MOVFF  01,A81
0A9CC:  MOVFF  00,A80
....................                RX_Buffer[4]=0x00; 
0A9D0:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0A9D2:  CLRF   40
....................          } 
....................       }else if(Opcion2==10){ 
0A9D4:  BRA    AC78
0A9D6:  MOVF   xBA,W
0A9D8:  SUBLW  0A
0A9DA:  BNZ   AA8E
....................          printf("Config.t2c.txt=\"Subir Codigo\""); 
0A9DC:  MOVLW  FE
0A9DE:  MOVWF  FF6
0A9E0:  MOVLW  10
0A9E2:  MOVWF  FF7
0A9E4:  MOVLW  00
0A9E6:  MOVWF  FF8
0A9E8:  CALL   1304
....................          SendDataDisplay();       
0A9EC:  CALL   1336
....................          printf("t3c.txt=\"%X\"",codigoSubir); 
0A9F0:  MOVLW  1C
0A9F2:  MOVWF  FF6
0A9F4:  MOVLW  11
0A9F6:  MOVWF  FF7
0A9F8:  MOVLW  00
0A9FA:  MOVWF  FF8
0A9FC:  MOVLW  09
0A9FE:  MOVLB  B
0AA00:  MOVWF  x02
0AA02:  MOVLB  0
0AA04:  CALL   5198
0AA08:  MOVFF  87,B02
0AA0C:  MOVLW  37
0AA0E:  MOVLB  B
0AA10:  MOVWF  x03
0AA12:  MOVLB  0
0AA14:  CALL   5E66
0AA18:  MOVLW  22
0AA1A:  BTFSS  F9E.4
0AA1C:  BRA    AA1A
0AA1E:  MOVWF  FAD
....................          SendDataDisplay(); 
0AA20:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AA24:  MOVF   35,W
0AA26:  SUBLW  0A
0AA28:  BNZ   AA8C
....................                codigoSubir=BYTE_IR[3]; 
0AA2A:  MOVFF  2E2,87
....................                RX_Buffer[4]=0x00;   
0AA2E:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AA30:  CLRF   40
....................                write_eeprom(54,codigoSubir); 
0AA32:  CLRF   FAA
0AA34:  MOVLW  36
0AA36:  MOVWF  FA9
0AA38:  MOVFF  87,FA8
0AA3C:  BCF    FA6.6
0AA3E:  BCF    FA6.7
0AA40:  BSF    FA6.2
0AA42:  MOVF   FF2,W
0AA44:  MOVWF  00
0AA46:  BCF    FF2.6
0AA48:  BCF    FF2.7
0AA4A:  MOVLB  F
0AA4C:  MOVLW  55
0AA4E:  MOVWF  FA7
0AA50:  MOVLW  AA
0AA52:  MOVWF  FA7
0AA54:  BSF    FA6.1
0AA56:  BTFSC  FA6.1
0AA58:  BRA    AA56
0AA5A:  BCF    FA6.2
0AA5C:  MOVF   00,W
0AA5E:  IORWF  FF2,F
....................                delay_ms(20); 
0AA60:  MOVLW  14
0AA62:  MOVLB  B
0AA64:  MOVWF  x22
0AA66:  MOVLB  0
0AA68:  CALL   11F6
....................                Alarma_on;delay_ms(500);Alarma_off; 
0AA6C:  BSF    F8B.0
0AA6E:  BCF    F94.0
0AA70:  MOVLW  02
0AA72:  MOVLB  B
0AA74:  MOVWF  x00
0AA76:  MOVLW  FA
0AA78:  MOVWF  x22
0AA7A:  MOVLB  0
0AA7C:  CALL   11F6
0AA80:  MOVLB  B
0AA82:  DECFSZ x00,F
0AA84:  BRA    AA76
0AA86:  BCF    F8B.0
0AA88:  BCF    F94.0
0AA8A:  MOVLB  0
....................          } 
....................       }else if(Opcion2==11){ 
0AA8C:  BRA    AC78
0AA8E:  MOVF   xBA,W
0AA90:  SUBLW  0B
0AA92:  BNZ   AB46
....................          printf("Config.t2c.txt=\"Bajar Codigo\""); 
0AA94:  MOVLW  2A
0AA96:  MOVWF  FF6
0AA98:  MOVLW  11
0AA9A:  MOVWF  FF7
0AA9C:  MOVLW  00
0AA9E:  MOVWF  FF8
0AAA0:  CALL   1304
....................          SendDataDisplay();       
0AAA4:  CALL   1336
....................          printf("t3c.txt=\"%X\"",codigoBajar); 
0AAA8:  MOVLW  48
0AAAA:  MOVWF  FF6
0AAAC:  MOVLW  11
0AAAE:  MOVWF  FF7
0AAB0:  MOVLW  00
0AAB2:  MOVWF  FF8
0AAB4:  MOVLW  09
0AAB6:  MOVLB  B
0AAB8:  MOVWF  x02
0AABA:  MOVLB  0
0AABC:  CALL   5198
0AAC0:  MOVFF  88,B02
0AAC4:  MOVLW  37
0AAC6:  MOVLB  B
0AAC8:  MOVWF  x03
0AACA:  MOVLB  0
0AACC:  CALL   5E66
0AAD0:  MOVLW  22
0AAD2:  BTFSS  F9E.4
0AAD4:  BRA    AAD2
0AAD6:  MOVWF  FAD
....................          SendDataDisplay(); 
0AAD8:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AADC:  MOVF   35,W
0AADE:  SUBLW  0A
0AAE0:  BNZ   AB44
....................                codigoBajar=BYTE_IR[3]; 
0AAE2:  MOVFF  2E2,88
....................                RX_Buffer[4]=0x00;   
0AAE6:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0AAE8:  CLRF   40
....................                write_eeprom(55,codigoBajar); 
0AAEA:  CLRF   FAA
0AAEC:  MOVLW  37
0AAEE:  MOVWF  FA9
0AAF0:  MOVFF  88,FA8
0AAF4:  BCF    FA6.6
0AAF6:  BCF    FA6.7
0AAF8:  BSF    FA6.2
0AAFA:  MOVF   FF2,W
0AAFC:  MOVWF  00
0AAFE:  BCF    FF2.6
0AB00:  BCF    FF2.7
0AB02:  MOVLB  F
0AB04:  MOVLW  55
0AB06:  MOVWF  FA7
0AB08:  MOVLW  AA
0AB0A:  MOVWF  FA7
0AB0C:  BSF    FA6.1
0AB0E:  BTFSC  FA6.1
0AB10:  BRA    AB0E
0AB12:  BCF    FA6.2
0AB14:  MOVF   00,W
0AB16:  IORWF  FF2,F
....................                delay_ms(20); 
0AB18:  MOVLW  14
0AB1A:  MOVLB  B
0AB1C:  MOVWF  x22
0AB1E:  MOVLB  0
0AB20:  CALL   11F6
....................                Alarma_on;delay_ms(500);Alarma_off; 
0AB24:  BSF    F8B.0
0AB26:  BCF    F94.0
0AB28:  MOVLW  02
0AB2A:  MOVLB  B
0AB2C:  MOVWF  x00
0AB2E:  MOVLW  FA
0AB30:  MOVWF  x22
0AB32:  MOVLB  0
0AB34:  CALL   11F6
0AB38:  MOVLB  B
0AB3A:  DECFSZ x00,F
0AB3C:  BRA    AB2E
0AB3E:  BCF    F8B.0
0AB40:  BCF    F94.0
0AB42:  MOVLB  0
....................          } 
....................       }else if(Opcion2==12){ 
0AB44:  BRA    AC78
0AB46:  MOVF   xBA,W
0AB48:  SUBLW  0C
0AB4A:  BNZ   ABFE
....................          printf("Config.t2c.txt=\"Detener Codigo\""); 
0AB4C:  MOVLW  56
0AB4E:  MOVWF  FF6
0AB50:  MOVLW  11
0AB52:  MOVWF  FF7
0AB54:  MOVLW  00
0AB56:  MOVWF  FF8
0AB58:  CALL   1304
....................          SendDataDisplay();       
0AB5C:  CALL   1336
....................          printf("t3c.txt=\"%X\"",codigoDetener); 
0AB60:  MOVLW  76
0AB62:  MOVWF  FF6
0AB64:  MOVLW  11
0AB66:  MOVWF  FF7
0AB68:  MOVLW  00
0AB6A:  MOVWF  FF8
0AB6C:  MOVLW  09
0AB6E:  MOVLB  B
0AB70:  MOVWF  x02
0AB72:  MOVLB  0
0AB74:  CALL   5198
0AB78:  MOVFF  89,B02
0AB7C:  MOVLW  37
0AB7E:  MOVLB  B
0AB80:  MOVWF  x03
0AB82:  MOVLB  0
0AB84:  CALL   5E66
0AB88:  MOVLW  22
0AB8A:  BTFSS  F9E.4
0AB8C:  BRA    AB8A
0AB8E:  MOVWF  FAD
....................          SendDataDisplay(); 
0AB90:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AB94:  MOVF   35,W
0AB96:  SUBLW  0A
0AB98:  BNZ   ABFC
....................                codigoDetener=BYTE_IR[3]; 
0AB9A:  MOVFF  2E2,89
....................                RX_Buffer[4]=0x00;   
0AB9E:  CLRF   35
....................                RX_Buffer2[4]=0x00;             
0ABA0:  CLRF   40
....................                write_eeprom(56,codigoDetener); 
0ABA2:  CLRF   FAA
0ABA4:  MOVLW  38
0ABA6:  MOVWF  FA9
0ABA8:  MOVFF  89,FA8
0ABAC:  BCF    FA6.6
0ABAE:  BCF    FA6.7
0ABB0:  BSF    FA6.2
0ABB2:  MOVF   FF2,W
0ABB4:  MOVWF  00
0ABB6:  BCF    FF2.6
0ABB8:  BCF    FF2.7
0ABBA:  MOVLB  F
0ABBC:  MOVLW  55
0ABBE:  MOVWF  FA7
0ABC0:  MOVLW  AA
0ABC2:  MOVWF  FA7
0ABC4:  BSF    FA6.1
0ABC6:  BTFSC  FA6.1
0ABC8:  BRA    ABC6
0ABCA:  BCF    FA6.2
0ABCC:  MOVF   00,W
0ABCE:  IORWF  FF2,F
....................                delay_ms(20); 
0ABD0:  MOVLW  14
0ABD2:  MOVLB  B
0ABD4:  MOVWF  x22
0ABD6:  MOVLB  0
0ABD8:  CALL   11F6
....................                Alarma_on;delay_ms(500);Alarma_off; 
0ABDC:  BSF    F8B.0
0ABDE:  BCF    F94.0
0ABE0:  MOVLW  02
0ABE2:  MOVLB  B
0ABE4:  MOVWF  x00
0ABE6:  MOVLW  FA
0ABE8:  MOVWF  x22
0ABEA:  MOVLB  0
0ABEC:  CALL   11F6
0ABF0:  MOVLB  B
0ABF2:  DECFSZ x00,F
0ABF4:  BRA    ABE6
0ABF6:  BCF    F8B.0
0ABF8:  BCF    F94.0
0ABFA:  MOVLB  0
....................          } 
....................       }else if(Opcion2==13){ 
0ABFC:  BRA    AC78
0ABFE:  MOVF   xBA,W
0AC00:  SUBLW  0D
0AC02:  BNZ   AC78
....................          printf("Config.t2c.txt=\"Media Movil\""); 
0AC04:  MOVLW  84
0AC06:  MOVWF  FF6
0AC08:  MOVLW  11
0AC0A:  MOVWF  FF7
0AC0C:  MOVLW  00
0AC0E:  MOVWF  FF8
0AC10:  CALL   1304
....................          SendDataDisplay();       
0AC14:  CALL   1336
....................          printf("t3c.txt=\"%02u\"",mediaMovil); 
0AC18:  MOVLW  A2
0AC1A:  MOVWF  FF6
0AC1C:  MOVLW  11
0AC1E:  MOVWF  FF7
0AC20:  MOVLW  00
0AC22:  MOVWF  FF8
0AC24:  MOVLW  09
0AC26:  MOVLB  B
0AC28:  MOVWF  x02
0AC2A:  MOVLB  0
0AC2C:  CALL   5198
0AC30:  MOVFF  95,B01
0AC34:  MOVLW  01
0AC36:  MOVLB  B
0AC38:  MOVWF  x02
0AC3A:  MOVLB  0
0AC3C:  CALL   51F6
0AC40:  MOVLW  22
0AC42:  BTFSS  F9E.4
0AC44:  BRA    AC42
0AC46:  MOVWF  FAD
....................          SendDataDisplay(); 
0AC48:  CALL   1336
....................          if(RX_Buffer[4]==0x0a){//Tecla Arriba Oprimida 
0AC4C:  MOVF   35,W
0AC4E:  SUBLW  0A
0AC50:  BNZ   AC58
....................             mediaMovil++; 
0AC52:  INCF   x95,F
....................             RX_Buffer[4]=0x00;   
0AC54:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AC56:  CLRF   40
....................          } 
....................          if(RX_Buffer[4]==0x0b){//Tecla Abajo Oprimida 
0AC58:  MOVF   35,W
0AC5A:  SUBLW  0B
0AC5C:  BNZ   AC64
....................             mediaMovil--; 
0AC5E:  DECF   x95,F
....................             RX_Buffer[4]=0x00; 
0AC60:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AC62:  CLRF   40
....................          } 
....................          if(mediaMovil>80) 
0AC64:  MOVF   x95,W
0AC66:  SUBLW  50
0AC68:  BC    AC6E
....................             mediaMovil=10; 
0AC6A:  MOVLW  0A
0AC6C:  MOVWF  x95
....................          if(mediaMovil<10) 
0AC6E:  MOVF   x95,W
0AC70:  SUBLW  09
0AC72:  BNC   AC78
....................             mediaMovil=80;    
0AC74:  MOVLW  50
0AC76:  MOVWF  x95
....................       } 
....................        
....................       if(RX_Buffer[4]==0x0c){//Tecla Izquierda Oprimida 
0AC78:  MOVF   35,W
0AC7A:  SUBLW  0C
0AC7C:  BNZ   AC84
....................             Opcion2++; 
0AC7E:  INCF   xBA,F
....................             RX_Buffer[4]=0x00;   
0AC80:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AC82:  CLRF   40
....................             //BorraBuffer();    
....................       } 
....................           
....................       if(RX_Buffer[4]==0x0d){//Tecla Derecha Oprimida          
0AC84:  MOVF   35,W
0AC86:  SUBLW  0D
0AC88:  BNZ   AC90
....................             Opcion2--; 
0AC8A:  DECF   xBA,F
....................             RX_Buffer[4]=0x00; 
0AC8C:  CLRF   35
....................             RX_Buffer2[4]=0x00;             
0AC8E:  CLRF   40
....................             //BorraBuffer(); 
....................       } 
....................        
....................       if(RX_Buffer[4]==0x11){//Tecla Regresar 
0AC90:  MOVF   35,W
0AC92:  SUBLW  11
0AC94:  BTFSS  FD8.2
0AC96:  BRA    B350
....................          delay_ms(20); 
0AC98:  MOVLW  14
0AC9A:  MOVLB  B
0AC9C:  MOVWF  x22
0AC9E:  MOVLB  0
0ACA0:  CALL   11F6
....................          if(RX_Buffer[4]==0x11){ 
0ACA4:  MOVF   35,W
0ACA6:  SUBLW  11
0ACA8:  BTFSS  FD8.2
0ACAA:  BRA    B350
....................             if(!GuardaEEPROM){ 
0ACAC:  BTFSC  x7E.6
0ACAE:  BRA    B33C
....................                Temporal=Flujo[1].Ajuste; 
0ACB0:  MOVFF  454,100
0ACB4:  MOVFF  453,FF
0ACB8:  MOVFF  452,FE
0ACBC:  MOVFF  451,FD
....................                Entero=(int)Flujo[1].Ajuste; 
0ACC0:  MOVFF  454,B03
0ACC4:  MOVFF  453,B02
0ACC8:  MOVFF  452,B01
0ACCC:  MOVFF  451,B00
0ACD0:  CALL   513E
0ACD4:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0ACD8:  MOVLB  B
0ACDA:  CLRF   x20
0ACDC:  MOVFF  8E,B1F
0ACE0:  MOVLB  0
0ACE2:  CALL   136C
0ACE6:  BSF    FD8.1
0ACE8:  MOVFF  100,B26
0ACEC:  MOVFF  FF,B25
0ACF0:  MOVFF  FE,B24
0ACF4:  MOVFF  FD,B23
0ACF8:  MOVFF  03,B2A
0ACFC:  MOVFF  02,B29
0AD00:  MOVFF  01,B28
0AD04:  MOVFF  00,B27
0AD08:  CALL   1500
0AD0C:  MOVFF  03,100
0AD10:  MOVFF  02,FF
0AD14:  MOVFF  01,FE
0AD18:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0AD1C:  MOVFF  100,B26
0AD20:  MOVFF  FF,B25
0AD24:  MOVFF  FE,B24
0AD28:  MOVFF  FD,B23
0AD2C:  MOVLB  B
0AD2E:  CLRF   x2A
0AD30:  CLRF   x29
0AD32:  MOVLW  20
0AD34:  MOVWF  x28
0AD36:  MOVLW  82
0AD38:  MOVWF  x27
0AD3A:  MOVLB  0
0AD3C:  CALL   3908
0AD40:  MOVFF  03,104
0AD44:  MOVFF  02,103
0AD48:  MOVFF  01,102
0AD4C:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0AD50:  MOVFF  104,B03
0AD54:  MOVFF  103,B02
0AD58:  MOVFF  102,B01
0AD5C:  MOVFF  101,B00
0AD60:  CALL   513E
0AD64:  MOVFF  01,8F
....................                write_eeprom(25,Entero); 
0AD68:  CLRF   FAA
0AD6A:  MOVLW  19
0AD6C:  MOVWF  FA9
0AD6E:  MOVFF  8E,FA8
0AD72:  BCF    FA6.6
0AD74:  BCF    FA6.7
0AD76:  BSF    FA6.2
0AD78:  MOVF   FF2,W
0AD7A:  MOVWF  00
0AD7C:  BCF    FF2.6
0AD7E:  BCF    FF2.7
0AD80:  MOVLB  F
0AD82:  MOVLW  55
0AD84:  MOVWF  FA7
0AD86:  MOVLW  AA
0AD88:  MOVWF  FA7
0AD8A:  BSF    FA6.1
0AD8C:  BTFSC  FA6.1
0AD8E:  BRA    AD8C
0AD90:  BCF    FA6.2
0AD92:  MOVF   00,W
0AD94:  IORWF  FF2,F
....................                delay_ms(20); 
0AD96:  MOVLW  14
0AD98:  MOVLB  B
0AD9A:  MOVWF  x22
0AD9C:  MOVLB  0
0AD9E:  CALL   11F6
....................                write_eeprom(26,Decimal1); 
0ADA2:  CLRF   FAA
0ADA4:  MOVLW  1A
0ADA6:  MOVWF  FA9
0ADA8:  MOVFF  8F,FA8
0ADAC:  BCF    FA6.6
0ADAE:  BCF    FA6.7
0ADB0:  BSF    FA6.2
0ADB2:  MOVF   FF2,W
0ADB4:  MOVWF  00
0ADB6:  BCF    FF2.6
0ADB8:  BCF    FF2.7
0ADBA:  MOVLB  F
0ADBC:  MOVLW  55
0ADBE:  MOVWF  FA7
0ADC0:  MOVLW  AA
0ADC2:  MOVWF  FA7
0ADC4:  BSF    FA6.1
0ADC6:  BTFSC  FA6.1
0ADC8:  BRA    ADC6
0ADCA:  BCF    FA6.2
0ADCC:  MOVF   00,W
0ADCE:  IORWF  FF2,F
....................                delay_ms(20); 
0ADD0:  MOVLW  14
0ADD2:  MOVLB  B
0ADD4:  MOVWF  x22
0ADD6:  MOVLB  0
0ADD8:  CALL   11F6
....................                 
....................                Temporal=Flujo[2].Ajuste; 
0ADDC:  MOVFF  5AD,100
0ADE0:  MOVFF  5AC,FF
0ADE4:  MOVFF  5AB,FE
0ADE8:  MOVFF  5AA,FD
....................                Entero=(int)Flujo[2].Ajuste; 
0ADEC:  MOVFF  5AD,B03
0ADF0:  MOVFF  5AC,B02
0ADF4:  MOVFF  5AB,B01
0ADF8:  MOVFF  5AA,B00
0ADFC:  CALL   513E
0AE00:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0AE04:  MOVLB  B
0AE06:  CLRF   x20
0AE08:  MOVFF  8E,B1F
0AE0C:  MOVLB  0
0AE0E:  CALL   136C
0AE12:  BSF    FD8.1
0AE14:  MOVFF  100,B26
0AE18:  MOVFF  FF,B25
0AE1C:  MOVFF  FE,B24
0AE20:  MOVFF  FD,B23
0AE24:  MOVFF  03,B2A
0AE28:  MOVFF  02,B29
0AE2C:  MOVFF  01,B28
0AE30:  MOVFF  00,B27
0AE34:  CALL   1500
0AE38:  MOVFF  03,100
0AE3C:  MOVFF  02,FF
0AE40:  MOVFF  01,FE
0AE44:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0AE48:  MOVFF  100,B26
0AE4C:  MOVFF  FF,B25
0AE50:  MOVFF  FE,B24
0AE54:  MOVFF  FD,B23
0AE58:  MOVLB  B
0AE5A:  CLRF   x2A
0AE5C:  CLRF   x29
0AE5E:  MOVLW  20
0AE60:  MOVWF  x28
0AE62:  MOVLW  82
0AE64:  MOVWF  x27
0AE66:  MOVLB  0
0AE68:  CALL   3908
0AE6C:  MOVFF  03,104
0AE70:  MOVFF  02,103
0AE74:  MOVFF  01,102
0AE78:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0AE7C:  MOVFF  104,B03
0AE80:  MOVFF  103,B02
0AE84:  MOVFF  102,B01
0AE88:  MOVFF  101,B00
0AE8C:  CALL   513E
0AE90:  MOVFF  01,8F
....................                write_eeprom(27,Entero); 
0AE94:  CLRF   FAA
0AE96:  MOVLW  1B
0AE98:  MOVWF  FA9
0AE9A:  MOVFF  8E,FA8
0AE9E:  BCF    FA6.6
0AEA0:  BCF    FA6.7
0AEA2:  BSF    FA6.2
0AEA4:  MOVF   FF2,W
0AEA6:  MOVWF  00
0AEA8:  BCF    FF2.6
0AEAA:  BCF    FF2.7
0AEAC:  MOVLB  F
0AEAE:  MOVLW  55
0AEB0:  MOVWF  FA7
0AEB2:  MOVLW  AA
0AEB4:  MOVWF  FA7
0AEB6:  BSF    FA6.1
0AEB8:  BTFSC  FA6.1
0AEBA:  BRA    AEB8
0AEBC:  BCF    FA6.2
0AEBE:  MOVF   00,W
0AEC0:  IORWF  FF2,F
....................                delay_ms(20); 
0AEC2:  MOVLW  14
0AEC4:  MOVLB  B
0AEC6:  MOVWF  x22
0AEC8:  MOVLB  0
0AECA:  CALL   11F6
....................                write_eeprom(28,Decimal1); 
0AECE:  CLRF   FAA
0AED0:  MOVLW  1C
0AED2:  MOVWF  FA9
0AED4:  MOVFF  8F,FA8
0AED8:  BCF    FA6.6
0AEDA:  BCF    FA6.7
0AEDC:  BSF    FA6.2
0AEDE:  MOVF   FF2,W
0AEE0:  MOVWF  00
0AEE2:  BCF    FF2.6
0AEE4:  BCF    FF2.7
0AEE6:  MOVLB  F
0AEE8:  MOVLW  55
0AEEA:  MOVWF  FA7
0AEEC:  MOVLW  AA
0AEEE:  MOVWF  FA7
0AEF0:  BSF    FA6.1
0AEF2:  BTFSC  FA6.1
0AEF4:  BRA    AEF2
0AEF6:  BCF    FA6.2
0AEF8:  MOVF   00,W
0AEFA:  IORWF  FF2,F
....................                delay_ms(20); 
0AEFC:  MOVLW  14
0AEFE:  MOVLB  B
0AF00:  MOVWF  x22
0AF02:  MOVLB  0
0AF04:  CALL   11F6
....................                 
....................                Temporal=Presion[4].Ajuste; 
0AF08:  MOVFF  AC7,100
0AF0C:  MOVFF  AC6,FF
0AF10:  MOVFF  AC5,FE
0AF14:  MOVFF  AC4,FD
....................                Entero=(int)Presion[4].Ajuste; 
0AF18:  MOVFF  AC7,B03
0AF1C:  MOVFF  AC6,B02
0AF20:  MOVFF  AC5,B01
0AF24:  MOVFF  AC4,B00
0AF28:  CALL   513E
0AF2C:  MOVFF  01,8E
....................                //Temporal=Ajustedn; 
....................                //Entero=(int)Ajustedn; 
....................                Temporal=Temporal-Entero; 
0AF30:  MOVLB  B
0AF32:  CLRF   x20
0AF34:  MOVFF  8E,B1F
0AF38:  MOVLB  0
0AF3A:  CALL   136C
0AF3E:  BSF    FD8.1
0AF40:  MOVFF  100,B26
0AF44:  MOVFF  FF,B25
0AF48:  MOVFF  FE,B24
0AF4C:  MOVFF  FD,B23
0AF50:  MOVFF  03,B2A
0AF54:  MOVFF  02,B29
0AF58:  MOVFF  01,B28
0AF5C:  MOVFF  00,B27
0AF60:  CALL   1500
0AF64:  MOVFF  03,100
0AF68:  MOVFF  02,FF
0AF6C:  MOVFF  01,FE
0AF70:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0AF74:  MOVFF  100,B26
0AF78:  MOVFF  FF,B25
0AF7C:  MOVFF  FE,B24
0AF80:  MOVFF  FD,B23
0AF84:  MOVLB  B
0AF86:  CLRF   x2A
0AF88:  CLRF   x29
0AF8A:  MOVLW  20
0AF8C:  MOVWF  x28
0AF8E:  MOVLW  82
0AF90:  MOVWF  x27
0AF92:  MOVLB  0
0AF94:  CALL   3908
0AF98:  MOVFF  03,104
0AF9C:  MOVFF  02,103
0AFA0:  MOVFF  01,102
0AFA4:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0AFA8:  MOVFF  104,B03
0AFAC:  MOVFF  103,B02
0AFB0:  MOVFF  102,B01
0AFB4:  MOVFF  101,B00
0AFB8:  CALL   513E
0AFBC:  MOVFF  01,8F
....................                write_eeprom(29,Entero); 
0AFC0:  CLRF   FAA
0AFC2:  MOVLW  1D
0AFC4:  MOVWF  FA9
0AFC6:  MOVFF  8E,FA8
0AFCA:  BCF    FA6.6
0AFCC:  BCF    FA6.7
0AFCE:  BSF    FA6.2
0AFD0:  MOVF   FF2,W
0AFD2:  MOVWF  00
0AFD4:  BCF    FF2.6
0AFD6:  BCF    FF2.7
0AFD8:  MOVLB  F
0AFDA:  MOVLW  55
0AFDC:  MOVWF  FA7
0AFDE:  MOVLW  AA
0AFE0:  MOVWF  FA7
0AFE2:  BSF    FA6.1
0AFE4:  BTFSC  FA6.1
0AFE6:  BRA    AFE4
0AFE8:  BCF    FA6.2
0AFEA:  MOVF   00,W
0AFEC:  IORWF  FF2,F
....................                delay_ms(20); 
0AFEE:  MOVLW  14
0AFF0:  MOVLB  B
0AFF2:  MOVWF  x22
0AFF4:  MOVLB  0
0AFF6:  CALL   11F6
....................                write_eeprom(30,Decimal1); 
0AFFA:  CLRF   FAA
0AFFC:  MOVLW  1E
0AFFE:  MOVWF  FA9
0B000:  MOVFF  8F,FA8
0B004:  BCF    FA6.6
0B006:  BCF    FA6.7
0B008:  BSF    FA6.2
0B00A:  MOVF   FF2,W
0B00C:  MOVWF  00
0B00E:  BCF    FF2.6
0B010:  BCF    FF2.7
0B012:  MOVLB  F
0B014:  MOVLW  55
0B016:  MOVWF  FA7
0B018:  MOVLW  AA
0B01A:  MOVWF  FA7
0B01C:  BSF    FA6.1
0B01E:  BTFSC  FA6.1
0B020:  BRA    B01E
0B022:  BCF    FA6.2
0B024:  MOVF   00,W
0B026:  IORWF  FF2,F
....................                delay_ms(20); 
0B028:  MOVLW  14
0B02A:  MOVLB  B
0B02C:  MOVWF  x22
0B02E:  MOVLB  0
0B030:  CALL   11F6
....................                 
....................                Temporal=Presion[3].Ajuste; 
0B034:  MOVFF  A83,100
0B038:  MOVFF  A82,FF
0B03C:  MOVFF  A81,FE
0B040:  MOVFF  A80,FD
....................                Entero=(int)Presion[3].Ajuste; 
0B044:  MOVFF  A83,B03
0B048:  MOVFF  A82,B02
0B04C:  MOVFF  A81,B01
0B050:  MOVFF  A80,B00
0B054:  CALL   513E
0B058:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0B05C:  MOVLB  B
0B05E:  CLRF   x20
0B060:  MOVFF  8E,B1F
0B064:  MOVLB  0
0B066:  CALL   136C
0B06A:  BSF    FD8.1
0B06C:  MOVFF  100,B26
0B070:  MOVFF  FF,B25
0B074:  MOVFF  FE,B24
0B078:  MOVFF  FD,B23
0B07C:  MOVFF  03,B2A
0B080:  MOVFF  02,B29
0B084:  MOVFF  01,B28
0B088:  MOVFF  00,B27
0B08C:  CALL   1500
0B090:  MOVFF  03,100
0B094:  MOVFF  02,FF
0B098:  MOVFF  01,FE
0B09C:  MOVFF  00,FD
....................                Temporal2=Temporal*10.0; 
0B0A0:  MOVFF  100,B26
0B0A4:  MOVFF  FF,B25
0B0A8:  MOVFF  FE,B24
0B0AC:  MOVFF  FD,B23
0B0B0:  MOVLB  B
0B0B2:  CLRF   x2A
0B0B4:  CLRF   x29
0B0B6:  MOVLW  20
0B0B8:  MOVWF  x28
0B0BA:  MOVLW  82
0B0BC:  MOVWF  x27
0B0BE:  MOVLB  0
0B0C0:  CALL   3908
0B0C4:  MOVFF  03,104
0B0C8:  MOVFF  02,103
0B0CC:  MOVFF  01,102
0B0D0:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B0D4:  MOVFF  104,B03
0B0D8:  MOVFF  103,B02
0B0DC:  MOVFF  102,B01
0B0E0:  MOVFF  101,B00
0B0E4:  CALL   513E
0B0E8:  MOVFF  01,8F
....................                write_eeprom(31,Entero); 
0B0EC:  CLRF   FAA
0B0EE:  MOVLW  1F
0B0F0:  MOVWF  FA9
0B0F2:  MOVFF  8E,FA8
0B0F6:  BCF    FA6.6
0B0F8:  BCF    FA6.7
0B0FA:  BSF    FA6.2
0B0FC:  MOVF   FF2,W
0B0FE:  MOVWF  00
0B100:  BCF    FF2.6
0B102:  BCF    FF2.7
0B104:  MOVLB  F
0B106:  MOVLW  55
0B108:  MOVWF  FA7
0B10A:  MOVLW  AA
0B10C:  MOVWF  FA7
0B10E:  BSF    FA6.1
0B110:  BTFSC  FA6.1
0B112:  BRA    B110
0B114:  BCF    FA6.2
0B116:  MOVF   00,W
0B118:  IORWF  FF2,F
....................                delay_ms(20); 
0B11A:  MOVLW  14
0B11C:  MOVLB  B
0B11E:  MOVWF  x22
0B120:  MOVLB  0
0B122:  CALL   11F6
....................                write_eeprom(32,Decimal1); 
0B126:  CLRF   FAA
0B128:  MOVLW  20
0B12A:  MOVWF  FA9
0B12C:  MOVFF  8F,FA8
0B130:  BCF    FA6.6
0B132:  BCF    FA6.7
0B134:  BSF    FA6.2
0B136:  MOVF   FF2,W
0B138:  MOVWF  00
0B13A:  BCF    FF2.6
0B13C:  BCF    FF2.7
0B13E:  MOVLB  F
0B140:  MOVLW  55
0B142:  MOVWF  FA7
0B144:  MOVLW  AA
0B146:  MOVWF  FA7
0B148:  BSF    FA6.1
0B14A:  BTFSC  FA6.1
0B14C:  BRA    B14A
0B14E:  BCF    FA6.2
0B150:  MOVF   00,W
0B152:  IORWF  FF2,F
....................                delay_ms(20); 
0B154:  MOVLW  14
0B156:  MOVLB  B
0B158:  MOVWF  x22
0B15A:  MOVLB  0
0B15C:  CALL   11F6
....................                write_eeprom(40,Vel1); 
0B160:  CLRF   FAA
0B162:  MOVLW  28
0B164:  MOVWF  FA9
0B166:  MOVFF  93,FA8
0B16A:  BCF    FA6.6
0B16C:  BCF    FA6.7
0B16E:  BSF    FA6.2
0B170:  MOVF   FF2,W
0B172:  MOVWF  00
0B174:  BCF    FF2.6
0B176:  BCF    FF2.7
0B178:  MOVLB  F
0B17A:  MOVLW  55
0B17C:  MOVWF  FA7
0B17E:  MOVLW  AA
0B180:  MOVWF  FA7
0B182:  BSF    FA6.1
0B184:  BTFSC  FA6.1
0B186:  BRA    B184
0B188:  BCF    FA6.2
0B18A:  MOVF   00,W
0B18C:  IORWF  FF2,F
....................                delay_ms(20); 
0B18E:  MOVLW  14
0B190:  MOVLB  B
0B192:  MOVWF  x22
0B194:  MOVLB  0
0B196:  CALL   11F6
....................                write_eeprom(41,Vel2); 
0B19A:  CLRF   FAA
0B19C:  MOVLW  29
0B19E:  MOVWF  FA9
0B1A0:  MOVFF  94,FA8
0B1A4:  BCF    FA6.6
0B1A6:  BCF    FA6.7
0B1A8:  BSF    FA6.2
0B1AA:  MOVF   FF2,W
0B1AC:  MOVWF  00
0B1AE:  BCF    FF2.6
0B1B0:  BCF    FF2.7
0B1B2:  MOVLB  F
0B1B4:  MOVLW  55
0B1B6:  MOVWF  FA7
0B1B8:  MOVLW  AA
0B1BA:  MOVWF  FA7
0B1BC:  BSF    FA6.1
0B1BE:  BTFSC  FA6.1
0B1C0:  BRA    B1BE
0B1C2:  BCF    FA6.2
0B1C4:  MOVF   00,W
0B1C6:  IORWF  FF2,F
....................                delay_ms(20); 
0B1C8:  MOVLW  14
0B1CA:  MOVLB  B
0B1CC:  MOVWF  x22
0B1CE:  MOVLB  0
0B1D0:  CALL   11F6
....................                 
....................                Temporal=Relacion; 
0B1D4:  MOVFF  2C4,100
0B1D8:  MOVFF  2C3,FF
0B1DC:  MOVFF  2C2,FE
0B1E0:  MOVFF  2C1,FD
....................                Entero=(int)Relacion; 
0B1E4:  MOVFF  2C4,B03
0B1E8:  MOVFF  2C3,B02
0B1EC:  MOVFF  2C2,B01
0B1F0:  MOVFF  2C1,B00
0B1F4:  CALL   513E
0B1F8:  MOVFF  01,8E
....................                Temporal=Temporal-Entero; 
0B1FC:  MOVLB  B
0B1FE:  CLRF   x20
0B200:  MOVFF  8E,B1F
0B204:  MOVLB  0
0B206:  CALL   136C
0B20A:  BSF    FD8.1
0B20C:  MOVFF  100,B26
0B210:  MOVFF  FF,B25
0B214:  MOVFF  FE,B24
0B218:  MOVFF  FD,B23
0B21C:  MOVFF  03,B2A
0B220:  MOVFF  02,B29
0B224:  MOVFF  01,B28
0B228:  MOVFF  00,B27
0B22C:  CALL   1500
0B230:  MOVFF  03,100
0B234:  MOVFF  02,FF
0B238:  MOVFF  01,FE
0B23C:  MOVFF  00,FD
....................                Temporal2=Temporal*100.0; 
0B240:  MOVFF  100,B26
0B244:  MOVFF  FF,B25
0B248:  MOVFF  FE,B24
0B24C:  MOVFF  FD,B23
0B250:  MOVLB  B
0B252:  CLRF   x2A
0B254:  CLRF   x29
0B256:  MOVLW  48
0B258:  MOVWF  x28
0B25A:  MOVLW  85
0B25C:  MOVWF  x27
0B25E:  MOVLB  0
0B260:  CALL   3908
0B264:  MOVFF  03,104
0B268:  MOVFF  02,103
0B26C:  MOVFF  01,102
0B270:  MOVFF  00,101
....................                Decimal1=(int8)Temporal2; 
0B274:  MOVFF  104,B03
0B278:  MOVFF  103,B02
0B27C:  MOVFF  102,B01
0B280:  MOVFF  101,B00
0B284:  CALL   513E
0B288:  MOVFF  01,8F
....................                write_eeprom(52,Entero); 
0B28C:  CLRF   FAA
0B28E:  MOVLW  34
0B290:  MOVWF  FA9
0B292:  MOVFF  8E,FA8
0B296:  BCF    FA6.6
0B298:  BCF    FA6.7
0B29A:  BSF    FA6.2
0B29C:  MOVF   FF2,W
0B29E:  MOVWF  00
0B2A0:  BCF    FF2.6
0B2A2:  BCF    FF2.7
0B2A4:  MOVLB  F
0B2A6:  MOVLW  55
0B2A8:  MOVWF  FA7
0B2AA:  MOVLW  AA
0B2AC:  MOVWF  FA7
0B2AE:  BSF    FA6.1
0B2B0:  BTFSC  FA6.1
0B2B2:  BRA    B2B0
0B2B4:  BCF    FA6.2
0B2B6:  MOVF   00,W
0B2B8:  IORWF  FF2,F
....................                delay_ms(20); 
0B2BA:  MOVLW  14
0B2BC:  MOVLB  B
0B2BE:  MOVWF  x22
0B2C0:  MOVLB  0
0B2C2:  CALL   11F6
....................                write_eeprom(53,Decimal1); 
0B2C6:  CLRF   FAA
0B2C8:  MOVLW  35
0B2CA:  MOVWF  FA9
0B2CC:  MOVFF  8F,FA8
0B2D0:  BCF    FA6.6
0B2D2:  BCF    FA6.7
0B2D4:  BSF    FA6.2
0B2D6:  MOVF   FF2,W
0B2D8:  MOVWF  00
0B2DA:  BCF    FF2.6
0B2DC:  BCF    FF2.7
0B2DE:  MOVLB  F
0B2E0:  MOVLW  55
0B2E2:  MOVWF  FA7
0B2E4:  MOVLW  AA
0B2E6:  MOVWF  FA7
0B2E8:  BSF    FA6.1
0B2EA:  BTFSC  FA6.1
0B2EC:  BRA    B2EA
0B2EE:  BCF    FA6.2
0B2F0:  MOVF   00,W
0B2F2:  IORWF  FF2,F
....................                delay_ms(20); 
0B2F4:  MOVLW  14
0B2F6:  MOVLB  B
0B2F8:  MOVWF  x22
0B2FA:  MOVLB  0
0B2FC:  CALL   11F6
....................                 
....................                write_eeprom(57,mediaMovil); 
0B300:  CLRF   FAA
0B302:  MOVLW  39
0B304:  MOVWF  FA9
0B306:  MOVFF  95,FA8
0B30A:  BCF    FA6.6
0B30C:  BCF    FA6.7
0B30E:  BSF    FA6.2
0B310:  MOVF   FF2,W
0B312:  MOVWF  00
0B314:  BCF    FF2.6
0B316:  BCF    FF2.7
0B318:  MOVLB  F
0B31A:  MOVLW  55
0B31C:  MOVWF  FA7
0B31E:  MOVLW  AA
0B320:  MOVWF  FA7
0B322:  BSF    FA6.1
0B324:  BTFSC  FA6.1
0B326:  BRA    B324
0B328:  BCF    FA6.2
0B32A:  MOVF   00,W
0B32C:  IORWF  FF2,F
....................                delay_ms(20); 
0B32E:  MOVLW  14
0B330:  MOVLB  B
0B332:  MOVWF  x22
0B334:  MOVLB  0
0B336:  CALL   11F6
....................                GuardaEEPROM=ON; 
0B33A:  BSF    x7E.6
....................             } 
....................             printf("page Ajustes"); 
0B33C:  MOVLW  B2
0B33E:  MOVWF  FF6
0B340:  MOVLW  11
0B342:  MOVWF  FF7
0B344:  MOVLW  00
0B346:  MOVWF  FF8
0B348:  CALL   1304
....................             SendDataDisplay(); 
0B34C:  CALL   1336
....................             //BorraBuffer(); 
....................          } 
....................       } 
....................       printf("fecha.txt=\"Fecha:%02u/%02u/20%02u    Hora: %02u:%02u\"",Dia,Mes,Year,Hora,Minuto); 
0B350:  MOVLW  C0
0B352:  MOVWF  FF6
0B354:  MOVLW  11
0B356:  MOVWF  FF7
0B358:  MOVLW  00
0B35A:  MOVWF  FF8
0B35C:  MOVLW  11
0B35E:  MOVLB  B
0B360:  MOVWF  x02
0B362:  MOVLB  0
0B364:  CALL   5198
0B368:  MOVFF  98,B01
0B36C:  MOVLW  01
0B36E:  MOVLB  B
0B370:  MOVWF  x02
0B372:  MOVLB  0
0B374:  CALL   51F6
0B378:  MOVLW  2F
0B37A:  BTFSS  F9E.4
0B37C:  BRA    B37A
0B37E:  MOVWF  FAD
0B380:  MOVFF  97,B01
0B384:  MOVLW  01
0B386:  MOVLB  B
0B388:  MOVWF  x02
0B38A:  MOVLB  0
0B38C:  CALL   51F6
0B390:  MOVLW  2F
0B392:  BTFSS  F9E.4
0B394:  BRA    B392
0B396:  MOVWF  FAD
0B398:  MOVLW  32
0B39A:  BTFSS  F9E.4
0B39C:  BRA    B39A
0B39E:  MOVWF  FAD
0B3A0:  MOVLW  30
0B3A2:  BTFSS  F9E.4
0B3A4:  BRA    B3A2
0B3A6:  MOVWF  FAD
0B3A8:  MOVFF  96,B01
0B3AC:  MOVLW  01
0B3AE:  MOVLB  B
0B3B0:  MOVWF  x02
0B3B2:  MOVLB  0
0B3B4:  CALL   51F6
0B3B8:  MOVLW  E1
0B3BA:  MOVWF  FF6
0B3BC:  MOVLW  11
0B3BE:  MOVWF  FF7
0B3C0:  MOVLW  00
0B3C2:  MOVWF  FF8
0B3C4:  MOVLW  0A
0B3C6:  MOVLB  B
0B3C8:  MOVWF  x02
0B3CA:  MOVLB  0
0B3CC:  CALL   5198
0B3D0:  MOVFF  99,B01
0B3D4:  MOVLW  01
0B3D6:  MOVLB  B
0B3D8:  MOVWF  x02
0B3DA:  MOVLB  0
0B3DC:  CALL   51F6
0B3E0:  MOVLW  3A
0B3E2:  BTFSS  F9E.4
0B3E4:  BRA    B3E2
0B3E6:  MOVWF  FAD
0B3E8:  MOVFF  9A,B01
0B3EC:  MOVLW  01
0B3EE:  MOVLB  B
0B3F0:  MOVWF  x02
0B3F2:  MOVLB  0
0B3F4:  CALL   51F6
0B3F8:  MOVLW  22
0B3FA:  BTFSS  F9E.4
0B3FC:  BRA    B3FA
0B3FE:  MOVWF  FAD
....................       SendDataDisplay();  
0B400:  CALL   1336
....................     } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------        
....................  
....................    } 
0B404:  GOTO   6518
....................  
.................... } 
.................... int8 BIT_BYTE(int1 D0, int1 D1, int1 D2, int1 D3, int1 D4, int1 D5, int1 D6, int1 D7){ 
....................    int8 dato; 
0B408:  SLEEP 
....................    dato= D7*128 + D6*64 + D5*32 + D4*16 + D3*8 + D2*4 + D1*2 +D0*1; // 0 al 255  
*
033EC:  MOVLB  B
033EE:  MOVF   x0F,W
033F0:  MULLW  80
033F2:  MOVFF  FF3,B11
033F6:  MOVF   x0E,W
033F8:  MULLW  40
033FA:  MOVF   FF3,W
033FC:  ADDWF  x11,F
033FE:  MOVF   x0D,W
03400:  MULLW  20
03402:  MOVF   FF3,W
03404:  ADDWF  x11,F
03406:  MOVF   x0C,W
03408:  MULLW  10
0340A:  MOVF   FF3,W
0340C:  ADDWF  x11,F
0340E:  MOVF   x0B,W
03410:  MULLW  08
03412:  MOVF   FF3,W
03414:  ADDWF  x11,F
03416:  MOVF   x0A,W
03418:  MULLW  04
0341A:  MOVF   FF3,W
0341C:  ADDWF  x11,F
0341E:  BCF    FD8.0
03420:  RLCF   x09,W
03422:  ADDWF  x11,W
03424:  ADDWF  x08,W
03426:  MOVWF  x10
....................    return dato;  
03428:  MOVFF  B10,01
.................... } 
0342C:  MOVLB  0
0342E:  RETLW  00

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN
   Word  2: 1B1F   BROWNOUT WDT BORV20 NOPUT WDT8192
   Word  3: 0000   NOPBADEN NOLPT1OSC NOMCLR
   Word  4: 00B0   NOSTVREN NODEBUG NOLVP NOXINST BBSIZ4K
   Word  5: C03F   NOPROTECT NOCPD NOCPB
   Word  6: E03F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 403F   NOEBTR NOEBTRB
